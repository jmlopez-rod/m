{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>The goal of <code>m</code> is to help maintain Github projects. This usually involves keeping a CHANGELOG, building, publishing and releasing packages. To achieve this, <code>m</code> comes with several utilities that can be used in the Github pipelines and on the developer's local environment.</p> <p>This process makes <code>m</code> to be opinionated. If the following points are acceptable by the project's maintainers then <code>m</code> may be a nice integration.</p>"},{"location":"#caveats","title":"Caveats","text":""},{"location":"#github-repositories","title":"Github repositories","text":"<p>All communication with repositories is done strictly with Github. <code>git</code> is used locally via <code>ssh</code> but any other user and pull request information is obtained via Github's APIs.</p> <p>Warning</p> <p>The git configuration should use <code>ssh</code> instead of <code>http</code>. This is done to avoid issues with the developers prefered git tool and/or user interface.</p> <pre><code>[remote \"origin\"]\n  url = git@github.com:&lt;owner&gt;/&lt;repo&gt;.git\n</code></pre>"},{"location":"#changelog","title":"Changelog","text":"<p>All projects are required to have a <code>CHANGELOG.md</code> file that follows the keep a changelog format. All a developer is required to do is to write/verify that a changelog entry.</p>"},{"location":"#versioning","title":"Versioning","text":"<p>A lot of projects in Github use tags of the form <code>v1.2.3</code>. Here we drop the <code>v</code> and simply use the semantic version when creating releases.</p>"},{"location":"#development-flows","title":"Development flows","text":"<p><code>m</code> currently supports three development flows: <code>free-flow</code>, <code>git-flow</code> and the <code>m-flow</code>. Depending on the flow chosen for the project a few extra setup is required on the Github repository's settings.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>The format of this changelog is based on Keep a Changelog. The project adheres to Semantic Versioning</p> <p>Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#0.34.2","title":"0.34.2 -  May 08, 2024","text":"<ul> <li>Add <code>dependabot</code> as a default bypasser for the <code>CHANGELOG.md</code> check.</li> </ul>"},{"location":"changelog/#0.34.1","title":"0.34.1 -  May 08, 2024","text":"<ul> <li>Provide another way to bypass the check for <code>CHANGELOG.md</code> when creating a   pull request. We can add <code>changelog_bypassers</code> in the <code>m</code> configuration to a   list of github usernames that are allowed to bypass the check. this is useful   for bots like <code>dependabot</code>.</li> </ul>"},{"location":"changelog/#0.34.0","title":"0.34.0 -  May 06, 2024","text":"<ul> <li>We may provide <code>platforms</code> in the <code>m</code> configuration. This is helpful when we   do not have access to different architectures. In this case the architecture   flag is still needed but they can be build in the same runner. When platform   is provided we can specify <code>linux/arm64</code> in there.</li> </ul>"},{"location":"changelog/#0.33.1","title":"0.33.1 -  March 27, 2024","text":"<ul> <li><code>use_buildx</code> is set to <code>true</code> by default. This flag will go away in the future   and the buildx command will be used by default.</li> </ul>"},{"location":"changelog/#0.33.0","title":"0.33.0 -  March 26, 2024","text":"<ul> <li>Add <code>use_buildx</code> flag to <code>m</code> configuration to try use a buildx command when   creating multi-arch manifests. See   https://docs.docker.com/reference/cli/docker/buildx/imagetools/create/   Defaults to <code>false</code>. In the future it may be set to <code>true</code> by default or   removed completely if the buildx command replaces the old way.</li> <li>The <code>m ci env</code> command will fail if pull requests do not modify the   <code>CHANGELOG.md</code> file. This is to ensure that we are keeping track of the   changes that are being made to the project. If we need to bypass it we can set   <code>require_pr_changelog</code> to <code>false</code> in the <code>m</code> configuration. NOTE: Pull   requests with more than 100 file changes will not be checked.</li> </ul>"},{"location":"changelog/#0.32.1","title":"0.32.1 -  March 17, 2024","text":"<ul> <li>Revert docker/login-action@v4. There is no such version.</li> <li>When using <code>container</code> we expect the developer to specify the environment   variables, in particular make sure to specify <code>ARCH: ${{ matrix.arch }}</code>.</li> </ul>"},{"location":"changelog/#0.32.0","title":"0.32.0 -  March 16, 2024","text":"<ul> <li>Allow branches to be prefixed with <code>release</code> and <code>hotfix</code>. We are still not   checking for the pattern <code>release/x.y.z</code> but we should now be able to name a   branch <code>release-*</code> or <code>hotfix-ticket#</code>.</li> <li>The <code>m</code> configuration allows the declaration of other inputs for a Github   workflow. This can be added by declaring <code>workflow_inputs</code>.</li> <li>The <code>m</code> configuration allows the use of a container to use to build the image   for the workflow. This can be added by declaring <code>container</code>. This is needed   in cases where the runner may be missing other tools that are needed in the   extra steps.</li> <li><code>m end_release</code> performs <code>git pull</code> at the end of the process. This is to   ensure that the latest changes are in the default branch.</li> <li><code>m blueprints</code> uses latest github actions (v4).</li> </ul>"},{"location":"changelog/#0.31.1","title":"0.31.1 -  November 14, 2023","text":"<ul> <li>Compatibility with <code>pydantic</code> 2.5.</li> <li>Devtools: Set mypy to 1.6.1 since newest version complains about some   annotations. To be worked out in the next version.</li> </ul>"},{"location":"changelog/#0.31.0","title":"0.31.0 -  November 13, 2023","text":"<ul> <li>Add <code>run_if</code> field to <code>RunStep</code> and   <code>UsesStep</code>. This field allows us to   specify a condition that must be met in order to execute the step.</li> </ul>"},{"location":"changelog/#0.30.0","title":"0.30.0 -  November 09, 2023","text":"<ul> <li>Update text for autogenerated files</li> <li>Switch to <code>mkdocs</code>.</li> <li>Add <code>env_var_or_empty</code> and <code>env_var</code> argparse validators. These are necessary   so that we can avoid displaying the current value of the environment variable   when generating the documentation. This can be consider a breaking change in   the CLI since it will no longer display the value of the environment.</li> <li>Add github actions utilities to help us maintain Github actions.</li> <li>Add <code>validate_file_exists</code> argparse validator.</li> </ul>"},{"location":"changelog/#0.29.4","title":"0.29.4 -  September 27, 2023","text":"<ul> <li>Wraps colors around <code>\\[</code> and <code>\\]</code> for colors in <code>$PS1</code>. See   https://unix.stackexchange.com/a/157884</li> </ul>"},{"location":"changelog/#0.29.3","title":"0.29.3 -  September 26, 2023","text":"<ul> <li>Pydantic 2.4.1 no longer passes <code>json_schema_extra</code> in <code>Field</code> as is. Instead   it gets json serialized. The end result is that we cannot have functions in   it. The internal implementation in <code>m</code> has been changed so that we may   continue passing validators in that field. This should be better since we now   bypass a serialization step to find out the model schemas on the CLI.</li> </ul>"},{"location":"changelog/#0.29.2","title":"0.29.2 -  September 25, 2023","text":"<ul> <li>Manifests jobs for multi-architecture builds may fail if there are too many of   them running at once. To avoid this we can specify <code>max_parallel_manifests</code> in   the docker configuration so that it will add it to the github workflow. see   more info at   https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs#defining-the-maximum-number-of-concurrent-jobs</li> </ul>"},{"location":"changelog/#0.29.1","title":"0.29.1 -  September 25, 2023","text":"<ul> <li>compute proper architecture when running locally. We may need to add other   entries to the arch map.</li> </ul>"},{"location":"changelog/#0.29.0","title":"0.29.0 -  September 25, 2023","text":"<ul> <li>add <code>m blueprints</code>. This command combined with the <code>docker_config</code> field in   the <code>m</code> file will create a set of shell scripts that can be used to create,   tag, and push docker images. See <code>tests/blueprints</code> for examples on <code>m/m.yaml</code>   files and the scripts it creates in their respective <code>fixtures</code> directories.</li> </ul>"},{"location":"changelog/#0.28.0","title":"0.28.0 -  September 14, 2023","text":"<ul> <li>Add <code>--major-only</code> option to <code>m git tag_release</code>. This option allows us to   only update the major version tag.</li> <li>This project is switching to only moving the <code>major</code> tag and drops the minor   version tag.</li> </ul>"},{"location":"changelog/#0.27.3","title":"0.27.3 -  September 13, 2023","text":"<ul> <li>Typo on code. I hope this is the last hotfix for <code>m git tag_release</code>.</li> </ul>"},{"location":"changelog/#0.27.2","title":"0.27.2 -  September 13, 2023","text":"<ul> <li>Fix <code>m git tag_release</code> when executing on github actions. Need to first fetch   the tag that needs to be deleted.</li> </ul>"},{"location":"changelog/#0.27.1","title":"0.27.1 -  September 13, 2023","text":"<ul> <li>No changes to library. This release is to verify that <code>m git tag_release</code>   works in github workflows. Please note that if you are running in a container   you will need to add</li> </ul> <pre><code>git config --global --add safe.directory \"$GITHUB_WORKSPACE\"\n</code></pre> <p>before running <code>m git tag_release</code>.</p>"},{"location":"changelog/#0.27.0","title":"0.27.0 -  September 13, 2023","text":"<ul> <li>Add <code>m git tag_release</code>. This command allows us to tag a release. It is meant   to be used after <code>m github release</code> to create git tags that keep track of the   major and minor versions of a project. It assumes that the version provided is   a valid semver of the form <code>x.y.z</code>.</li> </ul>"},{"location":"changelog/#0.26.0","title":"0.26.0 -  September 09, 2023","text":"<ul> <li>Add <code>--section</code> to <code>m devcontainer bashrc</code> so that we may specify a bashrc   snippet that we want to print.</li> <li>Add <code>--bashrc</code> to <code>m ci env</code> to print a bashrc snippet.</li> </ul>"},{"location":"changelog/#0.25.2","title":"0.25.2 -  September 06, 2023","text":"<ul> <li><code>bashrc</code> code snippet avoids alias declaration in a CI environment.</li> </ul>"},{"location":"changelog/#0.25.1","title":"0.25.1 -  September 05, 2023","text":"<ul> <li>Fix issues with <code>pnpm_setup</code> not creating a directory as well as virtual   environment for a project.</li> </ul>"},{"location":"changelog/#0.25.0","title":"0.25.0 -  September 05, 2023","text":"<ul> <li>Add <code>devcontainer</code> command group to <code>m</code> cli. It includes</li> <li><code>bashrc</code>: used to print a snippet that should be source on a <code>.bashrc</code> file.</li> <li><code>greet</code>: displays a message with devcontainer information. To be used in the     <code>postStartCommand</code> section of a devcontainer file.</li> <li><code>pnpm_setup</code>: to be used in the <code>postStartCommand</code> to setup all the the     necessary symlinks for <code>pnpm</code> to be efficient in all docker containers     regardless of the host.</li> <li><code>pnpm</code>: a wrapper around <code>pnpm</code> to perform the <code>pnpm</code> command in a mounted     volume.</li> <li><code>prompter</code>: a command line prompt that can be used in bash to display the     current git status.</li> <li><code>require_env_vars</code>: meant to stop a bash script if the specified env vars     are not defined.</li> <li>Add <code>RemainderArgs</code> to <code>m.cli</code>. This is helpful to specify that we want to   obtain the rest of the arguments so that we may pass it to another process.</li> </ul>"},{"location":"changelog/#0.24.0","title":"0.24.0 -  September 03, 2023","text":"<ul> <li>Any module can be used as a cli command. If the module is a package then we   can use the <code>__main__.py</code> file to define the cli commands.</li> <li>Deprecated <code>run_cli</code> usage. Instead use <code>exec_cli</code>. This was done so that we   can delegate the responsibility of coming up with cli commands to other   functions.</li> <li>If <code>run_cli</code> was using the <code>add_arg</code> parameter then define the <code>add_arguments</code>   function at the root of the command modules. See <code>m/cli/commands/__init__.py</code>   as an example.</li> <li>Add <code>import_cli_commands</code>. This function allows us to import cli commands from   a module and use them in the <code>exec_cli</code> function.</li> <li>Add <code>cli_commands</code>, <code>command_group</code> and <code>subcommands</code> to <code>m.cli</code>. These are   functions to help generate cli commands to be used in <code>exec_cli</code>.</li> <li>Add <code>merge_cli_commands</code> to <code>m.cli</code>. This function allows us to merge cli   commands from different modules to create a single cli command.</li> <li>Deprecate use of <code>name</code> parameter in <code>command</code> decorator. This is no longer   needed since we can use the module name as the command name or any other name   if manually defining the cli.</li> <li>Add <code>Meta</code> to help define information about a group of cli commands.</li> </ul>"},{"location":"changelog/#0.23.0","title":"0.23.0 -  August 21, 2023","text":"<ul> <li>Migrated to pydantic v2.</li> <li>Add <code>ruff</code> support to <code>m ci celt</code> command.</li> </ul> <pre><code>m ci celt -t ruff -c @config.json &lt; &lt;(ruff check --format json [dir])\n</code></pre> <ul> <li>Added <code>m.cli.Arg</code> and <code>m.cli.ArgProxy</code>. These are replacements for pydantic's   <code>Field</code> since this function no longer supports the <code>extra</code> keyword arguments.</li> <li>Added <code>m.core.hone</code>. Helps avoid writing a lambda when trying to handle an   <code>Issue</code>. Instead of</li> </ul> <pre><code>res.flat_map_bad(lambda err: issue('new error message', cause=err, context=context))\n</code></pre> <p>we can write</p> <pre><code>res.flat_map_bad(hone('git stash failure', context=context))\n</code></pre> <ul> <li>Added <code>m.core.Res</code>. This is an alias for <code>OneOf[Issue, G]</code> so that we only   have to specify the type of the \"Result\" or \"Response\".</li> <li>Added <code>exception</code> method and other wrappers to the <code>Logger</code> class.</li> <li>Added <code>parse_model</code> and <code>load_model</code> to <code>m.pydantic</code>. These utilities allow us   to parse and load a data from files.</li> <li>Deprecated <code>add_arg</code>. Instead of</li> </ul> <pre><code>  prop: str = Field(\n      json_schema_extra={\n          'proxy': add_arg(\n              '--opt',\n              help='help description',\n          ),\n      },\n  )\n</code></pre> <p>we can write</p> <pre><code>  prop: str = ArgProxy(\n    '--opt',\n    help='help description',\n  )\n</code></pre> <ul> <li><code>OneOf</code> is no longer a base class for <code>Bad</code> and <code>Good</code>. Instead we use   <code>Union[Bad, Good]</code> to define a <code>OneOf</code>. Since python does not support type   narrowing in the negative case we have to rely on <code>isinstance</code> to check if an   object is <code>Good</code> or <code>Bad</code> and be able to access the <code>value</code> without having to   cast. See https://github.com/python/typing/discussions/1013.</li> <li>Deprecated <code>is_good</code> and <code>is_bad</code>. Instead use <code>isinstance</code> to check if an   object is <code>Good</code> or <code>Bad</code>. Doing so will prevent having to cast the object to   be able to extract the value when using <code>OneOf</code>.</li> </ul>"},{"location":"changelog/#0.22.1","title":"0.22.1 -  July 27, 2023","text":"<ul> <li>Add <code>argcomplete</code> as a dependency.</li> </ul>"},{"location":"changelog/#0.22.0","title":"0.22.0 -  July 27, 2023","text":"<ul> <li>Fix circular import bug. <code>python -c 'from m.core.io import env'</code> should not   fail.</li> <li>Completions for the <code>m</code> cli #86.</li> </ul>"},{"location":"changelog/#0.21.0","title":"0.21.0 -  April 27, 2023","text":"<ul> <li>The <code>build_tag_with_version</code> bumps the current version to the next minor   version and uses it when generating the m tag.</li> </ul>"},{"location":"changelog/#0.20.2","title":"0.20.2 -  April 27, 2023","text":"<ul> <li>no changes once again.</li> </ul>"},{"location":"changelog/#0.20.1","title":"0.20.1 -  April 27, 2023","text":"<ul> <li>no changes, making sure the release process works.</li> </ul>"},{"location":"changelog/#0.20.0","title":"0.20.0 -  April 27, 2023","text":"<ul> <li>update error message explaining <code>m.yaml</code> is missing.</li> <li>no longer publishing to npmjs or github</li> <li>improved devcontainer</li> <li>all files are formatted with prettier</li> </ul>"},{"location":"changelog/#0.19.3","title":"0.19.3 -  April 14, 2023","text":"<ul> <li><code>review_release</code> ignores previously closed prs.</li> </ul>"},{"location":"changelog/#0.19.2","title":"0.19.2 -  April 10, 2023","text":"<ul> <li>Support python 3.11. <code>Foo.BAR</code> in Python 3.11 no longer returns the member   value \"bar\" when used in the format() function or f-strings the way that prior   Python versions used to. Instead, it returns the <code>Foo.BAR</code> member class.</li> <li>See https://blog.pecar.me/python-enum. For now the fix involves overriding the   magic method <code>__str__</code> but should consider using <code>StrEnum</code>.</li> </ul>"},{"location":"changelog/#0.19.1","title":"0.19.1 -  March 29, 2023","text":"<ul> <li>Prevent failure when pull requests are done by accounts that may not have an   email.</li> </ul>"},{"location":"changelog/#0.19.0","title":"0.19.0 -  March 21, 2023","text":"<ul> <li>Add <code>typescript</code> processor to <code>m ci celt</code>.</li> </ul>"},{"location":"changelog/#0.18.1","title":"0.18.1 -  March 15, 2023","text":"<ul> <li>Fix pull request description for the git flow (bad comparison link).</li> <li>Yaml dumper handles string enums.</li> </ul>"},{"location":"changelog/#0.18.0","title":"0.18.0 -  March 15, 2023","text":"<ul> <li><code>m init</code> creates <code>m.yaml</code>.</li> <li>release tools handle <code>m.yaml</code> files as well as <code>m.json</code> files.</li> </ul>"},{"location":"changelog/#0.17.0","title":"0.17.0 -  March 14, 2023","text":"<ul> <li>Deprecate <code>reviewRelease</code>. Instead use <code>m review_release</code>.</li> <li>Add <code>m review_release</code>. It creates the backport pull request first so that the   logs point to the build with actual contents (for git flow projects).</li> <li>Delegate <code>m</code> configuration validation to pydantic.</li> <li><code>m.cli.validate_json_payload</code> handles <code>yaml</code> files. Commands that use this   validator can now handle <code>.json</code>, <code>.yaml</code> and <code>.yml</code> extensions.</li> <li><code>m</code> configuration file is expected to have extension <code>.yaml</code>, <code>.yml</code> or   <code>.json</code>. Projects should continue using <code>.json</code> extension for now since   <code>reviewRelease</code> is is not aware of <code>m.yaml</code>.</li> <li>Removed bash test files - everything is covered via <code>pytest</code>.</li> </ul>"},{"location":"changelog/#0.16.1","title":"0.16.1 -  March 13, 2023","text":"<ul> <li><code>end_release</code> fails because default branch already exists.</li> </ul>"},{"location":"changelog/#0.16.0","title":"0.16.0 -  March 13, 2023","text":"<ul> <li>Deprecate <code>endRelease</code>. Instead we can use <code>m end_release</code>.</li> <li>When ending a release it switches to the default branch.</li> <li>Previously a release could only be finished by the user who started it. This   can now be done by any user as long as they switch to the release/hotfix   branch and execute <code>m end_release</code>.</li> </ul>"},{"location":"changelog/#0.15.2","title":"0.15.2 -  March 04, 2023","text":"<ul> <li><code>m start_release</code> fails when a project has not done any releases. Command now   does an exception for the case when the latest release is <code>0.0.0</code> and avoids   checking for commits.</li> </ul>"},{"location":"changelog/#0.15.1","title":"0.15.1 -  February 25, 2023","text":"<ul> <li>Require pygments &gt;= 2.14.0 and python &gt;= 3.10.</li> </ul>"},{"location":"changelog/#0.15.0","title":"0.15.0 -  February 24, 2023","text":"<ul> <li>Deprecate <code>startRelease</code> and <code>startHotfix</code>. These two bash scripts have been   rewritten in python. Instead use can use <code>m start_release</code> and   <code>m start_hotfix</code>.</li> <li><code>m release_setup</code> has been switched to use a logger.</li> <li><code>yaml</code> output has been introduced as well as colors. Currently the only way to   disable colors is by using the env var <code>NO_COLOR=true</code>.</li> <li>All cli errors default to <code>yaml</code> format.</li> </ul>"},{"location":"changelog/#0.14.0","title":"0.14.0 -  February 20, 2023","text":"<ul> <li>Update <code>m init</code> to provide information on what it does</li> <li>Logger formatter defaults to using colors. May be disabled with   <code>NO_COLOR=true</code> env var.</li> <li><code>m.log.colors</code> provides the <code>color</code> function to format any message with color.</li> </ul>"},{"location":"changelog/#0.13.0","title":"0.13.0 -  February 18, 2023","text":"<ul> <li>Moved <code>ciTools</code> to the <code>m.log</code> module. From here on <code>print</code> statements will be   substituted by <code>logger.info</code>.</li> <li><code>run_main</code> renamed parameters, use <code>result_handler</code> and <code>issue_handler</code>.</li> <li>Introducing environment variables <code>DEBUG_M_[INSERT_SOMETHING_HERE]</code>. More on   that later in the docs. These are meant to make things a bit more verbose in a   local environment.</li> </ul>"},{"location":"changelog/#0.12.2","title":"0.12.2 -  February 09, 2023","text":"<ul> <li>Fix <code>m ci npm_tag</code>: Versions with multiple digits not being properly matched.</li> </ul>"},{"location":"changelog/#0.12.1","title":"0.12.1 -  February 02, 2023","text":"<ul> <li>skip release to npmjs - previous job did not publish to pypi.</li> </ul>"},{"location":"changelog/#0.12.0","title":"0.12.0 -  February 01, 2023","text":"<ul> <li>Using a devcontainer for local development and pipelines.</li> <li>100% python test coverage.</li> </ul> <p>Breaking Changes:</p> <ul> <li>cli utilities no longer use <code>add_parser</code>, using <code>command</code> and pydantic model   instead.</li> <li><code>Issue.data</code> replaced by <code>Issue.context</code>.</li> </ul>"},{"location":"changelog/#0.11.2","title":"0.11.2 -  October 13, 2022","text":"<ul> <li>Github graphql changed the order of releases. This hotfix is explicit about   the order in which we want them to obtain the latest release.</li> </ul>"},{"location":"changelog/#0.11.1","title":"0.11.1 -  September 30, 2022","text":"<ul> <li>Revert version prefix. To specify prereleases in npm we need to do   <code>&gt;0.0.0-b &lt;0.0.1</code>. Using version <code>999.0.0-</code> would not target pre-releases so   using <code>0.0.0</code> is a shorter string.</li> </ul>"},{"location":"changelog/#0.11.0","title":"0.11.0 -  September 30, 2022","text":"<ul> <li>Version prefix for non releases are now <code>999.0.0-</code>. This is done so that the   semver may work when installing pull request builds.</li> <li><code>fetch_response</code> has been added so that we may have access to the response   object as well. This is helpful when we need to inspect response headers.</li> </ul>"},{"location":"changelog/#0.10.1","title":"0.10.1 -  September 12, 2022","text":"<ul> <li>Add python 3.7 as a supported version.</li> </ul>"},{"location":"changelog/#0.10.0","title":"0.10.0 -  August 01, 2022","text":"<ul> <li>Add <code>npm</code> cli command which allows the use of <code>clean_tag</code> subcommand.</li> <li>Remove deprecated function <code>call_main</code>, use <code>run_main</code>.</li> </ul>"},{"location":"changelog/#0.9.0","title":"0.9.0 -  June 21, 2022","text":"<ul> <li>Add <code>build_tag_with_version</code> to <code>m</code> configuration: Allows build tags to use   the current version instead of <code>0.0.0</code>.</li> <li>Docusaurus have been introduced. There is no docs yet but the static site can   be accessed at https://jmlopez-rod.github.io/m/</li> </ul>"},{"location":"changelog/#0.8.0","title":"0.8.0 -  March 15, 2022","text":"<ul> <li>Make <code>m</code> <code>mypy</code> comptabible</li> <li>Linting and tests added.</li> </ul>"},{"location":"changelog/#0.7.1","title":"0.7.1 -  March 07, 2022","text":"<ul> <li>Require <code>typing_extensions</code> on python installations.</li> </ul>"},{"location":"changelog/#0.7.0","title":"0.7.0 -  March 06, 2022","text":"<p>fixes: <code>m ci celt</code> fails when project has no errors 669bc54</p> <p>changes: Trying not to use <code>Popen</code> to make bash calls 6babc6be</p> <p>features: Publishing to <code>npmjs</code> and <code>pypi</code>. Only releases are published to the public registries. In github we can access the package from prs and the latest on the <code>master</code> branch.</p>"},{"location":"changelog/#0.6.0","title":"0.6.0 -  September 14, 2021","text":"<ul> <li><code>m ci celt</code> has <code>-i</code> option to ignore error allowance. This is helpful when   working on single files or the whole project and we want to see all the errors   without having to edit the configuration.</li> <li><code>m ci celt</code> accepts <code>-1</code> as a valid value for the <code>-m</code> option. This will print   all the errors instead of partially showing them.</li> <li><code>-s</code> option in <code>celt</code> removes error allownances that are set to zero.</li> </ul>"},{"location":"changelog/#0.5.0","title":"0.5.0 -  September 11, 2021","text":"<ul> <li>Breaking Change: Renamed <code>m ci lint</code> to <code>m ci celt</code>.</li> <li><code>celt</code> cli command adds the following options:</li> <li><code>--full-message</code>: Display the whole error message (useful with pylint)</li> <li><code>--file-regex</code>: When provided it only displays errors of files matching it.</li> <li><code>--file-prefix</code>: A string of the form <code>[old]:[new]</code>. It modifies a file     prefix that matches <code>old</code> for <code>new</code>. Useful to display file paths when     running in docker.</li> <li><code>--stats-only</code>: Displays the current number of violations for each rule.</li> </ul>"},{"location":"changelog/#0.4.0","title":"0.4.0 -  September 02, 2021","text":"<ul> <li>Add <code>m github latest_release</code> to check the latest version of a github repo.</li> <li>Fix issues with <code>startRelease.sh</code> and <code>startHotfix.sh</code> authenticating to   github by using the <code>latest_release</code> command.</li> </ul>"},{"location":"changelog/#0.3.1","title":"0.3.1 -  September 02, 2021","text":"<ul> <li>Fix startRelease and startHotfix scripts. When starting a release, the script   cannot detect the latest version by fetching the tags when using the git-flow   because the latest tag is in the master branch not develop.</li> </ul>"},{"location":"changelog/#0.3.0","title":"0.3.0 -  September 01, 2021","text":"<p>Breaking Changes:</p> <ul> <li>releaseFrom field is no longer used in the m configuration.</li> <li>To continue releasing versions we need to specify a \"workflow\":</li> <li>free_flow: No version, only tags.</li> <li>m_flow: Uses versions but only the master branch is needed.</li> <li>git_flow: Users versions and it uses master and develop branch.</li> <li>Removed <code>releaseSetup.sh</code>. Instead we should use:</li> <li><code>startRelease.sh</code> and <code>startHotfix.sh</code>.</li> </ul> <p>Features:</p> <ul> <li>Add <code>reviewRelease.sh</code> to quickly commit the changes and open up a PR.</li> <li>Add <code>endRelease.sh</code> to merge the PR.</li> </ul>"},{"location":"changelog/#0.2.0","title":"0.2.0 -  August 25, 2021","text":"<ul> <li>Add <code>-m, --max-lines</code> to <code>m ci lint</code> command. It allows us to specify the   maximum lines that the command should display per error. It defaults to 5.</li> <li>Fix releaseSetup.sh output. With the deprecation of <code>call_main</code> and a previous   change that was done to it, the releaseSetup and other commands display 0   after a successful run.</li> </ul>"},{"location":"changelog/#0.1.0","title":"0.1.0 -  August 21, 2021","text":"<ul> <li>Order results from <code>m ci lint</code> based on the number of errors found.</li> <li>Add command line option to specify branch when creating a github release.</li> </ul>"},{"location":"changelog/#0.0.3","title":"0.0.3 -  August 14, 2021","text":"<ul> <li>Issue objects can hide the traceback from displaying</li> <li>Add <code>format_seconds</code> function.</li> <li>Deprecate <code>call_main</code>: use <code>run_main</code></li> <li><code>run_main</code> allows us to handle the results and issues.</li> <li> <p><code>m ci lint</code> supports the output of</p> </li> <li> <p>eslint</p> </li> <li>pycodestyle</li> <li>pylint</li> </ul> <p>The tool allows us to make the linters continue with the ci process as long as   we do not introduce any more errors. See more details by checking the help   options <code>m ci lint -h</code>.</p>"},{"location":"changelog/#0.0.2","title":"0.0.2 -  July 28, 2021","text":"<ul> <li>Adds github release command.</li> <li>releaseSetup.sh allows creation of release from any branch.</li> <li>Fixes issues with http module that may arise when a response is 500.</li> </ul>"},{"location":"changelog/#0.0.1","title":"0.0.1 -  July 05, 2021","text":"<ul> <li>Provides basic utilities to create a CI/CD flow via the m cli.</li> <li>As a library, it facilities the creation of clis similar to m.</li> </ul>"},{"location":"install/","title":"Packaged versions","text":"<p>You can download it from the Python Package Index. For installation of packages from PyPI, try pip, it works on all major platforms.</p> <pre><code>pip install jmlopez-m\n</code></pre> <p>To install from a branch run</p> <pre><code>pip install git+https://github.com/jmlopez-rod/m.git@[branch-name]\n</code></pre> <p>or</p> <pre><code>poetry add git+https://github.com/jmlopez-rod/m.git@[branch-name]\n</code></pre>"},{"location":"install/#compatibility","title":"Compatibility","text":"<p>Requires <code>python &gt;= 3.10</code>.</p>"},{"location":"install/#argcomplete","title":"<code>argcomplete</code>","text":"<p>The <code>m</code> cli is made with argcomplete. To set it up follow the following depending on your shell</p> <pre><code># for fish shell\nregister-python-argcomplete --shell fish m &gt; /tmp/foo\nsudo mv /tmp/foo /usr/share/fish/vendor_functions.d/m.fish\n\n# for bash shell\nregister-python-argcomplete --shell bash m &gt; /tmp/foo\nsudo mv /tmp/foo /usr/share/bash-completion/completions/m\n\n# for zsh\nregister-python-argcomplete --shell zsh m &gt; /tmp/foo\nsudo mv /tmp/foo /usr/share/zsh/site-functions/_m\n</code></pre>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>m<ul> <li>ci<ul> <li>assert_branch</li> <li>celt<ul> <li>core<ul> <li>io</li> <li>process</li> <li>types</li> </ul> </li> <li>post_processor</li> <li>post_processors<ul> <li>eslint</li> <li>pycodestyle</li> <li>pylint</li> <li>ruff</li> <li>typescript</li> </ul> </li> </ul> </li> <li>config</li> <li>docker<ul> <li>config</li> <li>docker_build</li> <li>env</li> <li>filenames</li> <li>gh_workflow_multi</li> <li>gh_workflow_single</li> <li>image</li> <li>shell_command</li> <li>shell_scripts</li> <li>tags</li> <li>workflow_input</li> </ul> </li> <li>end_release</li> <li>git_env</li> <li>init</li> <li>m_blueprints</li> <li>m_env</li> <li>release_env</li> <li>release_setup</li> <li>release_utils</li> <li>review_release</li> <li>start_release</li> <li>types</li> <li>versioning</li> </ul> </li> <li>cli<ul> <li>args</li> <li>cli</li> <li>engine<ul> <li>argparse</li> <li>misc</li> <li>parsers<ul> <li>boolean</li> <li>positional</li> <li>proxy</li> <li>remainder</li> <li>standard</li> </ul> </li> <li>sys</li> <li>types</li> </ul> </li> <li>handlers</li> <li>validators</li> </ul> </li> <li>color<ul> <li>colors</li> <li>disable</li> <li>pygment</li> </ul> </li> <li>core<ul> <li>fp</li> <li>http</li> <li>io</li> <li>issue</li> <li>json</li> <li>maybe</li> <li>one_of</li> <li>rw</li> <li>subprocess</li> <li>types</li> <li>yaml</li> <li>yaml_fp</li> </ul> </li> <li>devcontainer<ul> <li>bashrc</li> <li>env</li> <li>greet</li> <li>pnpm</li> <li>prompter</li> </ul> </li> <li>git</li> <li>github<ul> <li>actions<ul> <li>action_file</li> <li>actions</li> <li>api</li> <li>builder</li> <li>misc</li> <li>system</li> </ul> </li> <li>api</li> <li>ci</li> <li>ci_dataclasses</li> <li>ci_graph_queries</li> <li>cli</li> <li>graphql<ul> <li>api</li> <li>enums</li> <li>generics</li> <li>queries<ul> <li>branch_prs</li> </ul> </li> </ul> </li> <li>request</li> </ul> </li> <li>log<ul> <li>ci_tools<ul> <li>ci_tools</li> <li>providers<ul> <li>github</li> <li>local</li> <li>teamcity</li> </ul> </li> <li>types</li> </ul> </li> <li>config</li> <li>formatters</li> <li>handlers</li> <li>logger</li> <li>misc</li> </ul> </li> <li>npm<ul> <li>clean_tags</li> <li>cli</li> <li>tag</li> </ul> </li> <li>pydantic</li> <li>testing<ul> <li>conftest</li> <li>testing</li> </ul> </li> <li>version</li> </ul> </li> </ul>"},{"location":"api/m/","title":"m","text":""},{"location":"api/m/git/","title":"git","text":""},{"location":"api/m/git/#m.git.checkout_branch","title":"<code>checkout_branch(branch, create=True)</code>","text":"<p>Checkout a branch.</p> <p>Parameters:</p> Name Type Description Default <code>branch</code> <code>str</code> <p>name of branch to checkout</p> required <code>create</code> <code>bool</code> <p>create new branch</p> <code>True</code> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> of the git response.</p> Source code in <code>m/git.py</code> <pre><code>def checkout_branch(branch: str, create: bool = True) -&gt; Res[str]:\n    \"\"\"Checkout a branch.\n\n    Args:\n        branch: name of branch to checkout\n        create: create new branch\n\n    Returns:\n        A `OneOf` containing an `Issue` of the git response.\n    \"\"\"\n    opt = '-b' if create else ''\n    res = subprocess.eval_cmd(f'git checkout {opt} {branch}')\n    return res.flat_map_bad(hone('git checkout failure'))\n</code></pre>"},{"location":"api/m/git/#m.git.commit","title":"<code>commit(msg)</code>","text":"<p>Create a commit.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>commit description.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from the git command.</p> Source code in <code>m/git.py</code> <pre><code>def commit(msg: str) -&gt; Res[str]:\n    \"\"\"Create a commit.\n\n    Args:\n        msg: commit description.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from the git command.\n    \"\"\"\n    res = subprocess.eval_cmd(f'git commit -m \"{msg}\"')\n    return res.flat_map_bad(hone('git commit failure'))\n</code></pre>"},{"location":"api/m/git/#m.git.get_branch","title":"<code>get_branch()</code>","text":"<p>Get the current git branch name.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a string specifying the branch.</p> Source code in <code>m/git.py</code> <pre><code>def get_branch() -&gt; Res[str]:\n    \"\"\"Get the current git branch name.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a string specifying the branch.\n    \"\"\"\n    return subprocess.eval_cmd('git rev-parse --abbrev-ref HEAD')\n</code></pre>"},{"location":"api/m/git/#m.git.get_commits","title":"<code>get_commits(first, latest='HEAD')</code>","text":"<p>Get a list of all the commits between two tags.</p> <p>May return <code>None</code> in the special case when <code>first</code> is <code>0.0.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>first</code> <code>str</code> <p>The first tag.</p> required <code>latest</code> <code>str</code> <p>The second tag, defaults to HEAD.</p> <code>'HEAD'</code> <p>Returns:</p> Type Description <code>Res[list[str] | None]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of all the commits.</p> Source code in <code>m/git.py</code> <pre><code>def get_commits(\n    first: str,\n    latest: str = 'HEAD',\n) -&gt; Res[list[str] | None]:\n    \"\"\"Get a list of all the commits between two tags.\n\n    May return `None` in the special case when `first` is `0.0.0`.\n\n    Args:\n        first: The first tag.\n        latest: The second tag, defaults to HEAD.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of all the commits.\n    \"\"\"\n    if first == '0.0.0':\n        return Good(None)\n    cmd = f'git log {latest}...{first} --oneline --no-color'\n    return subprocess.eval_cmd(cmd).map(lambda out: out.splitlines())\n</code></pre>"},{"location":"api/m/git/#m.git.get_current_commit_sha","title":"<code>get_current_commit_sha()</code>","text":"<p>Find the sha of the current commit.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a string of the current commit sha.</p> Source code in <code>m/git.py</code> <pre><code>def get_current_commit_sha() -&gt; Res[str]:\n    \"\"\"Find the sha of the current commit.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a string of the current commit sha.\n    \"\"\"\n    return subprocess.eval_cmd('git rev-parse HEAD')\n</code></pre>"},{"location":"api/m/git/#m.git.get_first_commit_sha","title":"<code>get_first_commit_sha()</code>","text":"<p>Find the first commit sha in the repository.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a string of the first commit sha.</p> Source code in <code>m/git.py</code> <pre><code>def get_first_commit_sha() -&gt; Res[str]:\n    \"\"\"Find the first commit sha in the repository.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a string of the first commit sha.\n    \"\"\"\n    return subprocess.eval_cmd('git rev-list --max-parents=0 HEAD')\n</code></pre>"},{"location":"api/m/git/#m.git.get_remote_url","title":"<code>get_remote_url()</code>","text":"<p>Find the remote url of the repo.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a string with the url.</p> Source code in <code>m/git.py</code> <pre><code>def get_remote_url() -&gt; Res[str]:\n    \"\"\"Find the remote url of the repo.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a string with the url.\n    \"\"\"\n    return subprocess.eval_cmd('git config --get remote.origin.url')\n</code></pre>"},{"location":"api/m/git/#m.git.get_repo_path","title":"<code>get_repo_path()</code>","text":"<p>Get the absolute path to the repository.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>An issue or a string of the path to the repo.</p> Source code in <code>m/git.py</code> <pre><code>def get_repo_path() -&gt; Res[str]:\n    \"\"\"Get the absolute path to the repository.\n\n    Returns:\n        An issue or a string of the path to the repo.\n    \"\"\"\n    return subprocess.eval_cmd('git rev-parse --show-toplevel')\n</code></pre>"},{"location":"api/m/git/#m.git.get_status","title":"<code>get_status(*, check_stash=False)</code>","text":"<p>Find the current git status.</p> <p>Note that checking for stashed changes is not part of the regular git status. To opt in you must set <code>check_stash=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>check_stash</code> <code>bool</code> <p>Check if there are any stashed changes.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[tuple[str, str]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a word denoting the git status.</p> Source code in <code>m/git.py</code> <pre><code>def get_status(*, check_stash: bool = False) -&gt; Res[tuple[str, str]]:\n    \"\"\"Find the current git status.\n\n    Note that checking for stashed changes is not part of the regular git\n    status. To opt in you must set `check_stash=True`.\n\n    Args:\n        check_stash: Check if there are any stashed changes.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a word denoting the git status.\n    \"\"\"\n    res = subprocess.eval_cmd('git status')\n    if check_stash:\n        stash_files = subprocess.eval_cmd('git stash show').get_or_else('')\n        has_untracked = res.get_or_else('').startswith('Untracked files')\n        if not has_untracked and stash_files:\n            return Good(('stash', 'stash'))\n    return one_of(\n        lambda: [\n            _extract_status(msg)\n            for msg in res\n        ],\n    )\n</code></pre>"},{"location":"api/m/git/#m.git.list_tags","title":"<code>list_tags(pattern)</code>","text":"<p>List all the tags matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>The pattern to match.</p> required <p>Returns:</p> Type Description <code>Res[dict[str, str]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a string specifying the branch.</p> Source code in <code>m/git.py</code> <pre><code>def list_tags(pattern: str) -&gt; Res[dict[str, str]]:\n    \"\"\"List all the tags matching a pattern.\n\n    Args:\n        pattern: The pattern to match.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a string specifying the branch.\n    \"\"\"\n    cmd = f'git ls-remote --tags origin -l \"{pattern}\"'\n    return one_of(\n        lambda: [\n            _list_tags(output)\n            for output in subprocess.eval_cmd(cmd)\n        ],\n    )\n</code></pre>"},{"location":"api/m/git/#m.git.pull","title":"<code>pull()</code>","text":"<p>Pull branch.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from the git command.</p> Source code in <code>m/git.py</code> <pre><code>def pull() -&gt; Res[str]:\n    \"\"\"Pull branch.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from the git command.\n    \"\"\"\n    res = subprocess.eval_cmd('git pull')\n    return res.flat_map_bad(hone('git pull failure'))\n</code></pre>"},{"location":"api/m/git/#m.git.push_branch","title":"<code>push_branch(branch)</code>","text":"<p>Push branch.</p> <p>Parameters:</p> Name Type Description Default <code>branch</code> <code>str</code> <p>name of branch to push.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from the command.</p> Source code in <code>m/git.py</code> <pre><code>def push_branch(branch: str) -&gt; Res[str]:\n    \"\"\"Push branch.\n\n    Args:\n        branch: name of branch to push.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from the command.\n    \"\"\"\n    res = subprocess.eval_cmd(f'git push -u origin \"{branch}\"')\n    return res.flat_map_bad(hone('git push failure'))\n</code></pre>"},{"location":"api/m/git/#m.git.raw_status","title":"<code>raw_status()</code>","text":"<p>Obtain the output of \"git status\".</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the output of \"git status\".</p> Source code in <code>m/git.py</code> <pre><code>def raw_status() -&gt; Res[str]:\n    \"\"\"Obtain the output of \"git status\".\n\n    Returns:\n        A `OneOf` containing an `Issue` or the output of \"git status\".\n    \"\"\"\n    return subprocess.eval_cmd('git status')\n</code></pre>"},{"location":"api/m/git/#m.git.remove_git_tag","title":"<code>remove_git_tag(tag)</code>","text":"<p>Remove a git tag.</p> <p>It is important to remove the local tag before removing the remote tag.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The tag to remove.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from the git command.</p> Source code in <code>m/git.py</code> <pre><code>def remove_git_tag(tag: str) -&gt; Res[str]:\n    \"\"\"Remove a git tag.\n\n    It is important to remove the local tag before removing the remote tag.\n\n    Args:\n        tag: The tag to remove.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from the git command.\n    \"\"\"\n    tag_ref = f'refs/tags/{tag}'\n    return one_of(lambda: [\n        f'{local}\\n{remote}'\n        for _ in subprocess.eval_cmd(f'git fetch origin +{tag_ref}:{tag_ref}')\n        for local in subprocess.eval_cmd(f'git tag -d {tag}')\n        for remote in subprocess.eval_cmd(f'git push origin :{tag_ref}')\n    ])\n</code></pre>"},{"location":"api/m/git/#m.git.stage_all","title":"<code>stage_all()</code>","text":"<p>Stage the current changes in the branch.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from <code>git add .</code>.</p> Source code in <code>m/git.py</code> <pre><code>def stage_all() -&gt; Res[str]:\n    \"\"\"Stage the current changes in the branch.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from `git add .`.\n    \"\"\"\n    res = subprocess.eval_cmd('git add .')\n    return res.flat_map_bad(hone('git add failure'))\n</code></pre>"},{"location":"api/m/git/#m.git.stash","title":"<code>stash()</code>","text":"<p>Stash the current changes in the branch.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from <code>git stash</code>.</p> Source code in <code>m/git.py</code> <pre><code>def stash() -&gt; Res[str]:\n    \"\"\"Stash the current changes in the branch.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from `git stash`.\n    \"\"\"\n    return subprocess.eval_cmd('git stash')\n</code></pre>"},{"location":"api/m/git/#m.git.stash_pop","title":"<code>stash_pop()</code>","text":"<p>Pop the changes stored in the git stash.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from <code>git stash pop</code>.</p> Source code in <code>m/git.py</code> <pre><code>def stash_pop() -&gt; Res[str]:\n    \"\"\"Pop the changes stored in the git stash.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from `git stash pop`.\n    \"\"\"\n    return subprocess.eval_cmd('git stash pop')\n</code></pre>"},{"location":"api/m/git/#m.git.tag_release","title":"<code>tag_release(version, sha, *, major_only)</code>","text":"<p>Create a git tags for a release.</p> <p>This is done to keep a major and minor versions tags pointing to the latest.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>The version to tag.</p> required <code>sha</code> <code>str</code> <p>The commit sha to tag.</p> required <code>major_only</code> <code>bool</code> <p>Only create the major tag.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from the git command.</p> Source code in <code>m/git.py</code> <pre><code>def tag_release(version: str, sha: str, *, major_only: bool) -&gt; Res[str]:\n    \"\"\"Create a git tags for a release.\n\n    This is done to keep a major and minor versions tags pointing to the latest.\n\n    Args:\n        version: The version to tag.\n        sha: The commit sha to tag.\n        major_only: Only create the major tag.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from the git command.\n    \"\"\"\n    v_parts = version.split('.')\n    # Assuming the version is valid\n    major, minor = v_parts[0], v_parts[1]\n    major_tag = f'v{major}'\n    minor_tag = f'v{major}.{minor}'\n\n    return one_of(lambda: [\n        '\\n'.join([major_out, minor_out])\n        for all_tags in list_tags(f'v{major}*')\n        for major_out in update_git_tag(major_tag, sha, list(all_tags))\n        for minor_out in update_git_tag(\n            minor_tag,\n            sha,\n            list(all_tags),\n            skip=major_only,\n        )\n    ])\n</code></pre>"},{"location":"api/m/git/#m.git.update_git_tag","title":"<code>update_git_tag(tag, sha, remote_tags, *, skip=False)</code>","text":"<p>Create or move a git tag.</p> <p>The remote_tags should be provided to determine if we need to remove them before moving the tag. See https://stackoverflow.com/a/28280404 for more details on the git commands.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The tag to set.</p> required <code>sha</code> <code>str</code> <p>The commit sha to set the tag to.</p> required <code>remote_tags</code> <code>list[str]</code> <p>The list of remote tags.</p> required <code>skip</code> <code>bool</code> <p>Skip process if set to true.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from the git command.</p> Source code in <code>m/git.py</code> <pre><code>def update_git_tag(\n    tag: str,\n    sha: str,\n    remote_tags: list[str],\n    *,\n    skip: bool = False,\n) -&gt; Res[str]:\n    \"\"\"Create or move a git tag.\n\n    The remote_tags should be provided to determine if we need to remove them\n    before moving the tag. See https://stackoverflow.com/a/28280404 for more\n    details on the git commands.\n\n    Args:\n        tag: The tag to set.\n        sha: The commit sha to set the tag to.\n        remote_tags: The list of remote tags.\n        skip: Skip process if set to true.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from the git command.\n    \"\"\"\n    if skip:\n        return Good(f'skipping {tag}')\n    removal_output = ''\n    if tag in remote_tags:\n        removal_res = remove_git_tag(tag)\n        if isinstance(removal_res, Bad):\n            return Bad(removal_res.value)\n        removal_output = f'{removal_res.value}\\n'\n    return one_of(lambda: [\n        f'{removal_output}{local}\\n{remote}'\n        for local in subprocess.eval_cmd(f'git tag {tag} {sha}')\n        for remote in subprocess.eval_cmd(f'git push origin {tag}')\n    ])\n</code></pre>"},{"location":"api/m/pydantic/","title":"pydantic","text":""},{"location":"api/m/pydantic/#m.pydantic.CamelModel","title":"<code>CamelModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Allows models to be defined with camel case properties.</p> See <p>https://medium.com/analytics-vidhya/camel-case-models-with-fast-api-and-pydantic-5a8acb6c0eee</p> Source code in <code>m/pydantic.py</code> <pre><code>class CamelModel(BaseModel):\n    \"\"\"Allows models to be defined with camel case properties.\n\n    See:\n        https://medium.com/analytics-vidhya/camel-case-models-with-fast-api-and-pydantic-5a8acb6c0eee\n    \"\"\"\n\n    model_config = ConfigDict(\n        alias_generator=to_camel,\n        populate_by_name=True,\n    )\n</code></pre>"},{"location":"api/m/pydantic/#m.pydantic.KebabModel","title":"<code>KebabModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Allows models to be defined with kebab case properties.</p> <p>Inputs and outputs need to be written using a <code>KebabModel</code> as a base class. This is so that their definitions may be written using kebab casing in the final <code>action.yaml</code>.</p> <pre><code>from m.github.actions import KebabModel, InArg\n\nclass MyInput(KebabModel):\n    my_input: str = InArg(help='description')\n</code></pre> Source code in <code>m/pydantic.py</code> <pre><code>class KebabModel(BaseModel):\n    \"\"\"Allows models to be defined with kebab case properties.\n\n    Inputs and outputs need to be written using a `KebabModel` as a base class.\n    This is so that their definitions may be written using kebab casing in the\n    final `action.yaml`.\n\n    ```python\n    from m.github.actions import KebabModel, InArg\n\n    class MyInput(KebabModel):\n        my_input: str = InArg(help='description')\n    ```\n    \"\"\"\n\n    model_config = ConfigDict(\n        alias_generator=to_kebab,\n        populate_by_name=True,\n    )\n</code></pre>"},{"location":"api/m/pydantic/#m.pydantic.load_model","title":"<code>load_model(model, file_path, transform=None)</code>","text":"<p>Load a model from a json or yaml file.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[GenericModel]</code> <p>The class to create an instance of.</p> required <code>file_path</code> <code>str</code> <p>The path to the file.</p> required <code>transform</code> <code>DataTransformer | None</code> <p>A function to transform the data before creating the model.</p> <code>None</code> <p>Returns:</p> Type Description <code>Res[GenericModel]</code> <p>A <code>OneOf</code> with the model or an issue.</p> Source code in <code>m/pydantic.py</code> <pre><code>def load_model(\n    model: type[GenericModel],\n    file_path: str,\n    transform: DataTransformer | None = None,\n) -&gt; Res[GenericModel]:\n    \"\"\"Load a model from a json or yaml file.\n\n    Args:\n        model: The class to create an instance of.\n        file_path: The path to the file.\n        transform: A function to transform the data before creating the model.\n\n    Returns:\n        A `OneOf` with the model or an issue.\n    \"\"\"\n    context = {'file_path': file_path, 'model': str(model)}\n    transform_function = transform or Good\n    return one_of(\n        lambda: [\n            model_inst\n            for _ in assert_file_exists(file_path)\n            for model_data in read_yson(file_path)\n            for transformed_data in transform_function(model_data)\n            for model_inst in parse_model(model, transformed_data)\n        ],\n    ).flat_map_bad(hone('pydantic.load_model_failure', context))\n</code></pre>"},{"location":"api/m/pydantic/#m.pydantic.parse_model","title":"<code>parse_model(model, model_data)</code>","text":"<p>Parse a python object using pydantics TypeAdapter.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[GenericModel]</code> <p>The class to create an instance of.</p> required <code>model_data</code> <code>Any</code> <p>The data to parse.</p> required <p>Returns:</p> Type Description <code>Res[GenericModel]</code> <p>A <code>OneOf</code> with the model or an issue.</p> Source code in <code>m/pydantic.py</code> <pre><code>def parse_model(model: type[GenericModel], model_data: Any) -&gt; Res[GenericModel]:\n    \"\"\"Parse a python object using pydantics TypeAdapter.\n\n    Args:\n        model: The class to create an instance of.\n        model_data: The data to parse.\n\n    Returns:\n        A `OneOf` with the model or an issue.\n    \"\"\"\n    try:\n        return Good(TypeAdapter(model).validate_python(model_data))\n    except Exception as ex:\n        return issue('parse_model_failure', cause=ex)\n</code></pre>"},{"location":"api/m/pydantic/#m.pydantic.to_camel","title":"<code>to_camel(snake_case)</code>","text":"<p>Transform a string in snake_case to camel case.</p> <p>Parameters:</p> Name Type Description Default <code>snake_case</code> <code>str</code> <p>string in snake case.</p> required <p>Returns:</p> Type Description <code>str</code> <p>string in camel case.</p> Source code in <code>m/pydantic.py</code> <pre><code>def to_camel(snake_case: str) -&gt; str:\n    \"\"\"Transform a string in snake_case to camel case.\n\n    Args:\n        snake_case: string in snake case.\n\n    Returns:\n        string in camel case.\n    \"\"\"\n    s = sub('(_|-)+', ' ', snake_case).title().replace(' ', '')\n    return ''.join([s[0].lower(), s[1:]])\n</code></pre>"},{"location":"api/m/pydantic/#m.pydantic.to_kebab","title":"<code>to_kebab(snake_case)</code>","text":"<p>Transform a string in snake_case to kebab case.</p> <p>Parameters:</p> Name Type Description Default <code>snake_case</code> <code>str</code> <p>string in snake case.</p> required <p>Returns:</p> Type Description <code>str</code> <p>string in kebab case.</p> Source code in <code>m/pydantic.py</code> <pre><code>def to_kebab(snake_case: str) -&gt; str:\n    \"\"\"Transform a string in snake_case to kebab case.\n\n    Args:\n        snake_case: string in snake case.\n\n    Returns:\n        string in kebab case.\n    \"\"\"\n    return snake_case.replace('_', '-', -1)\n</code></pre>"},{"location":"api/m/version/","title":"version","text":""},{"location":"api/m/ci/","title":"ci","text":""},{"location":"api/m/ci/assert_branch/","title":"assert_branch","text":""},{"location":"api/m/ci/assert_branch/#m.ci.assert_branch.assert_branch","title":"<code>assert_branch(assertion_type, m_dir)</code>","text":"<p>Make sure git is using the correct branch based on the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>assertion_type</code> <code>str</code> <p>Either 'release' or 'hotfix'.</p> required <code>m_dir</code> <code>str</code> <p>The directory for the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[Config]</code> <p>A OneOf containing <code>None</code> or an <code>Issue</code>.</p> Source code in <code>m/ci/assert_branch.py</code> <pre><code>def assert_branch(assertion_type: str, m_dir: str) -&gt; Res[Config]:\n    \"\"\"Make sure git is using the correct branch based on the workflow.\n\n    Args:\n        assertion_type:\n            Either 'release' or 'hotfix'.\n        m_dir:\n            The directory for the m configuration.\n\n    Returns:\n        A OneOf containing `None` or an `Issue`.\n    \"\"\"\n    return one_of(lambda: [\n        config\n        for config in cfg_mod.read_config(m_dir)\n        for branch in git.get_branch()\n        for _ in _verify_branch(config, branch, assertion_type)\n    ])\n</code></pre>"},{"location":"api/m/ci/config/","title":"config","text":""},{"location":"api/m/ci/config/#m.ci.config.Config","title":"<code>Config</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Object to store the m project configuration.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <code>str</code> <p>...</p> <code>owner</code> <code>str</code> <p>...</p> <code>repo</code> <code>str</code> <p>...</p> <code>version</code> <code>str</code> <p>...</p> <code>workflow</code> <code>Workflow</code> <p>...</p> <code>require_pr_changelog</code> <code>bool</code> <p>...</p> <code>changelog_bypassers</code> <code>list[str]</code> <p>...</p> <code>git_flow</code> <code>GitFlowConfig</code> <p>...</p> <code>m_flow</code> <code>MFlowConfig</code> <p>...</p> <code>build_tag_with_version</code> <code>bool</code> <p>...</p> <code>docker_config</code> <code>DockerConfig | None</code> <p>...</p> Source code in <code>m/ci/config.py</code> <pre><code>class Config(BaseModel):\n    \"\"\"Object to store the m project configuration.\"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    m_dir: str\n    owner: str\n    repo: str\n    version: str = '0.0.0'\n    workflow: Workflow = Workflow.free_flow\n\n    # If true it will require an update to the changelog for every PR.\n    require_pr_changelog: bool = True\n\n    # List of github logins allowed to bypass the changelog requirement.\n    changelog_bypassers: list[str] = ['dependabot']\n\n    git_flow: GitFlowConfig = GitFlowConfig(\n        master_branch=Branches.master,\n        develop_branch=Branches.develop,\n        release_prefix=Branches.release,\n        hotfix_prefix=Branches.hotfix,\n    )\n    m_flow: MFlowConfig = MFlowConfig(\n        master_branch=Branches.master,\n        release_prefix=Branches.release,\n        hotfix_prefix=Branches.hotfix,\n    )\n    build_tag_with_version: bool = False\n    docker_config: DockerConfig | None = None\n\n    model_config = ConfigDict(use_enum_values=True)\n\n    def uses_git_flow(self) -&gt; bool:\n        \"\"\"Check if configuration is using the git flow.\n\n        Returns:\n            True if workflow is the git flow.\n        \"\"\"\n        return self.workflow == Workflow.git_flow\n\n    def uses_m_flow(self) -&gt; bool:\n        \"\"\"Check if configuration is using the m flow.\n\n        Returns:\n            True if workflow is the m flow.\n        \"\"\"\n        return self.workflow == Workflow.m_flow\n\n    def uses_free_flow(self) -&gt; bool:\n        \"\"\"Check if configuration is using the free flow.\n\n        Returns:\n            True if workflow is the free flow.\n        \"\"\"\n        return self.workflow == Workflow.free_flow\n\n    def get_master_branch(self) -&gt; str:\n        \"\"\"Obtain the name of the branch that aliases the \"master\" branch.\n\n        Returns:\n            The name/alias assigned to the `master` branch.\n        \"\"\"\n        if self.uses_m_flow():\n            return self.m_flow.master_branch\n        if self.uses_git_flow():\n            return self.git_flow.master_branch\n        return 'master'\n\n    def get_develop_branch(self) -&gt; str:\n        \"\"\"Obtain the name of the branch that aliases the \"develop\" branch.\n\n        Returns:\n            The name/alias assigned to the `develop` branch.\n        \"\"\"\n        if self.uses_git_flow():\n            return self.git_flow.develop_branch\n        return 'develop'\n\n    def get_default_branch(self) -&gt; str:\n        \"\"\"Obtain the name of the branch that aliases the \"default\" branch.\n\n        This is dependent on the flow. For instance, in the git flow we\n        use the `develop` branch as default.\n\n        Returns:\n            The name/alias assigned to the default branch.\n        \"\"\"\n        if self.uses_m_flow():\n            return self.m_flow.master_branch\n        if self.uses_git_flow():\n            return self.git_flow.develop_branch\n        return 'master'\n\n    def verify_version(\n        self,\n        gh_latest: str,\n        is_release_pr: bool,\n        is_release: bool,\n    ) -&gt; Res[int]:\n        \"\"\"Verify that the configuration version is valid.\n\n        Args:\n            gh_latest:\n                The version stored in `Github`. Checks are skipped if\n                this value is empty.\n            is_release_pr:\n                Set to `True` if the build is done during a release pr.\n            is_release:\n                Set to `True` if the build is done during a release.\n\n        Returns:\n            A `OneOf` containing 0 if all is well, otherwise an `Issue`.\n        \"\"\"\n        if not gh_latest:\n            return Good(0)\n        err_data = {\n            'config_version': self.version,\n            'gh_latest': gh_latest,\n            'is_release': is_release,\n            'is_release_pr': is_release_pr,\n        }\n        try:\n            p_ver = Version(self.version)\n        except Exception as ex:\n            return issue('error parsing version', cause=ex, context=err_data)\n        try:\n            p_latest = Version(gh_latest)\n        except Exception as ex:  # noqa: WPS440\n            return issue('error parsing latest', cause=ex, context=err_data)\n        ver_gt_latest = p_ver &gt; p_latest\n        ver_lt_latest = p_ver &lt; p_latest\n        msg: str = ''\n        if is_release_pr:\n            msg = _handle_release_pr(ver_gt_latest)\n        elif is_release:\n            msg = _handle_release(ver_gt_latest)\n        else:\n            msg = _handle_non_release(ver_lt_latest, ver_gt_latest)\n        return issue(msg, context=err_data) if msg else Good(0)\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.get_default_branch","title":"<code>get_default_branch()</code>","text":"<p>Obtain the name of the branch that aliases the \"default\" branch.</p> <p>This is dependent on the flow. For instance, in the git flow we use the <code>develop</code> branch as default.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name/alias assigned to the default branch.</p> Source code in <code>m/ci/config.py</code> <pre><code>def get_default_branch(self) -&gt; str:\n    \"\"\"Obtain the name of the branch that aliases the \"default\" branch.\n\n    This is dependent on the flow. For instance, in the git flow we\n    use the `develop` branch as default.\n\n    Returns:\n        The name/alias assigned to the default branch.\n    \"\"\"\n    if self.uses_m_flow():\n        return self.m_flow.master_branch\n    if self.uses_git_flow():\n        return self.git_flow.develop_branch\n    return 'master'\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.get_develop_branch","title":"<code>get_develop_branch()</code>","text":"<p>Obtain the name of the branch that aliases the \"develop\" branch.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name/alias assigned to the <code>develop</code> branch.</p> Source code in <code>m/ci/config.py</code> <pre><code>def get_develop_branch(self) -&gt; str:\n    \"\"\"Obtain the name of the branch that aliases the \"develop\" branch.\n\n    Returns:\n        The name/alias assigned to the `develop` branch.\n    \"\"\"\n    if self.uses_git_flow():\n        return self.git_flow.develop_branch\n    return 'develop'\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.get_master_branch","title":"<code>get_master_branch()</code>","text":"<p>Obtain the name of the branch that aliases the \"master\" branch.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name/alias assigned to the <code>master</code> branch.</p> Source code in <code>m/ci/config.py</code> <pre><code>def get_master_branch(self) -&gt; str:\n    \"\"\"Obtain the name of the branch that aliases the \"master\" branch.\n\n    Returns:\n        The name/alias assigned to the `master` branch.\n    \"\"\"\n    if self.uses_m_flow():\n        return self.m_flow.master_branch\n    if self.uses_git_flow():\n        return self.git_flow.master_branch\n    return 'master'\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.uses_free_flow","title":"<code>uses_free_flow()</code>","text":"<p>Check if configuration is using the free flow.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if workflow is the free flow.</p> Source code in <code>m/ci/config.py</code> <pre><code>def uses_free_flow(self) -&gt; bool:\n    \"\"\"Check if configuration is using the free flow.\n\n    Returns:\n        True if workflow is the free flow.\n    \"\"\"\n    return self.workflow == Workflow.free_flow\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.uses_git_flow","title":"<code>uses_git_flow()</code>","text":"<p>Check if configuration is using the git flow.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if workflow is the git flow.</p> Source code in <code>m/ci/config.py</code> <pre><code>def uses_git_flow(self) -&gt; bool:\n    \"\"\"Check if configuration is using the git flow.\n\n    Returns:\n        True if workflow is the git flow.\n    \"\"\"\n    return self.workflow == Workflow.git_flow\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.uses_m_flow","title":"<code>uses_m_flow()</code>","text":"<p>Check if configuration is using the m flow.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if workflow is the m flow.</p> Source code in <code>m/ci/config.py</code> <pre><code>def uses_m_flow(self) -&gt; bool:\n    \"\"\"Check if configuration is using the m flow.\n\n    Returns:\n        True if workflow is the m flow.\n    \"\"\"\n    return self.workflow == Workflow.m_flow\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.verify_version","title":"<code>verify_version(gh_latest, is_release_pr, is_release)</code>","text":"<p>Verify that the configuration version is valid.</p> <p>Parameters:</p> Name Type Description Default <code>gh_latest</code> <code>str</code> <p>The version stored in <code>Github</code>. Checks are skipped if this value is empty.</p> required <code>is_release_pr</code> <code>bool</code> <p>Set to <code>True</code> if the build is done during a release pr.</p> required <code>is_release</code> <code>bool</code> <p>Set to <code>True</code> if the build is done during a release.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>A <code>OneOf</code> containing 0 if all is well, otherwise an <code>Issue</code>.</p> Source code in <code>m/ci/config.py</code> <pre><code>def verify_version(\n    self,\n    gh_latest: str,\n    is_release_pr: bool,\n    is_release: bool,\n) -&gt; Res[int]:\n    \"\"\"Verify that the configuration version is valid.\n\n    Args:\n        gh_latest:\n            The version stored in `Github`. Checks are skipped if\n            this value is empty.\n        is_release_pr:\n            Set to `True` if the build is done during a release pr.\n        is_release:\n            Set to `True` if the build is done during a release.\n\n    Returns:\n        A `OneOf` containing 0 if all is well, otherwise an `Issue`.\n    \"\"\"\n    if not gh_latest:\n        return Good(0)\n    err_data = {\n        'config_version': self.version,\n        'gh_latest': gh_latest,\n        'is_release': is_release,\n        'is_release_pr': is_release_pr,\n    }\n    try:\n        p_ver = Version(self.version)\n    except Exception as ex:\n        return issue('error parsing version', cause=ex, context=err_data)\n    try:\n        p_latest = Version(gh_latest)\n    except Exception as ex:  # noqa: WPS440\n        return issue('error parsing latest', cause=ex, context=err_data)\n    ver_gt_latest = p_ver &gt; p_latest\n    ver_lt_latest = p_ver &lt; p_latest\n    msg: str = ''\n    if is_release_pr:\n        msg = _handle_release_pr(ver_gt_latest)\n    elif is_release:\n        msg = _handle_release(ver_gt_latest)\n    else:\n        msg = _handle_non_release(ver_lt_latest, ver_gt_latest)\n    return issue(msg, context=err_data) if msg else Good(0)\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.get_m_filename","title":"<code>get_m_filename(m_dir)</code>","text":"<p>Obtain the path to the m configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory with the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>The name of the configuration file or an issue if it doesn't exist.</p> Source code in <code>m/ci/config.py</code> <pre><code>def get_m_filename(m_dir: str) -&gt; Res[str]:\n    \"\"\"Obtain the path to the m configuration file.\n\n    Args:\n        m_dir: The directory with the m configuration.\n\n    Returns:\n        The name of the configuration file or an issue if it doesn't exist.\n    \"\"\"\n    filenames = (f'{m_dir}/m.yaml', f'{m_dir}/m.yml', f'{m_dir}/m.json')\n    for filename in filenames:\n        if Path(filename).exists():\n            return Good(filename)\n    return issue('m_file not found', context={\n        'm_dir': m_dir,\n        'valid_m_files': filenames,\n    })\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.read_config","title":"<code>read_config(m_dir)</code>","text":"<p>Read an m configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>Directory containing <code>m.json</code>.</p> required <p>Returns:</p> Type Description <code>Res[Config]</code> <p>A <code>OneOf</code> containing the <code>m</code> configuration or an <code>Issue</code>.</p> Source code in <code>m/ci/config.py</code> <pre><code>def read_config(m_dir: str) -&gt; Res[Config]:\n    \"\"\"Read an m configuration file.\n\n    Args:\n        m_dir: Directory containing `m.json`.\n\n    Returns:\n        A `OneOf` containing the `m` configuration or an `Issue`.\n    \"\"\"\n    return one_of(lambda: [\n        Config(m_dir=m_dir, **m_cfg)\n        for m_filename in get_m_filename(m_dir)\n        for m_cfg in yaml_fp.read_yson(m_filename)\n    ]).flat_map_bad(hone('read_config failure'))\n</code></pre>"},{"location":"api/m/ci/end_release/","title":"end_release","text":""},{"location":"api/m/ci/end_release/#m.ci.end_release.end_release","title":"<code>end_release(gh_token)</code>","text":"<p>End the release process.</p> <p>Parameters:</p> Name Type Description Default <code>gh_token</code> <code>str</code> <p>The GITHUB_TOKEN to use to make api calls to Github.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, otherwise an issue.</p> Source code in <code>m/ci/end_release.py</code> <pre><code>def end_release(gh_token: str) -&gt; Res[None]:\n    \"\"\"End the release process.\n\n    Args:\n        gh_token: The GITHUB_TOKEN to use to make api calls to Github.\n\n    Returns:\n        None if successful, otherwise an issue.\n    \"\"\"\n    return one_of(lambda: [\n        None\n        for branch in git.get_branch()\n        for _, target_ver in assert_branch(branch, 'end')\n        for config in read_config('m')\n        for prs in fetch_branch_prs(\n            gh_token,\n            config.owner,\n            config.repo,\n            branch,\n        )\n        for _ in inspect_prs(prs)\n        for _ in merge_prs(gh_token, config, prs, target_ver)\n        for default_branch in Good[Issue, str](config.get_default_branch())\n        for checkout in git.checkout_branch(default_branch, create=False)\n        for _ in _switch_branch(default_branch, checkout)\n        for pull_output in git.pull()\n        for _ in _pull_branch(pull_output)\n    ])\n</code></pre>"},{"location":"api/m/ci/end_release/#m.ci.end_release.inspect_prs","title":"<code>inspect_prs(prs)</code>","text":"<p>Inspect the release pull requests.</p> <p>Attempts to warn the users of possible issues that may be encountered.</p> <p>Parameters:</p> Name Type Description Default <code>prs</code> <code>list[PullRequest]</code> <p>The list of pull requests to merge.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue if the user decides to cancel, None otherwise.</p> Source code in <code>m/ci/end_release.py</code> <pre><code>def inspect_prs(prs: list[PullRequest]) -&gt; Res[None]:\n    \"\"\"Inspect the release pull requests.\n\n    Attempts to warn the users of possible issues that may be encountered.\n\n    Args:\n        prs: The list of pull requests to merge.\n\n    Returns:\n        An issue if the user decides to cancel, None otherwise.\n    \"\"\"\n    if not prs:\n        return issue('no prs associated with the release/hotfix branch')\n    conflicting = [\n        pr\n        for pr in prs\n        if pr.mergeable == MergeableState.conflicting\n    ]\n    if conflicting:\n        return issue('found conflicting prs', context={\n            'prs': {pr.number: pr.url for pr in conflicting},\n            'suggestion': 'check out the pull requests',\n        })\n    # Nice to have: handle code reviews - warn if there are requested changes\n    # To introduce this we need to prompt the user if we should proceed to\n    # merge the pr even when there are pending reviews. This is mainly\n    # done for admins that may be able to merge without approvals.\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/end_release/#m.ci.end_release.merge_prs","title":"<code>merge_prs(gh_token, config, prs, target_ver)</code>","text":"<p>Merge the given prs.</p> <p>Parameters:</p> Name Type Description Default <code>gh_token</code> <code>str</code> <p>The GITHUB_TOKEN to use to make api calls to Github.</p> required <code>config</code> <code>Config</code> <p>The m configuration.</p> required <code>prs</code> <code>list[PullRequest]</code> <p>The pull requests to merge.</p> required <code>target_ver</code> <code>str</code> <p>The version to release.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue if there is a problem while merging or None if successful.</p> Source code in <code>m/ci/end_release.py</code> <pre><code>def merge_prs(\n    gh_token: str,\n    config: Config,\n    prs: list[PullRequest],\n    target_ver: str,\n) -&gt; Res[None]:\n    \"\"\"Merge the given prs.\n\n    Args:\n        gh_token: The GITHUB_TOKEN to use to make api calls to Github.\n        config: The m configuration.\n        prs: The pull requests to merge.\n        target_ver: The version to release.\n\n    Returns:\n        An issue if there is a problem while merging or None if successful.\n    \"\"\"\n    master_branch = config.get_master_branch()\n    first_index = 0 if prs[0].base_ref_name == master_branch else 1\n    second_index = 0 if first_index == 1 else 1\n    first_pr = prs[first_index]\n    second_pr = None\n    if len(prs) == 2:\n        second_pr = prs[second_index]\n\n    first_merged_result: Res[None]\n    if first_pr.merged or first_pr.closed:\n        msg = f'{master_branch} branch pr already merged/closed'\n        logger.warning(msg, context={\n            'pr_info': first_pr.model_dump(),\n        })\n        first_merged_result = Good(None)\n    else:\n        msg = f'merged pr{first_pr.number} to {master_branch}'\n        first_merged_result = merge_pr(\n            gh_token,\n            config.owner,\n            config.repo,\n            first_pr.number,\n            None,\n        ).map(lambda res: logger.info(msg, res)).map(lambda _: None)\n\n    return one_of(lambda: [\n        None\n        for _ in first_merged_result\n        for _ in _merge_second_pr(gh_token, config, second_pr, target_ver)\n    ])\n</code></pre>"},{"location":"api/m/ci/end_release/#m.ci.end_release.wait_until","title":"<code>wait_until(predicate)</code>","text":"<p>Sleep until the predicate function returns False.</p> <p>Will print a <code>.</code> (dot) every 10 seconds thus every 6 dots denote a minute.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[], Res[bool]]</code> <p>function returning an Issue or a boolean</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue or None.</p> Source code in <code>m/ci/end_release.py</code> <pre><code>def wait_until(\n    predicate: Callable[[], Res[bool]],\n) -&gt; Res[None]:\n    \"\"\"Sleep until the predicate function returns False.\n\n    Will print a `.` (dot) every 10 seconds thus every 6 dots\n    denote a minute.\n\n    Args:\n        predicate: function returning an Issue or a boolean\n\n    Returns:\n        An issue or None.\n    \"\"\"\n    should_loop = predicate()\n    counter = 0\n    indent = '       '\n    sys.stdout.write(indent)\n    while not should_loop.is_bad and should_loop.value is True:\n        time.sleep(10)\n        counter += 1\n        modifier = ''\n        if counter % 6 == 0:\n            modifier = '    '\n        if counter % _checks_per_line == 0:\n            modifier = f'\\n{indent}'\n        sys.stdout.write(f'.{modifier}')\n        sys.stdout.flush()\n        should_loop = predicate()\n    sys.stdout.write('\\n')\n    return should_loop.map(lambda _: None)\n</code></pre>"},{"location":"api/m/ci/git_env/","title":"git_env","text":""},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv","title":"<code>GitEnv</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Object to store the git configuration.</p> <p>Attributes:</p> Name Type Description <code>sha</code> <code>str</code> <p>...</p> <code>branch</code> <code>str</code> <p>...</p> <code>target_branch</code> <code>str</code> <p>...</p> <code>commit</code> <code>Commit | None</code> <p>...</p> <code>pull_request</code> <code>PullRequest | None</code> <p>...</p> <code>release</code> <code>Release | None</code> <p>...</p> Source code in <code>m/ci/git_env.py</code> <pre><code>class GitEnv(BaseModel):\n    \"\"\"Object to store the git configuration.\"\"\"\n\n    sha: str\n    branch: str\n    target_branch: str\n    commit: Commit | None = None\n    pull_request: PullRequest | None = None\n    release: Release | None = None\n\n    def get_pr_branch(self) -&gt; str:\n        \"\"\"Get the pull request branch or empty string.\n\n        Returns:\n            The name of the pull request branch or an empty string when not\n            dealing with a pull request.\n        \"\"\"\n        return self.pull_request.pr_branch if self.pull_request else ''\n\n    def get_pr_number(self) -&gt; int:\n        \"\"\"Get the pull request number or 0 if not a pull request.\n\n        Returns:\n            The pull request number or 0 if not a pull request.\n        \"\"\"\n        return self.pull_request.pr_number if self.pull_request else 0\n\n    def is_release(self, config: Config) -&gt; bool:\n        \"\"\"Determine if the current commit should create a release.\n\n        Args:\n            config: The `m` configuration.\n\n        Returns:\n            True if we are dealing with a release.\n        \"\"\"\n        if not self.commit:\n            return False\n        release_prefix = get_release_prefix(config)\n        hotfix_prefix = get_hotfix_prefix(config)\n        if config.uses_m_flow() and self.branch != config.m_flow.master_branch:\n            return False\n        if config.uses_git_flow():\n            if self.branch != config.git_flow.master_branch:\n                return False\n        return (\n            self.commit.is_release(release_prefix)\n            or self.commit.is_release(hotfix_prefix)\n        )\n\n    def is_release_pr(self, config: Config) -&gt; bool:\n        \"\"\"Determine if the the current pr is a release pr.\n\n        Args:\n            config: The `m` configuration.\n\n        Returns:\n            True if we are dealing with a release pr.\n        \"\"\"\n        if not self.pull_request:\n            return False\n        release_prefix = get_release_prefix(config)\n        return self.pull_request.is_release_pr(release_prefix)\n\n    def is_hotfix_pr(self, config: Config) -&gt; bool:\n        \"\"\"Determine if the the current pr is a hotfix pr.\n\n        It is a release pr as far as the pull request should see it but\n        from the context of the git environment we need to label it as a\n        hotfix pr.\n\n        Args:\n            config: The m configuration object.\n\n        Returns:\n            True if the we are dealing with hotfix pr.\n        \"\"\"\n        if not self.pull_request:\n            return False\n        hotfix_prefix = get_hotfix_prefix(config)\n        return self.pull_request.is_release_pr(hotfix_prefix)\n\n    def get_build_tag(self, config: Config, run_id: str) -&gt; Res[str]:\n        \"\"\"Create a build tag for the current commit.\n\n        It is tempting to use the config_version when creating a build tag for\n        pull requests or branches. This will only be annoying when testing.\n\n        Consider the following scenario. An application is being tested with\n        `1.0.1-pr99.b123`. When using docker you may want to refer to the\n        latest pr build by using `1.0.1-pr99`. Now lets say that a release\n        happened and now the config_version is at `1.1.0`. The application\n        build will not get the latest changes because the new changes are in\n        `1.1.0-pr99`.\n\n        There are two solutions, either always state the version that is\n        being used or make a tag to depend only on the pull request number.\n        This is the reason why for prs (constantly changing) we avoid\n        using the version in the configuration.\n\n        For release prs we use `rc` followed by the pull request. In this case\n        it is safe to use config_version given that there should only be\n        one release at a time. We treat hotfixes similar to releases.\n\n        Git flow will generate a special build tag: SKIP. This will happen when\n        we try to merge a release or hotfix branch to the develop branch.\n\n        Args:\n            config: The `m` configuration.\n            run_id: A unique identifier for the run/job.\n\n        Returns:\n            A unique identifier for the build. This tag is compatible with\n            both `npm` and `docker`.\n        \"\"\"\n        ver_input = _version_inputs(self, config, run_id)\n        if ver_input:\n            return Good(build_m_tag(ver_input, config))\n        return Good('SKIP')\n\n    def get_py_tag(self, config: Config, run_id: str) -&gt; Res[str]:\n        \"\"\"Create a python tag for the current commit.\n\n        Args:\n            config: The `m` configuration.\n            run_id: A unique identifier for the run/job.\n\n        Returns:\n            A unique identifier for the build. This tag is compatible with\n            python.\n        \"\"\"\n        ver_input = _version_inputs(self, config, run_id)\n        if ver_input:\n            return Good(build_py_tag(ver_input, config))\n        return Good('SKIP')\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.get_build_tag","title":"<code>get_build_tag(config, run_id)</code>","text":"<p>Create a build tag for the current commit.</p> <p>It is tempting to use the config_version when creating a build tag for pull requests or branches. This will only be annoying when testing.</p> <p>Consider the following scenario. An application is being tested with <code>1.0.1-pr99.b123</code>. When using docker you may want to refer to the latest pr build by using <code>1.0.1-pr99</code>. Now lets say that a release happened and now the config_version is at <code>1.1.0</code>. The application build will not get the latest changes because the new changes are in <code>1.1.0-pr99</code>.</p> <p>There are two solutions, either always state the version that is being used or make a tag to depend only on the pull request number. This is the reason why for prs (constantly changing) we avoid using the version in the configuration.</p> <p>For release prs we use <code>rc</code> followed by the pull request. In this case it is safe to use config_version given that there should only be one release at a time. We treat hotfixes similar to releases.</p> <p>Git flow will generate a special build tag: SKIP. This will happen when we try to merge a release or hotfix branch to the develop branch.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The <code>m</code> configuration.</p> required <code>run_id</code> <code>str</code> <p>A unique identifier for the run/job.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A unique identifier for the build. This tag is compatible with</p> <code>Res[str]</code> <p>both <code>npm</code> and <code>docker</code>.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_build_tag(self, config: Config, run_id: str) -&gt; Res[str]:\n    \"\"\"Create a build tag for the current commit.\n\n    It is tempting to use the config_version when creating a build tag for\n    pull requests or branches. This will only be annoying when testing.\n\n    Consider the following scenario. An application is being tested with\n    `1.0.1-pr99.b123`. When using docker you may want to refer to the\n    latest pr build by using `1.0.1-pr99`. Now lets say that a release\n    happened and now the config_version is at `1.1.0`. The application\n    build will not get the latest changes because the new changes are in\n    `1.1.0-pr99`.\n\n    There are two solutions, either always state the version that is\n    being used or make a tag to depend only on the pull request number.\n    This is the reason why for prs (constantly changing) we avoid\n    using the version in the configuration.\n\n    For release prs we use `rc` followed by the pull request. In this case\n    it is safe to use config_version given that there should only be\n    one release at a time. We treat hotfixes similar to releases.\n\n    Git flow will generate a special build tag: SKIP. This will happen when\n    we try to merge a release or hotfix branch to the develop branch.\n\n    Args:\n        config: The `m` configuration.\n        run_id: A unique identifier for the run/job.\n\n    Returns:\n        A unique identifier for the build. This tag is compatible with\n        both `npm` and `docker`.\n    \"\"\"\n    ver_input = _version_inputs(self, config, run_id)\n    if ver_input:\n        return Good(build_m_tag(ver_input, config))\n    return Good('SKIP')\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.get_pr_branch","title":"<code>get_pr_branch()</code>","text":"<p>Get the pull request branch or empty string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the pull request branch or an empty string when not</p> <code>str</code> <p>dealing with a pull request.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_pr_branch(self) -&gt; str:\n    \"\"\"Get the pull request branch or empty string.\n\n    Returns:\n        The name of the pull request branch or an empty string when not\n        dealing with a pull request.\n    \"\"\"\n    return self.pull_request.pr_branch if self.pull_request else ''\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.get_pr_number","title":"<code>get_pr_number()</code>","text":"<p>Get the pull request number or 0 if not a pull request.</p> <p>Returns:</p> Type Description <code>int</code> <p>The pull request number or 0 if not a pull request.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_pr_number(self) -&gt; int:\n    \"\"\"Get the pull request number or 0 if not a pull request.\n\n    Returns:\n        The pull request number or 0 if not a pull request.\n    \"\"\"\n    return self.pull_request.pr_number if self.pull_request else 0\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.get_py_tag","title":"<code>get_py_tag(config, run_id)</code>","text":"<p>Create a python tag for the current commit.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The <code>m</code> configuration.</p> required <code>run_id</code> <code>str</code> <p>A unique identifier for the run/job.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A unique identifier for the build. This tag is compatible with</p> <code>Res[str]</code> <p>python.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_py_tag(self, config: Config, run_id: str) -&gt; Res[str]:\n    \"\"\"Create a python tag for the current commit.\n\n    Args:\n        config: The `m` configuration.\n        run_id: A unique identifier for the run/job.\n\n    Returns:\n        A unique identifier for the build. This tag is compatible with\n        python.\n    \"\"\"\n    ver_input = _version_inputs(self, config, run_id)\n    if ver_input:\n        return Good(build_py_tag(ver_input, config))\n    return Good('SKIP')\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.is_hotfix_pr","title":"<code>is_hotfix_pr(config)</code>","text":"<p>Determine if the the current pr is a hotfix pr.</p> <p>It is a release pr as far as the pull request should see it but from the context of the git environment we need to label it as a hotfix pr.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The m configuration object.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the we are dealing with hotfix pr.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def is_hotfix_pr(self, config: Config) -&gt; bool:\n    \"\"\"Determine if the the current pr is a hotfix pr.\n\n    It is a release pr as far as the pull request should see it but\n    from the context of the git environment we need to label it as a\n    hotfix pr.\n\n    Args:\n        config: The m configuration object.\n\n    Returns:\n        True if the we are dealing with hotfix pr.\n    \"\"\"\n    if not self.pull_request:\n        return False\n    hotfix_prefix = get_hotfix_prefix(config)\n    return self.pull_request.is_release_pr(hotfix_prefix)\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.is_release","title":"<code>is_release(config)</code>","text":"<p>Determine if the current commit should create a release.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The <code>m</code> configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if we are dealing with a release.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def is_release(self, config: Config) -&gt; bool:\n    \"\"\"Determine if the current commit should create a release.\n\n    Args:\n        config: The `m` configuration.\n\n    Returns:\n        True if we are dealing with a release.\n    \"\"\"\n    if not self.commit:\n        return False\n    release_prefix = get_release_prefix(config)\n    hotfix_prefix = get_hotfix_prefix(config)\n    if config.uses_m_flow() and self.branch != config.m_flow.master_branch:\n        return False\n    if config.uses_git_flow():\n        if self.branch != config.git_flow.master_branch:\n            return False\n    return (\n        self.commit.is_release(release_prefix)\n        or self.commit.is_release(hotfix_prefix)\n    )\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.is_release_pr","title":"<code>is_release_pr(config)</code>","text":"<p>Determine if the the current pr is a release pr.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The <code>m</code> configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if we are dealing with a release pr.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def is_release_pr(self, config: Config) -&gt; bool:\n    \"\"\"Determine if the the current pr is a release pr.\n\n    Args:\n        config: The `m` configuration.\n\n    Returns:\n        True if we are dealing with a release pr.\n    \"\"\"\n    if not self.pull_request:\n        return False\n    release_prefix = get_release_prefix(config)\n    return self.pull_request.is_release_pr(release_prefix)\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.get_git_env","title":"<code>get_git_env(config, env_vars)</code>","text":"<p>Obtain the git environment by asking Github's API.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The m configuration object.</p> required <code>env_vars</code> <code>EnvVars</code> <p>The environment variables.</p> required <p>Returns:</p> Type Description <code>Res[GitEnv]</code> <p>The git environment object or an issue.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_git_env(config: Config, env_vars: EnvVars) -&gt; Res[GitEnv]:\n    \"\"\"Obtain the git environment by asking Github's API.\n\n    Args:\n        config: The m configuration object.\n        env_vars: The environment variables.\n\n    Returns:\n        The git environment object or an issue.\n    \"\"\"\n    branch = _remove_strings(env_vars.git_branch, ['refs/heads/', 'heads/'])\n    sha = env_vars.git_sha\n    git_env = GitEnv(sha=sha, branch=branch, target_branch=branch)\n\n    # quick exit for local environment\n    if not env_vars.ci_env:\n        return Good(git_env)\n\n    pr_number = get_pr_number(branch)\n    git_env_box = get_ci_run_info(\n        token=env_vars.github_token,\n        commit_info=CommitInfo(\n            owner=config.owner,\n            repo=config.repo,\n            sha=env_vars.git_sha,\n        ),\n        pr_number=pr_number,\n        file_count=100,\n        include_release=True,\n    )\n    if isinstance(git_env_box, Bad):\n        return issue('git_env failure', cause=git_env_box.value)\n\n    res = git_env_box.value\n    pr = res.pull_request\n\n    if pr and config.require_pr_changelog and not pr.changelog_updated():\n        can_bypass: bool = bool(config.changelog_bypassers) and pr.author.login in config.changelog_bypassers\n\n        # If this is a huge PR we'll bypass it, the file may not be present in\n        # the list of files.\n        if not can_bypass and pr.file_count &lt; 100:\n            return issue('missing CHANGELOG.md in PR', context={'pr': pr.model_dump()})\n\n    git_env.sha = res.commit.sha\n    git_env.target_branch = pr.target_branch if pr else branch\n    git_env.commit = res.commit\n    git_env.pull_request = res.pull_request\n    git_env.release = res.release\n    return Good(git_env)\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.get_hotfix_prefix","title":"<code>get_hotfix_prefix(config)</code>","text":"<p>Find out the hotfix prefix.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The m configuration. Its workflow is used to determine the prefix.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The hofix prefix or None if not using a supported workflow.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_hotfix_prefix(config: Config) -&gt; str | None:\n    \"\"\"Find out the hotfix prefix.\n\n    Args:\n        config:\n            The m configuration. Its workflow is used to determine the prefix.\n\n    Returns:\n        The hofix prefix or None if not using a supported workflow.\n    \"\"\"\n    if config.uses_git_flow():\n        return config.git_flow.hotfix_prefix\n    if config.uses_m_flow():\n        return config.m_flow.hotfix_prefix\n    return None\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.get_pr_number","title":"<code>get_pr_number(branch)</code>","text":"<p>Retrieve the pull request number from the branch name.</p> <p>Parameters:</p> Name Type Description Default <code>branch</code> <code>str</code> <p>The branch name from where the pr number is extracted.py</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>The pr number if the branch is a pull request otherwise <code>None</code>.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_pr_number(branch: str) -&gt; int | None:\n    \"\"\"Retrieve the pull request number from the branch name.\n\n    Args:\n        branch: The branch name from where the pr number is extracted.py\n\n    Returns:\n        The pr number if the branch is a pull request otherwise `None`.\n    \"\"\"\n    if 'pull/' in branch:\n        parts = branch.split('/')\n        return int(parts[parts.index('pull') + 1])\n    return None\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.get_release_prefix","title":"<code>get_release_prefix(config)</code>","text":"<p>Find out the release prefix.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The m configuration. Its workflow is used to determine the prefix.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The release prefix or None if not using a supported workflow.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_release_prefix(config: Config) -&gt; str | None:\n    \"\"\"Find out the release prefix.\n\n    Args:\n        config:\n            The m configuration. Its workflow is used to determine the prefix.\n\n    Returns:\n        The release prefix or None if not using a supported workflow.\n    \"\"\"\n    if config.uses_git_flow():\n        return config.git_flow.release_prefix\n    if config.uses_m_flow():\n        return config.m_flow.release_prefix\n    return None\n</code></pre>"},{"location":"api/m/ci/init/","title":"init","text":""},{"location":"api/m/ci/init/#m.ci.init.create_changelog","title":"<code>create_changelog()</code>","text":"<p>Create the changelog file.</p> <p>Returns:</p> Type Description <code>Res[str | None]</code> <p>A <code>OneOf</code> containing 0 if successful or an <code>Issue</code>.</p> Source code in <code>m/ci/init.py</code> <pre><code>def create_changelog() -&gt; Res[str | None]:\n    \"\"\"Create the changelog file.\n\n    Returns:\n        A `OneOf` containing 0 if successful or an `Issue`.\n    \"\"\"\n    body = \"\"\"\\\n        # Changelog\n\n        The format of this changelog is based on\n        [Keep a Changelog](http://keepachangelog.com/en/1.0.0/). The project adheres to\n        [Semantic Versioning](http://semver.org/spec/v2.0.0.html)\n\n        &gt; Major version zero (0.y.z) is for initial development. Anything may change at\n        &gt; any time. The public API should not be considered stable.\n\n        ## [Unreleased]\n    \"\"\"\n    file_name = 'CHANGELOG.md'\n    if Path.exists(Path(file_name)):\n        logger.warning(f'{file_name} already exists')\n        return Good(None)\n    return one_of(lambda: [\n        file_name\n        for _ in mio.write_file('CHANGELOG.md', dedent(body))\n        for _ in logger.info(f'created {file_name}')\n    ])\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.create_m_config","title":"<code>create_m_config()</code>","text":"<p>Create the m configuration file.</p> <p>Returns:</p> Type Description <code>Res[str | None]</code> <p>The name of the m file or none if successful. Otherwise an <code>Issue</code>.</p> Source code in <code>m/ci/init.py</code> <pre><code>def create_m_config() -&gt; Res[str | None]:\n    \"\"\"Create the m configuration file.\n\n    Returns:\n        The name of the m file or none if successful. Otherwise an `Issue`.\n    \"\"\"\n    file_name = 'm/m.yaml'\n    if Path.exists(Path(file_name)):\n        logger.warning(f'{file_name} already exists')\n        return Good(None)\n    m_dir = Path('m')\n    if not Path.exists(m_dir):\n        Path.mkdir(m_dir, parents=True)\n    return one_of(lambda: [\n        file_name\n        for owner, repo in get_repo_info()\n        for _ in mio.write_file(file_name, m_config_body(owner, repo))\n        for _ in logger.info(f'created {file_name}', {\n            'owner': owner,\n            'repo': repo,\n        })\n    ])\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.get_repo_info","title":"<code>get_repo_info()</code>","text":"<p>Get the owner and repo name from the current repository.</p> <p>Returns:</p> Type Description <code>Res[Tuple[str, str]]</code> <p>A tuple with the owner and repo (or an Issue).</p> Source code in <code>m/ci/init.py</code> <pre><code>def get_repo_info() -&gt; Res[Tuple[str, str]]:\n    \"\"\"Get the owner and repo name from the current repository.\n\n    Returns:\n        A tuple with the owner and repo (or an Issue).\n    \"\"\"\n    return one_of(lambda: [\n        owner_repo\n        for ssh_url in get_remote_url()\n        for owner_repo in parse_ssh_url(ssh_url)\n    ])\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.init_repo","title":"<code>init_repo()</code>","text":"<p>Initialize a repository with the basic project configurations.</p> <p>Returns:</p> Type Description <code>Res[None]</code> <p>A <code>OneOf</code> containing 0 if successful or an <code>Issue</code>.</p> Source code in <code>m/ci/init.py</code> <pre><code>def init_repo() -&gt; Res[None]:\n    \"\"\"Initialize a repository with the basic project configurations.\n\n    Returns:\n        A `OneOf` containing 0 if successful or an `Issue`.\n    \"\"\"\n    return one_of(lambda: [\n        None\n        for m_file in create_m_config()\n        for gitignore in update_gitignore()\n        for changelog in create_changelog()\n        for _ in logger.info('setup complete', {\n            'modified_files': [x for x in (m_file, gitignore, changelog) if x],\n        })\n    ])\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.m_config_body","title":"<code>m_config_body(owner, repo)</code>","text":"<p>Create the basic contents of a m configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The repo owner.</p> required <code>repo</code> <code>str</code> <p>The repo name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A yaml string to be the content of the <code>m.yaml</code> file.</p> Source code in <code>m/ci/init.py</code> <pre><code>def m_config_body(owner: str, repo: str) -&gt; str:\n    \"\"\"Create the basic contents of a m configuration file.\n\n    Args:\n        owner: The repo owner.\n        repo: The repo name.\n\n    Returns:\n        A yaml string to be the content of the `m.yaml` file.\n    \"\"\"\n    body = f\"\"\"\\\n        owner: {owner}\n        repo: {repo}\n        version: 0.0.0\n        workflow: m_flow\n    \"\"\"\n    return dedent(body)\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.parse_ssh_url","title":"<code>parse_ssh_url(ssh_url)</code>","text":"<p>Find the owner and repo from an ssh url.</p> <p>Parameters:</p> Name Type Description Default <code>ssh_url</code> <code>str</code> <p>The url of the repo</p> required <p>Returns:</p> Type Description <code>Res[Tuple[str, str]]</code> <p>A tuple with the owner and repo (or an Issue).</p> Source code in <code>m/ci/init.py</code> <pre><code>def parse_ssh_url(ssh_url: str) -&gt; Res[Tuple[str, str]]:\n    \"\"\"Find the owner and repo from an ssh url.\n\n    Args:\n        ssh_url: The url of the repo\n\n    Returns:\n        A tuple with the owner and repo (or an Issue).\n    \"\"\"\n    match = re.findall('.*:(.*)/(.*).git', ssh_url)\n    if match and match[0] and match[0][0] and match[0][1]:\n        return Good(match[0])\n    return issue(\n        'unable to obtain owner and repo',\n        context={'ssh_url': ssh_url},\n    )\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.update_gitignore","title":"<code>update_gitignore()</code>","text":"<p>Update the gitignore file.</p> <p>Adds the m/.m directory to the list.</p> <p>Returns:</p> Type Description <code>Res[str | None]</code> <p>A <code>OneOf</code> containing file name or an Issue if it was unable to update</p> <code>Res[str | None]</code> <p>the file.</p> Source code in <code>m/ci/init.py</code> <pre><code>def update_gitignore() -&gt; Res[str | None]:\n    \"\"\"Update the gitignore file.\n\n    Adds the m/.m directory to the list.\n\n    Returns:\n        A `OneOf` containing file name or an Issue if it was unable to update\n        the file.\n    \"\"\"\n    file_name = '.gitignore'\n    return one_of(lambda: [\n        fname\n        for _ in subprocess.eval_cmd(f'touch {file_name}')\n        for body in mio.read_file(file_name)\n        for fname in _update_gitignore(file_name, body)\n    ])\n</code></pre>"},{"location":"api/m/ci/m_blueprints/","title":"m_blueprints","text":""},{"location":"api/m/ci/m_blueprints/#m.ci.m_blueprints.write_blueprints","title":"<code>write_blueprints(m_dir, *, m_tag, cache_from_pr, update_makefile=False, update_workflow=False)</code>","text":"<p>Write a file with the M environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory with the m configuration.</p> required <code>m_tag</code> <code>str</code> <p>The unique identifier for the build.</p> required <code>cache_from_pr</code> <code>str</code> <p>The pr number to attempt to pull cache from.</p> required <code>update_makefile</code> <code>bool</code> <p>If true, updates the <code>Makefile</code>.</p> <code>False</code> <code>update_workflow</code> <code>bool</code> <p>If true, updates the github workflow.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue or the m environment instance.</p> Source code in <code>m/ci/m_blueprints.py</code> <pre><code>def write_blueprints(\n    m_dir: str,\n    *,\n    m_tag: str,\n    cache_from_pr: str,\n    update_makefile: bool = False,\n    update_workflow: bool = False,\n) -&gt; Res[None]:\n    \"\"\"Write a file with the M environment variables.\n\n    Args:\n        m_dir: The directory with the m configuration.\n        m_tag: The unique identifier for the build.\n        cache_from_pr: The pr number to attempt to pull cache from.\n        update_makefile: If true, updates the `Makefile`.\n        update_workflow: If true, updates the github workflow.\n\n    Returns:\n        An issue or the m environment instance.\n    \"\"\"\n    blueprints_dir = Path(f'{m_dir}/.m/blueprints')\n    if not blueprints_dir.exists():\n        Path(f'{m_dir}/.m/blueprints/local').mkdir(parents=True)\n        Path(f'{m_dir}/.m/blueprints/ci').mkdir(parents=True)\n    return one_of(lambda: [\n        None\n        for config in read_config(m_dir)\n        for _ in _write_blueprints(\n            config,\n            m_tag=m_tag,\n            cache_from_pr=cache_from_pr,\n            update_makefile=update_makefile,\n            update_workflow=update_workflow,\n        )\n    ])\n</code></pre>"},{"location":"api/m/ci/m_env/","title":"m_env","text":""},{"location":"api/m/ci/m_env/#m.ci.m_env.MEnv","title":"<code>MEnv</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Contains all the information required for a CI run.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>Config</code> <p>...</p> <code>env_vars</code> <code>EnvVars</code> <p>...</p> <code>git_env</code> <code>GitEnv</code> <p>...</p> <code>release_env</code> <code>ReleaseEnv</code> <p>...</p> Source code in <code>m/ci/m_env.py</code> <pre><code>class MEnv(BaseModel):\n    \"\"\"Contains all the information required for a CI run.\"\"\"\n\n    config: Config\n    env_vars: EnvVars\n    git_env: GitEnv\n    release_env: ReleaseEnv\n</code></pre>"},{"location":"api/m/ci/m_env/#m.ci.m_env.bashrc_snippet","title":"<code>bashrc_snippet(m_dir)</code>","text":"<p>Create a bash snippet that exports the M environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory with the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>An issue or a bash snippet.</p> Source code in <code>m/ci/m_env.py</code> <pre><code>def bashrc_snippet(m_dir: str) -&gt; Res[str]:\n    \"\"\"Create a bash snippet that exports the M environment variables.\n\n    Args:\n        m_dir: The directory with the m configuration.\n\n    Returns:\n        An issue or a bash snippet.\n    \"\"\"\n    return one_of(lambda: [\n        '\\n'.join([\n            f'export {assignment}'\n            for line in env_list\n            for assignment in fp.Good(_lower_bool(line))\n        ])\n        for m_env in get_m_env(m_dir)\n        for env_list in _m_env_vars(m_env)\n    ])\n</code></pre>"},{"location":"api/m/ci/m_env/#m.ci.m_env.get_m_env","title":"<code>get_m_env(m_dir)</code>","text":"<p>Obtain the M Environment object.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory containing the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[MEnv]</code> <p>The M Environment if it exists otherwise an issue.</p> Source code in <code>m/ci/m_env.py</code> <pre><code>def get_m_env(m_dir: str) -&gt; Res[MEnv]:\n    \"\"\"Obtain the M Environment object.\n\n    Args:\n        m_dir: The directory containing the m configuration.\n\n    Returns:\n        The M Environment if it exists otherwise an issue.\n    \"\"\"\n    ci_tool = get_ci_tool()\n    return one_of(lambda: [\n        MEnv(\n            config=config,\n            env_vars=env_vars,\n            git_env=git_env,\n            release_env=release_env,\n        )\n        for config in read_config(m_dir)\n        for env_vars in ci_tool.env_vars()\n        for git_env in get_git_env(config, env_vars)\n        for release_env in get_release_env(config, env_vars, git_env)\n    ]).flat_map_bad(hone('get_m_env failure'))\n</code></pre>"},{"location":"api/m/ci/m_env/#m.ci.m_env.write_m_env_vars","title":"<code>write_m_env_vars(m_dir)</code>","text":"<p>Write a file with the M environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory with the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[Any]</code> <p>An issue or the m environment instance.</p> Source code in <code>m/ci/m_env.py</code> <pre><code>def write_m_env_vars(m_dir: str) -&gt; Res[Any]:\n    \"\"\"Write a file with the M environment variables.\n\n    Args:\n        m_dir: The directory with the m configuration.\n\n    Returns:\n        An issue or the m environment instance.\n    \"\"\"\n    target_dir = Path(f'{m_dir}/.m')\n\n    if not Path.exists(target_dir):\n        Path.mkdir(target_dir, parents=True)\n    return one_of(lambda: [\n        json.loads(m_env.model_dump_json())\n        for m_env in get_m_env(m_dir)\n        for env_list in _m_env_vars(m_env)\n        for _ in mio.write_file(f'{m_dir}/.m/env.list', '\\n'.join(env_list))\n    ])\n</code></pre>"},{"location":"api/m/ci/release_env/","title":"release_env","text":""},{"location":"api/m/ci/release_env/#m.ci.release_env.ReleaseEnv","title":"<code>ReleaseEnv</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Object to store the release configuration.</p> <p>Attributes:</p> Name Type Description <code>build_tag</code> <code>str</code> <p>...</p> <code>python_tag</code> <code>str</code> <p>...</p> <code>is_release</code> <code>bool</code> <p>...</p> <code>is_release_pr</code> <code>bool</code> <p>...</p> <code>is_hotfix_pr</code> <code>bool</code> <p>...</p> <code>workflow</code> <code>Workflow</code> <p>...</p> Source code in <code>m/ci/release_env.py</code> <pre><code>class ReleaseEnv(BaseModel):\n    \"\"\"Object to store the release configuration.\"\"\"\n\n    build_tag: str\n    python_tag: str\n    is_release: bool\n    is_release_pr: bool\n    is_hotfix_pr: bool\n    workflow: Workflow\n</code></pre>"},{"location":"api/m/ci/release_env/#m.ci.release_env.get_release_env","title":"<code>get_release_env(config, env_vars, git_env)</code>","text":"<p>Provide the release environment information.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The m configuration.</p> required <code>env_vars</code> <code>EnvVars</code> <p>The environment variables.</p> required <code>git_env</code> <code>GitEnv</code> <p>The git environment.</p> required <p>Returns:</p> Type Description <code>Res[ReleaseEnv]</code> <p>A <code>ReleaseEnv</code> instance.</p> Source code in <code>m/ci/release_env.py</code> <pre><code>def get_release_env(\n    config: Config,\n    env_vars: EnvVars,\n    git_env: GitEnv,\n) -&gt; Res[ReleaseEnv]:\n    \"\"\"Provide the release environment information.\n\n    Args:\n        config: The m configuration.\n        env_vars: The environment variables.\n        git_env: The git environment.\n\n    Returns:\n        A `ReleaseEnv` instance.\n    \"\"\"\n    is_release = git_env.is_release(config)\n    is_release_pr = git_env.is_release_pr(config)\n    is_hotfix_pr = git_env.is_hotfix_pr(config)\n    gh_latest = git_env.release.tag_name if git_env.release else ''\n    if not config.uses_free_flow():\n        check_result = _extra_checks(\n            config,\n            git_env,\n            is_release_pr=is_release_pr,\n            is_hotfix_pr=is_hotfix_pr,\n        )\n        if isinstance(check_result, Bad):\n            return check_result\n    return one_of(lambda: [\n        ReleaseEnv(\n            build_tag=build_tag,\n            python_tag=python_tag,\n            is_release=is_release,\n            is_release_pr=is_release_pr,\n            is_hotfix_pr=is_hotfix_pr,\n            workflow=config.workflow,\n        )\n        for _ in _verify_version(\n            config,\n            git_env,\n            gh_latest,\n            is_release_pr=is_release_pr or is_hotfix_pr,\n            is_release=is_release,\n        )\n        for build_tag in git_env.get_build_tag(config, env_vars.run_id)\n        for python_tag in git_env.get_py_tag(config, env_vars.run_id)\n    ])\n</code></pre>"},{"location":"api/m/ci/release_setup/","title":"release_setup","text":""},{"location":"api/m/ci/release_setup/#m.ci.release_setup.new_changelog","title":"<code>new_changelog(changelog_contents, owner, repo, new_ver, first_sha)</code>","text":"<p>Modify the contents of a CHANGELOG.</p> <p>It adds a new entry with the new version the new changelog contents.</p> <p>Parameters:</p> Name Type Description Default <code>changelog_contents</code> <code>str</code> <p>The current contents of the CHANGELOG file.</p> required <code>owner</code> <code>str</code> <p>The repo owner.</p> required <code>repo</code> <code>str</code> <p>The repo name.</p> required <code>new_ver</code> <code>str</code> <p>The new version.</p> required <code>first_sha</code> <code>str</code> <p>The very first commit sha of the repo.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>The new contents of the CHANGELOG.</p> Source code in <code>m/ci/release_setup.py</code> <pre><code>def new_changelog(\n    changelog_contents: str,\n    owner: str,\n    repo: str,\n    new_ver: str,\n    first_sha: str,\n) -&gt; Res[str]:\n    \"\"\"Modify the contents of a CHANGELOG.\n\n    It adds a new entry with the new version the new changelog contents.\n\n    Args:\n        changelog_contents: The current contents of the CHANGELOG file.\n        owner: The repo owner.\n        repo: The repo name.\n        new_ver: The new version.\n        first_sha: The very first commit sha of the repo.\n\n    Returns:\n        The new contents of the CHANGELOG.\n    \"\"\"\n    parts = changelog_contents.split('## [Unreleased]')\n    if len(parts) != 2:\n        return issue('missing \"Unreleased\" link')\n\n    header, main = parts\n    entries = main.split('[unreleased]:')[0]\n    versions = _get_versions(entries.split('\\n'), new_ver, first_sha)\n\n    compare_url = compare_sha_url(owner, repo, new_ver, 'HEAD')\n    links = [f'[unreleased]: {compare_url}']\n    for i in range(len(versions) - 1):\n        link = compare_sha_url(owner, repo, versions[i + 1], versions[i])\n        links.append(f'[{versions[i]}]: {link}')\n\n    date = datetime.now().strftime('%B %d, %Y')\n    ver_anchor = _version_anchor(new_ver)\n    return Good(''.join([\n        header,\n        '## [Unreleased]\\n\\n',\n        f'## [{new_ver}] {ver_anchor} {date}\\n\\n',\n        entries,\n        '\\n'.join(links),\n        '\\n',\n    ]))\n</code></pre>"},{"location":"api/m/ci/release_setup/#m.ci.release_setup.release_setup","title":"<code>release_setup(m_dir, config_inst, new_ver, changelog='CHANGELOG.md')</code>","text":"<p>Modify all the necessary files to create a release.</p> <p>These include: CHANGELOG.md and the m configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory with the m configuration.</p> required <code>config_inst</code> <code>Config | None</code> <p>If provided it skips reading the configuration.</p> required <code>new_ver</code> <code>str</code> <p>The new version to write in the m configuration.</p> required <code>changelog</code> <code>str</code> <p>The name of the changelog file (defaults to CHANGELOG.md)</p> <code>'CHANGELOG.md'</code> <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, otherwise an issue.</p> Source code in <code>m/ci/release_setup.py</code> <pre><code>def release_setup(\n    m_dir: str,\n    config_inst: Config | None,\n    new_ver: str,\n    changelog: str = 'CHANGELOG.md',\n) -&gt; Res[None]:\n    \"\"\"Modify all the necessary files to create a release.\n\n    These include: CHANGELOG.md and the m configuration file.\n\n    Args:\n        m_dir: The directory with the m configuration.\n        config_inst: If provided it skips reading the configuration.\n        new_ver: The new version to write in the m configuration.\n        changelog: The name of the changelog file (defaults to CHANGELOG.md)\n\n    Returns:\n        None if successful, otherwise an issue.\n    \"\"\"\n    return one_of(lambda: [\n        None\n        for config in _read_config(m_dir, config_inst)\n        for first_sha in get_first_commit_sha()\n        for _ in update_version(m_dir, new_ver)\n        for _ in update_changelog_file(\n            config.owner,\n            config.repo,\n            new_ver,\n            first_sha,\n            changelog,\n        )\n        for _ in _success_release_setup(config, new_ver)\n    ])\n</code></pre>"},{"location":"api/m/ci/release_setup/#m.ci.release_setup.update_changelog_file","title":"<code>update_changelog_file(owner, repo, new_ver, first_sha, filename='CHANGELOG.md')</code>","text":"<p>Add the new version entry to be released to the CHANGELOG.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The repo owner.</p> required <code>repo</code> <code>str</code> <p>The repo name.</p> required <code>new_ver</code> <code>str</code> <p>The version that is being released.</p> required <code>first_sha</code> <code>str</code> <p>The first sha ever committed on the repo.</p> required <code>filename</code> <code>str</code> <p>Specify the CHANGELOG file (defaults to CHANGELOG.md)</p> <code>'CHANGELOG.md'</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>0 if successful, an issue otherwise.</p> Source code in <code>m/ci/release_setup.py</code> <pre><code>def update_changelog_file(\n    owner: str,\n    repo: str,\n    new_ver: str,\n    first_sha: str,\n    filename: str = 'CHANGELOG.md',\n) -&gt; Res[int]:\n    \"\"\"Add the new version entry to be released to the CHANGELOG.\n\n    Args:\n        owner: The repo owner.\n        repo: The repo name.\n        new_ver: The version that is being released.\n        first_sha: The first sha ever committed on the repo.\n        filename: Specify the CHANGELOG file (defaults to CHANGELOG.md)\n\n    Returns:\n        0 if successful, an issue otherwise.\n    \"\"\"\n    return one_of(lambda: [\n        0\n        for text in rw.read_file(filename)\n        for new_data in new_changelog(text, owner, repo, new_ver, first_sha)\n        for _ in rw.write_file(filename, new_data)\n        for _ in logger.info(f'updated {filename}')\n    ])\n</code></pre>"},{"location":"api/m/ci/release_setup/#m.ci.release_setup.update_version","title":"<code>update_version(root, version)</code>","text":"<p>Update the version property in m configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>The directory with the m configuration file.</p> required <code>version</code> <code>str</code> <p>The new version to write in the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>0 if successful or an issue.</p> Source code in <code>m/ci/release_setup.py</code> <pre><code>def update_version(\n    root: str,\n    version: str,\n) -&gt; Res[int]:\n    \"\"\"Update the version property in m configuration file.\n\n    Args:\n        root: The directory with the m configuration file.\n        version: The new version to write in the m configuration.\n\n    Returns:\n        0 if successful or an issue.\n    \"\"\"\n    return one_of(lambda: [\n        0\n        for filename in get_m_filename(root)\n        for config_contents in rw.read_file(filename)\n        for new_data in _update_config_version(config_contents, version)\n        for _ in rw.write_file(filename, new_data)\n        for _ in logger.info(f'bumped version in {filename}')\n    ])\n</code></pre>"},{"location":"api/m/ci/release_utils/","title":"release_utils","text":""},{"location":"api/m/ci/release_utils/#m.ci.release_utils.assert_branch","title":"<code>assert_branch(branch, step)</code>","text":"<p>Assert that a release step is done in the proper branch.</p> <p>This can only happen in <code>release/x.y.z</code> or <code>hotfix/x.y.z</code>.</p> <p>Parameters:</p> Name Type Description Default <code>branch</code> <code>str</code> <p>branch name to verify.</p> required <code>step</code> <code>str</code> <p>the release step name.</p> required <p>Returns:</p> Type Description <code>Res[tuple[str, str]]</code> <p>An Issue if the current branch is not a release/hotfix else the</p> <code>Res[tuple[str, str]]</code> <p>release type and version to release/hotfix.</p> Source code in <code>m/ci/release_utils.py</code> <pre><code>def assert_branch(branch: str, step: str) -&gt; Res[tuple[str, str]]:\n    \"\"\"Assert that a release step is done in the proper branch.\n\n    This can only happen in `release/x.y.z` or `hotfix/x.y.z`.\n\n    Args:\n        branch: branch name to verify.\n        step: the release step name.\n\n    Returns:\n        An Issue if the current branch is not a release/hotfix else the\n        release type and version to release/hotfix.\n    \"\"\"\n    valid_prefix = ('release/', 'hotfix/')\n    if branch.startswith(valid_prefix):\n        parts = branch.split('/')\n        return Good((parts[0], parts[1]))\n    return issue(\n        f'{step}_release can only be done from a release/hotfix branch',\n        context={\n            'current_branch': branch,\n            'expected': 'release/x.y.z or hotfix/x.y.z',\n        },\n    )\n</code></pre>"},{"location":"api/m/ci/release_utils/#m.ci.release_utils.is_yes","title":"<code>is_yes(user_response)</code>","text":"<p>Assert the user response is \"yes\".</p> <p>Parameters:</p> Name Type Description Default <code>user_response</code> <code>str</code> <p>user's response</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the string is \"yes\".</p> Source code in <code>m/ci/release_utils.py</code> <pre><code>def is_yes(user_response: str) -&gt; bool:\n    \"\"\"Assert the user response is \"yes\".\n\n    Args:\n        user_response: user's response\n\n    Returns:\n        True if the string is \"yes\".\n    \"\"\"\n    return user_response == 'yes'\n</code></pre>"},{"location":"api/m/ci/review_release/","title":"review_release","text":""},{"location":"api/m/ci/review_release/#m.ci.review_release.acknowledge_git_status","title":"<code>acknowledge_git_status(status)</code>","text":"<p>Display the current git status and ask developer to confirm.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>The raw output of <code>git status</code>.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue to stop the operation, otherwise None.</p> Source code in <code>m/ci/review_release.py</code> <pre><code>def acknowledge_git_status(status: str) -&gt; Res[None]:\n    \"\"\"Display the current git status and ask developer to confirm.\n\n    Args:\n        status: The raw output of `git status`.\n\n    Returns:\n        An issue to stop the operation, otherwise None.\n    \"\"\"\n    logger.info('The following changes will be committed', {'git': status})\n    response = io.prompt_choices(\n        'proceed creating the pull request(s)?',\n        YES_NO,\n        as_list=False,\n    )\n    if is_yes(response):\n        return Good(None)\n    return issue('operation cancelled by user')\n</code></pre>"},{"location":"api/m/ci/review_release/#m.ci.review_release.create_prs","title":"<code>create_prs(gh_token, config, release_type, target_ver, gh_ver)</code>","text":"<p>Create release pull request(s).</p> <p>Parameters:</p> Name Type Description Default <code>gh_token</code> <code>str</code> <p>The GITHUB_TOKEN to use to make api calls to Github.</p> required <code>config</code> <code>Config</code> <p>The m configuration.</p> required <code>release_type</code> <code>str</code> <p>'hotfix' or 'release'.</p> required <code>target_ver</code> <code>str</code> <p>The version to release.</p> required <code>gh_ver</code> <code>str</code> <p>The current version in Github.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue if there is a problem while creating or None if successful.</p> Source code in <code>m/ci/review_release.py</code> <pre><code>def create_prs(\n    gh_token: str,\n    config: Config,\n    release_type: str,\n    target_ver: str,\n    gh_ver: str,\n) -&gt; Res[None]:\n    \"\"\"Create release pull request(s).\n\n    Args:\n        gh_token: The GITHUB_TOKEN to use to make api calls to Github.\n        config: The m configuration.\n        release_type: 'hotfix' or 'release'.\n        target_ver: The version to release.\n        gh_ver: The current version in Github.\n\n    Returns:\n        An issue if there is a problem while creating or None if successful.\n    \"\"\"\n    all_prs: dict[str, str] = {}\n    git_branch = f'{release_type}/{target_ver}'\n    develop_branch = config.get_develop_branch()\n    if config.uses_git_flow():\n        title = f'({release_type} to {develop_branch}) {target_ver}'\n        backport_pr = create_pr(\n            gh_token,\n            config.owner,\n            config.repo,\n            GithubPullRequest(\n                title=title,\n                body=_git_flow_pr_body(config, git_branch, gh_ver),\n                head=git_branch,\n                base=develop_branch,\n            ),\n        ).map(lambda res: cast(str, res.get('html_url', '')))\n        if isinstance(backport_pr, Bad):\n            logger.warning(\n                'unable to create backport pull request',\n                backport_pr.value,\n            )\n        else:\n            all_prs[title] = backport_pr.value\n    title = f'({release_type}) {target_ver}'\n    release_pr = create_pr(\n        gh_token,\n        config.owner,\n        config.repo,\n        GithubPullRequest(\n            title=title,\n            body=release_pr_body(config, gh_ver),\n            head=git_branch,\n            base=config.get_master_branch(),\n        ),\n    ).map(lambda res: cast(str, res.get('html_url', '')))\n    if isinstance(release_pr, Bad):\n        logger.warning(\n            'unable to create release pull request',\n            release_pr.value,\n        )\n    else:\n        all_prs[title] = release_pr.value\n    if all_prs:\n        logger.info('pull requests created', context=all_prs)\n        return Good(None)\n    return issue('no prs were created, inspect logs for hints')\n</code></pre>"},{"location":"api/m/ci/review_release/#m.ci.review_release.inspect_prs","title":"<code>inspect_prs(all_prs)</code>","text":"<p>Inspect the release pull requests.</p> <p>There should not be any pull requests when calling <code>review_release</code>. This is a one time operation.</p> <p>Parameters:</p> Name Type Description Default <code>all_prs</code> <code>list[PullRequest]</code> <p>The list of pull requests.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue if prs already exist, None otherwise.</p> Source code in <code>m/ci/review_release.py</code> <pre><code>def inspect_prs(all_prs: list[PullRequest]) -&gt; Res[None]:\n    \"\"\"Inspect the release pull requests.\n\n    There should not be any pull requests when calling `review_release`.\n    This is a one time operation.\n\n    Args:\n        all_prs: The list of pull requests.\n\n    Returns:\n        An issue if prs already exist, None otherwise.\n    \"\"\"\n    prs = [pr for pr in all_prs if pr.closed is False]\n    if prs:\n        return issue('release is already in review', context={\n            'prs': {pr.number: pr.url for pr in prs},\n        })\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/review_release/#m.ci.review_release.release_pr_body","title":"<code>release_pr_body(config, gh_ver)</code>","text":"<p>Generate the pull request body.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The <code>m</code> configuration.</p> required <code>gh_ver</code> <code>str</code> <p>The current version in Github.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The text to add to the pull request.</p> Source code in <code>m/ci/review_release.py</code> <pre><code>def release_pr_body(config: Config, gh_ver: str) -&gt; str:\n    \"\"\"Generate the pull request body.\n\n    Args:\n        config: The `m` configuration.\n        gh_ver: The current version in Github.\n\n    Returns:\n        The text to add to the pull request.\n    \"\"\"\n    link = compare_sha_url(config.owner, config.repo, gh_ver, 'HEAD')\n    instructions = (\n        '**DO NOT** use the merge button. Instead run `m end_release`.'\n        if config.uses_git_flow()\n        else 'either push the merge button or run `m end_release`'\n    )\n    return dedent(f\"\"\"\\\n        ## Reviewer directions\n\n        Verify `CHANGELOG.md` contains a summary of the unreleased changes.\n\n        {link}\n\n        ## Author directions\n\n        - Wait for reviewers to approve\n        - When approved, {instructions}\n    \"\"\")\n</code></pre>"},{"location":"api/m/ci/review_release/#m.ci.review_release.review_release","title":"<code>review_release(token)</code>","text":"<p>Create release prs.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The GITHUB_TOKEN to use to make api calls to Github.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, otherwise an issue.</p> Source code in <code>m/ci/review_release.py</code> <pre><code>def review_release(token: str) -&gt; Res[None]:\n    \"\"\"Create release prs.\n\n    Args:\n        token: The GITHUB_TOKEN to use to make api calls to Github.\n\n    Returns:\n        None if successful, otherwise an issue.\n    \"\"\"\n    return one_of(lambda: [\n        None\n        for branch in git.get_branch()\n        for release_type, target_ver in assert_branch(branch, 'review')\n        for config in read_config('m')\n        for prs in fetch_branch_prs(token, config.owner, config.repo, branch)\n        for _ in inspect_prs(prs)\n        for _ in git.stage_all()\n        for git_status in git.raw_status()\n        for _ in acknowledge_git_status(git_status)\n        for _ in _commit_changes(f'({release_type}) {target_ver}')\n        for _ in git.push_branch(branch)\n        for gh_ver in get_latest_release(token, config.owner, config.repo)\n        for _ in create_prs(token, config, release_type, target_ver, gh_ver)\n    ])\n</code></pre>"},{"location":"api/m/ci/start_release/","title":"start_release","text":""},{"location":"api/m/ci/start_release/#m.ci.start_release.after_checkout","title":"<code>after_checkout(branch_checkout, stashed)</code>","text":"<p>Notify the user that the branch has switched.</p> <p>Optionally if there are stashed changes they will be popped.</p> <p>Parameters:</p> Name Type Description Default <code>branch_checkout</code> <code>str</code> <p>output from git checkout.</p> required <code>stashed</code> <code>bool</code> <p>If True, it will run git stash pop.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>A OneOf with None. There should be no issues. A warning may show up.</p> Source code in <code>m/ci/start_release.py</code> <pre><code>def after_checkout(branch_checkout: str, stashed: bool) -&gt; Res[None]:\n    \"\"\"Notify the user that the branch has switched.\n\n    Optionally if there are stashed changes they will be popped.\n\n    Args:\n        branch_checkout: output from git checkout.\n        stashed: If True, it will run git stash pop.\n\n    Returns:\n        A OneOf with None. There should be no issues. A warning may show up.\n    \"\"\"\n    logger.info('branch checkout successful', {\n        'git': f'{branch_checkout}\\n',\n    })\n    if stashed:\n        pop_result = git.stash_pop()\n        if isinstance(pop_result, Bad):\n            logger.warning('`git stash pop` issue', pop_result.value)\n        else:\n            logger.info('stashed files have been restored')\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/start_release/#m.ci.start_release.assert_git_status","title":"<code>assert_git_status(status, description)</code>","text":"<p>Assert that the current branch is in a clean state.</p> <p>This action may stash some changes. This happens when the developer works on a hotfix and starts making changes directly in the branch.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>short key describing the status</p> required <code>description</code> <code>str</code> <p>The text used to determine the status</p> required <p>Returns:</p> Type Description <code>Res[bool]</code> <p>An issue explaining why we cannot complete the release setup. If</p> <code>Res[bool]</code> <p>successful it will return a boolean value. A true value means that</p> <code>Res[bool]</code> <p>the process stashed changes and they will need to be popped.</p> Source code in <code>m/ci/start_release.py</code> <pre><code>def assert_git_status(status: str, description: str) -&gt; Res[bool]:\n    \"\"\"Assert that the current branch is in a clean state.\n\n    This action may stash some changes. This happens when the developer works\n    on a hotfix and starts making changes directly in the branch.\n\n    Args:\n        status: short key describing the status\n        description: The text used to determine the status\n\n    Returns:\n        An issue explaining why we cannot complete the release setup. If\n        successful it will return a boolean value. A true value means that\n        the process stashed changes and they will need to be popped.\n    \"\"\"\n    if status == 'clean':\n        logger.info('branch is in a clean state')\n        return Good(False)\n    if status in {'ahead', 'behind'}:\n        return issue(\n            'branch is not in sync with the remote branch',\n            context={\n                'git_status': description,\n                'suggestion': 'try running `git pull` and/or `git push`',\n            },\n        )\n    can_stash = {\n        'Untracked files',\n        'Changes to be committed',\n        'Changed but not updated',\n        'Changes not staged',\n    }\n    if description in can_stash:\n        logger.warning(f'git status: {description}')\n        response = io.prompt_choices(\n            'would you like to stash the changes and continue?',\n            YES_NO,\n            as_list=False,\n        )\n        if is_yes(response):\n            return one_of(lambda: [\n                True\n                for cmd_out in git.stash()\n                for _ in logger.info('ran `git stash`', {'git': cmd_out})\n            ]).flat_map_bad(hone('git stash failure'))\n    return issue(\n        'releases can only be done in a clean git state',\n        context={\n            'git_status': status,\n            'description': description,\n        },\n    )\n</code></pre>"},{"location":"api/m/ci/start_release/#m.ci.start_release.start_release","title":"<code>start_release(gh_token, hotfix=False)</code>","text":"<p>Start the release process.</p> <p>Parameters:</p> Name Type Description Default <code>gh_token</code> <code>str</code> <p>The GITHUB_TOKEN to use to make api calls to Github.</p> required <code>hotfix</code> <code>bool</code> <p>Set to true to start a hotfix.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, otherwise an issue.</p> Source code in <code>m/ci/start_release.py</code> <pre><code>def start_release(gh_token: str, hotfix: bool = False) -&gt; Res[None]:\n    \"\"\"Start the release process.\n\n    Args:\n        gh_token: The GITHUB_TOKEN to use to make api calls to Github.\n        hotfix: Set to true to start a hotfix.\n\n    Returns:\n        None if successful, otherwise an issue.\n    \"\"\"\n    release_type = 'hotfix' if hotfix else 'release'\n    return one_of(lambda: [\n        None\n        for config in assert_branch(release_type, 'm')\n        for status, description in git.get_status()\n        for stashed_changes in assert_git_status(status, description)\n        for gh_ver in get_latest_release(gh_token, config.owner, config.repo)\n        for commits in _get_commits(gh_ver)\n        for _ in verify_release(commits, hotfix=hotfix)\n        for new_ver in io.prompt_next_version(gh_ver, release_type)\n        for branch_checkout in git.checkout_branch(f'{release_type}/{new_ver}')\n        for _ in after_checkout(branch_checkout, stashed_changes)\n        for _ in release_setup('m', config, new_ver)\n    ])\n</code></pre>"},{"location":"api/m/ci/start_release/#m.ci.start_release.verify_release","title":"<code>verify_release(commits, hotfix)</code>","text":"<p>Compare the number of commits to verify if the release should proceed.</p> <p>In some cases we may start a hotfix without realizing that there are already some commits in the branch that have not been released. In this case it should have been a full release instead.</p> <p>This step can be skipped if <code>commits</code> is <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>commits</code> <code>list[str] | None</code> <p>List of unreleased commits.</p> required <code>hotfix</code> <code>bool</code> <p>flag to let us know if the release is a hotfix.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if everything is good, otherwise an issue.</p> Source code in <code>m/ci/start_release.py</code> <pre><code>def verify_release(\n    commits: list[str] | None,\n    hotfix: bool,\n) -&gt; Res[None]:\n    \"\"\"Compare the number of commits to verify if the release should proceed.\n\n    In some cases we may start a hotfix without realizing that there are\n    already some commits in the branch that have not been released. In this\n    case it should have been a full release instead.\n\n    This step can be skipped if `commits` is `None`.\n\n    Args:\n        commits: List of unreleased commits.\n        hotfix: flag to let us know if the release is a hotfix.\n\n    Returns:\n        None if everything is good, otherwise an issue.\n    \"\"\"\n    if commits is None:\n        return Good(None)\n    if hotfix and len(commits):\n        logger.warning('hotfix may contain unreleased features', {\n            'commits': commits,\n        })\n        response = io.prompt_choices(\n            'Disregard warning and proceed with hotfix?',\n            YES_NO,\n            as_list=False,\n        )\n        if is_yes(response):\n            return Good(None)\n        return issue('hotfix aborted by user', context={\n            'commits': commits,\n            'suggestion': 'consider creating a release',\n        })\n    if not commits and not hotfix:\n        logger.warning('there are no commits to release')\n        response = io.prompt_choices(\n            'Proceed with a release instead of a hotfix?',\n            YES_NO,\n            as_list=False,\n        )\n        if is_yes(response):\n            return Good(None)\n        return issue('release aborted by user', context={\n            'commits': 'no commits to release',\n            'suggestion': 'consider creating a hotfix',\n        })\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/types/","title":"types","text":""},{"location":"api/m/ci/types/#m.ci.types.Branches","title":"<code>Branches</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Default branches to use for the supported workflows.</p> Source code in <code>m/ci/types.py</code> <pre><code>class Branches(str, Enum):  # noqa: WPS600\n    \"\"\"Default branches to use for the supported workflows.\"\"\"\n\n    master = 'master'\n    develop = 'develop'\n    release = 'release'\n    hotfix = 'hotfix'\n\n    def __str__(self: 'Branches') -&gt; str:\n        \"\"\"Return the string representation of the Branch.\n\n        Returns:\n            The string representation of the Branch.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"api/m/ci/types/#m.ci.types.Branches.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the Branch.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the Branch.</p> Source code in <code>m/ci/types.py</code> <pre><code>def __str__(self: 'Branches') -&gt; str:\n    \"\"\"Return the string representation of the Branch.\n\n    Returns:\n        The string representation of the Branch.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"api/m/ci/types/#m.ci.types.GitFlowConfig","title":"<code>GitFlowConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object mapping branches for the git_flow workflow.</p> <p>Attributes:</p> Name Type Description <code>master_branch</code> <code>str | Branches</code> <p>...</p> <code>develop_branch</code> <code>str | Branches</code> <p>...</p> <code>release_prefix</code> <code>str | Branches</code> <p>...</p> <code>hotfix_prefix</code> <code>str | Branches</code> <p>...</p> Source code in <code>m/ci/types.py</code> <pre><code>class GitFlowConfig(BaseModel):\n    \"\"\"An object mapping branches for the git_flow workflow.\"\"\"\n\n    master_branch: str | Branches = Branches.master\n    develop_branch: str | Branches = Branches.develop\n    release_prefix: str | Branches = Branches.release\n    hotfix_prefix: str | Branches = Branches.hotfix\n</code></pre>"},{"location":"api/m/ci/types/#m.ci.types.MFlowConfig","title":"<code>MFlowConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object mapping branches for the m_flow workflow.</p> <p>Attributes:</p> Name Type Description <code>master_branch</code> <code>str | Branches</code> <p>...</p> <code>release_prefix</code> <code>str | Branches</code> <p>...</p> <code>hotfix_prefix</code> <code>str | Branches</code> <p>...</p> Source code in <code>m/ci/types.py</code> <pre><code>class MFlowConfig(BaseModel):\n    \"\"\"An object mapping branches for the m_flow workflow.\"\"\"\n\n    master_branch: str | Branches = Branches.master\n    release_prefix: str | Branches = Branches.release\n    hotfix_prefix: str | Branches = Branches.hotfix\n</code></pre>"},{"location":"api/m/ci/types/#m.ci.types.Workflow","title":"<code>Workflow</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Supported workflows.</p> Source code in <code>m/ci/types.py</code> <pre><code>class Workflow(str, Enum):  # noqa: WPS600\n    \"\"\"Supported workflows.\"\"\"\n\n    git_flow = 'git_flow'\n    m_flow = 'm_flow'\n    free_flow = 'free_flow'\n\n    def __str__(self: 'Workflow') -&gt; str:\n        \"\"\"Return the string representation of the workflow.\n\n        Returns:\n            The string representation of the workflow.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"api/m/ci/types/#m.ci.types.Workflow.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the workflow.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the workflow.</p> Source code in <code>m/ci/types.py</code> <pre><code>def __str__(self: 'Workflow') -&gt; str:\n    \"\"\"Return the string representation of the workflow.\n\n    Returns:\n        The string representation of the workflow.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"api/m/ci/versioning/","title":"versioning","text":""},{"location":"api/m/ci/versioning/#m.ci.versioning.VersionInputs","title":"<code>VersionInputs</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Container with information to generate a version.</p> <p>Attributes:</p> Name Type Description <code>version_prefix</code> <code>str</code> <p>...</p> <code>version</code> <code>str</code> <p>...</p> <code>run_id</code> <code>str | None</code> <p>...</p> <code>sha</code> <code>str</code> <p>...</p> <code>pr_number</code> <code>int | None</code> <p>...</p> <code>branch</code> <code>str</code> <p>...</p> <code>is_release</code> <code>bool</code> <p>...</p> <code>is_release_pr</code> <code>bool</code> <p>...</p> <code>is_hotfix_pr</code> <code>bool</code> <p>...</p> Source code in <code>m/ci/versioning.py</code> <pre><code>class VersionInputs(BaseModel):\n    \"\"\"Container with information to generate a version.\"\"\"\n\n    # '0.0.0-' or 'a.b.c-' or '': Necessary for pr builds\n    version_prefix: str\n\n    # the version in the configuration\n    version: str\n\n    # unique number for each run in CI environment\n    run_id: str | None\n\n    # current commit sha\n    sha: str\n\n    pr_number: int | None\n\n    # The build git branch\n    branch: str\n\n    is_release: bool\n    is_release_pr: bool\n    is_hotfix_pr: bool\n</code></pre>"},{"location":"api/m/ci/versioning/#m.ci.versioning.build_m_tag","title":"<code>build_m_tag(ver_input, config)</code>","text":"<p>Build an valid \"M_TAG\".</p> <p>Parameters:</p> Name Type Description Default <code>ver_input</code> <code>VersionInputs</code> <p>The inputs to create the tag.</p> required <code>config</code> <code>Config</code> <p>The m configuration.</p> required <p>Returns:</p> Type Description <code>str</code> <p>An m tag that can be used to version npm and docker packages.</p> Source code in <code>m/ci/versioning.py</code> <pre><code>def build_m_tag(ver_input: VersionInputs, config: Config) -&gt; str:\n    \"\"\"Build an valid \"M_TAG\".\n\n    Args:\n        ver_input: The inputs to create the tag.\n        config: The m configuration.\n\n    Returns:\n        An m tag that can be used to version npm and docker packages.\n    \"\"\"\n    prefix = '' if config.uses_free_flow() else f'{ver_input.version_prefix}-'\n    pr_number = ver_input.pr_number\n    run_id = ver_input.run_id\n    if not run_id:\n        return f'{prefix}local.{ver_input.sha}'\n    if ver_input.is_release:\n        return ver_input.version\n    if pr_number:\n        nprefix = ''\n        if ver_input.is_release_pr:\n            nprefix = 'rc'\n        elif ver_input.is_hotfix_pr:\n            nprefix = 'hotfix'\n        if nprefix:\n            return f'{ver_input.version}-{nprefix}{pr_number}.b{run_id}'\n        return f'{prefix}pr{pr_number}.b{run_id}'\n    return f'{prefix}{ver_input.branch}.b{run_id}'\n</code></pre>"},{"location":"api/m/ci/versioning/#m.ci.versioning.build_py_tag","title":"<code>build_py_tag(ver_input, config)</code>","text":"<p>Build a valid python version.</p> <p>The configuration object is provided since python does not accept using names of branches in the versions. For this reason we will map</p> <p>Parameters:</p> Name Type Description Default <code>ver_input</code> <code>VersionInputs</code> <p>The inputs to create the version.</p> required <code>config</code> <code>Config</code> <p>The m configuration.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A valid python tag.</p> Source code in <code>m/ci/versioning.py</code> <pre><code>def build_py_tag(ver_input: VersionInputs, config: Config) -&gt; str:\n    \"\"\"Build a valid python version.\n\n    The configuration object is provided since python does not accept using\n    names of branches in the versions. For this reason we will map\n\n    Args:\n        ver_input: The inputs to create the version.\n        config: The m configuration.\n\n    Returns:\n        A valid python tag.\n    \"\"\"\n    prefix = ver_input.version_prefix\n    pr_number = ver_input.pr_number\n    run_id = ver_input.run_id\n    now = int(time.time())\n    if not run_id:\n        return f'{prefix}a0+b{now}'\n    if ver_input.is_release:\n        return ver_input.version\n    if pr_number:\n        nprefix = ''\n        if ver_input.is_release_pr or ver_input.is_hotfix_pr:\n            nprefix = 'rc'\n        if nprefix:\n            return f'{ver_input.version}{nprefix}{pr_number}.dev{run_id}'\n        return f'{prefix}b{pr_number}.dev{run_id}'\n    nprefix = _get_py_branch_prefix(config, ver_input.branch)\n    return f'{prefix}{nprefix}.dev{run_id}'\n</code></pre>"},{"location":"api/m/ci/celt/","title":"celt","text":""},{"location":"api/m/ci/celt/post_processor/","title":"post_processor","text":""},{"location":"api/m/ci/celt/post_processor/#m.ci.celt.post_processor.get_post_processor","title":"<code>get_post_processor(name, celt_config)</code>","text":"<p>Find an available post processor based on the key provided.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the post processor</p> required <code>celt_config</code> <code>Configuration</code> <p>The configuration to use</p> required <p>Returns:</p> Type Description <code>Res[PostProcessor]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a post processor function.</p> Source code in <code>m/ci/celt/post_processor.py</code> <pre><code>def get_post_processor(\n    name: str,\n    celt_config: Configuration,\n) -&gt; Res[PostProcessor]:\n    \"\"\"Find an available post processor based on the key provided.\n\n    Args:\n        name: name of the post processor\n        celt_config: The configuration to use\n\n    Returns:\n        A `OneOf` containing an `Issue` or a post processor function.\n    \"\"\"\n    mapping: Dict[str, Transform] = {\n        'eslint': eslint.read_payload,\n        'pycodestyle': pycodestyle.read_payload,\n        'flake8': pycodestyle.read_payload,\n        'pylint': pylint.read_payload,\n        'typescript': typescript.read_payload,\n        'ruff': ruff.read_payload,\n    }\n    if name not in mapping:\n        return issue(f'{name} is not a supported post processor')\n\n    return Good(PostProcessor(name, celt_config, mapping[name]))\n</code></pre>"},{"location":"api/m/ci/celt/core/","title":"core","text":""},{"location":"api/m/ci/celt/core/io/","title":"io","text":""},{"location":"api/m/ci/celt/core/io/#m.ci.celt.core.io.format_row","title":"<code>format_row(tokens, widths, alignment)</code>","text":"<p>Format a row to be displayed in a table.</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>List[Any]</code> <p>A list of values to be displayed.</p> required <code>widths</code> <code>List[int]</code> <p>A list of integers of same size as tokens dictating the how many spaces to take for a token.</p> required <code>alignment</code> <code>str</code> <p>Either 'l' or 'r' so that the tokens may be aligned on the left or right.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A single string for a row of a table.</p> Source code in <code>m/ci/celt/core/io.py</code> <pre><code>def format_row(tokens: List[Any], widths: List[int], alignment: str) -&gt; str:\n    \"\"\"Format a row to be displayed in a table.\n\n    Args:\n        tokens:\n            A list of values to be displayed.\n        widths:\n            A list of integers of same size as tokens dictating the how many\n            spaces to take for a token.\n        alignment:\n            Either 'l' or 'r' so that the tokens may be aligned on the left\n            or right.\n\n    Returns:\n        A single string for a row of a table.\n    \"\"\"\n    return '  '.join([\n        token\n        for index, align in enumerate(alignment)\n        for token in (_align(tokens[index], align)(widths[index]),)\n    ])\n</code></pre>"},{"location":"api/m/ci/celt/core/io/#m.ci.celt.core.io.project_stats_json","title":"<code>project_stats_json(name, project)</code>","text":"<p>Stringify a <code>ProjectStatus</code> instance.</p> <p>Displays as json showing the current total of violations for each rule.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the compiler/linter.</p> required <code>project</code> <code>ProjectStatus</code> <p>The <code>ProjectStatus</code> instance.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string version of the project status.</p> Source code in <code>m/ci/celt/core/io.py</code> <pre><code>def project_stats_json(\n    name: str,\n    project: ProjectStatus,\n) -&gt; str:\n    \"\"\"Stringify a `ProjectStatus` instance.\n\n    Displays as json showing the current total of violations for each rule.\n\n    Args:\n        name: The name of the compiler/linter.\n        project: The `ProjectStatus` instance.\n\n    Returns:\n        The string version of the project status.\n    \"\"\"\n    cap_name = name.capitalize()\n    buffer = [\n        '{',\n        f'  \"allowed{cap_name}Rules\": {{',\n    ]\n\n    key_rule = sorted(\n        [\n            x\n            for x in project.rules.items()\n            if x[1].found &gt; 0 and not x[1].ignored\n        ],\n        key=cmp_to_key(_compare_rule_items),\n    )\n\n    if key_rule:\n        buffer.extend([\n            f'    \"{rule_id}\": {rule.found},'\n            for rule_id, rule in key_rule[:-1]\n        ])\n        rule_id, rule = key_rule[-1]\n        buffer.append(f'    \"{rule_id}\": {rule.found}')\n\n    buffer.extend([\n        '  }',\n        '}',\n    ])\n    return '\\n'.join(buffer)\n</code></pre>"},{"location":"api/m/ci/celt/core/io/#m.ci.celt.core.io.project_status_str","title":"<code>project_status_str(project, celt_config)</code>","text":"<p>Stringify a <code>ProjectStatus</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>ProjectStatus</code> <p>The <code>ProjectStatus</code> instance.</p> required <code>celt_config</code> <code>Configuration</code> <p>The post processor configuration.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string version of the project status.</p> Source code in <code>m/ci/celt/core/io.py</code> <pre><code>def project_status_str(\n    project: ProjectStatus,\n    celt_config: Configuration,\n) -&gt; str:\n    \"\"\"Stringify a `ProjectStatus` instance.\n\n    Args:\n        project: The `ProjectStatus` instance.\n        celt_config: The post processor configuration.\n\n    Returns:\n        The string version of the project status.\n    \"\"\"\n    keys = project.rules.keys()\n    rules = sorted(project.rules.values(), key=cmp_to_key(_compare_rules))\n\n    if project.status == ExitCode.ok:\n        buffer = [\n            rule_info_str(rule, celt_config)\n            for rule in rules\n            if rule.ignored\n        ]\n        if project.total_found &gt; 0:\n            buffer.append(\n                color(\n                    '{gray}project has ',\n                    f'{{red}}{project.total_found} errors',\n                    '{gray} to clear',\n                ),\n            )\n        else:\n            msg = 'no errors found'\n            buffer.append(color(f'{{bold_green}}{msg}'))\n        return '\\n'.join(buffer)\n\n    buffer = [\n        rule_info_str(rule, celt_config)\n        for rule in rules\n        if rule.found &gt; rule.allowed\n    ]\n\n    buffer.append(color('{bold}FILES:'))\n    by_file = sorted(project.files.items(), key=lambda t: len(t[1]))\n    buffer.extend([\n        color(f'  {{gray}}{file_name}:{{end}} found {total}')\n        for file_name, violations in by_file\n        for total in (len(violations), )\n    ])\n    buffer.append('')\n\n    c1_w = max((len(x) for x in keys))\n    c1_w = max([c1_w, len('rules')])\n    c2_w = max((len(str(s.found)) for s in rules))\n    c2_w = max([c2_w, len('found')])\n    c3_w = max((len(str(s.allowed)) for s in rules))\n    c3_w = max([c3_w, len('allowed')])\n    widths = [c1_w, c2_w, c3_w]\n\n    key_rule = sorted(\n        project.rules.items(),\n        key=cmp_to_key(_compare_rule_items),\n    )\n    buffer.append(format_row(['RULES', 'FOUND', 'ALLOWED'], widths, 'lll'))\n    buffer.extend([\n        (\n            color(\n                '{gray}',\n                format_row([rule_id, rule.found, rule.allowed], widths, 'lrr'),\n            )\n            if rule.found == rule.allowed\n            else format_row([rule_id, rule.found, rule.allowed], widths, 'lrr')\n        )\n        for rule_id, rule in key_rule\n        if not rule.ignored\n    ])\n    buffer.append('')\n    return '\\n'.join(buffer)\n</code></pre>"},{"location":"api/m/ci/celt/core/io/#m.ci.celt.core.io.rule_info_str","title":"<code>rule_info_str(rule, config)</code>","text":"<p>Format a single rule and its violations.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>RuleInfo</code> <p>The rule to display.</p> required <code>config</code> <code>Configuration</code> <p>The post processor configuration.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the rule info.</p> Source code in <code>m/ci/celt/core/io.py</code> <pre><code>def rule_info_str(\n    rule: RuleInfo,\n    config: Configuration,\n) -&gt; str:\n    \"\"\"Format a single rule and its violations.\n\n    Args:\n        rule: The rule to display.\n        config: The post processor configuration.\n\n    Returns:\n        A string representation of the rule info.\n    \"\"\"\n    allowed = 'IGNORED' if rule.ignored else f'allowed {rule.allowed}'\n    rule_id = color(f'{{red}}{rule.rule_id}{{end}}')\n    total_found = color(f'{{red}}{rule.found}{{end}}')\n    buffer = [f'{rule_id} (found {total_found}, {allowed}):']\n    violations = (\n        rule.violations\n        if config.max_lines == -1\n        else rule.violations[:config.max_lines]\n    )\n    for violation in violations:\n        file_path = violation.file_path\n        msg, *rest = violation.message.splitlines()\n        line = violation.line\n        column = violation.column\n        file_loc = color(f'{{gray}}{file_path}:{line}:{column}{{end}}')\n        buffer.append(f'  {file_loc} - {msg}')\n        if rest and config.full_message:\n            buffer.extend([f'    {x}' for x in rest])\n    if -1 &lt; config.max_lines &lt; len(rule.violations):\n        remaining = len(rule.violations) - config.max_lines\n        buffer.append(f'  ... and {remaining} more')\n    buffer.append('')\n    return '\\n'.join(buffer)\n</code></pre>"},{"location":"api/m/ci/celt/core/process/","title":"process","text":""},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.PostProcessor","title":"<code>PostProcessor</code>","text":"<p>A post processor to handle a compiler/linter ouput.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>class PostProcessor:\n    \"\"\"A post processor to handle a compiler/linter ouput.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        celt_config: Configuration,\n        transform: Transform,\n    ):\n        \"\"\"Instantiate a `PostProcessor`.\n\n        Args:\n            name: The name of the compiler/linter.\n            celt_config: The post processor configuration.\n            transform: Function to generate a list of `FileReport` objects.\n        \"\"\"\n        self.name = name\n        self.celt_config = celt_config\n        self.transform = transform\n\n    def run(\n        self,\n        payload: str,\n        config: Dict[str, Any],\n    ) -&gt; Res[ProjectStatus]:\n        \"\"\"Run the processor on the given payload.\n\n        Args:\n            payload: The payload from the compiler/linter.\n            config: A dictionary with rule allowance/ignores.\n\n        Returns:\n            A `OneOf` containing an `Issue` or the `ProjectStatus`.\n        \"\"\"\n        cap_name = self.name.capitalize()\n        allowed_rules = config.get(f'allowed{cap_name}Rules', {})\n        if self.celt_config.ignore_error_allowance:\n            allowed_rules = {}\n        ignored_rules = config.get(f'ignored{cap_name}Rules', {})\n        return process(\n            payload,\n            self.transform,\n            allowed_rules,\n            ignored_rules,\n            self.celt_config,\n        )\n\n    def to_str(self, project: ProjectStatus) -&gt; str:\n        \"\"\"Stringify a `ProjectStatus`.\n\n        Args:\n            project: The `ProjectStatus` obtained by running the `run` method.\n\n        Returns:\n            The string version of the project status.\n        \"\"\"\n        return project_status_str(project, self.celt_config)\n\n    def stats_json(self, project: ProjectStatus) -&gt; str:\n        \"\"\"Stringify a `ProjectStatus`.\n\n        Show a dictionary with the total number of violations. Useful when\n        writing an entry for the configuration file.\n\n        Args:\n            project: The `ProjectStatus` obtained by running the `run` method.\n\n        Returns:\n            The string version of the project status.\n        \"\"\"\n        return project_stats_json(self.name, project)\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.PostProcessor.__init__","title":"<code>__init__(name, celt_config, transform)</code>","text":"<p>Instantiate a <code>PostProcessor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the compiler/linter.</p> required <code>celt_config</code> <code>Configuration</code> <p>The post processor configuration.</p> required <code>transform</code> <code>Transform</code> <p>Function to generate a list of <code>FileReport</code> objects.</p> required Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    celt_config: Configuration,\n    transform: Transform,\n):\n    \"\"\"Instantiate a `PostProcessor`.\n\n    Args:\n        name: The name of the compiler/linter.\n        celt_config: The post processor configuration.\n        transform: Function to generate a list of `FileReport` objects.\n    \"\"\"\n    self.name = name\n    self.celt_config = celt_config\n    self.transform = transform\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.PostProcessor.run","title":"<code>run(payload, config)</code>","text":"<p>Run the processor on the given payload.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The payload from the compiler/linter.</p> required <code>config</code> <code>Dict[str, Any]</code> <p>A dictionary with rule allowance/ignores.</p> required <p>Returns:</p> Type Description <code>Res[ProjectStatus]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the <code>ProjectStatus</code>.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def run(\n    self,\n    payload: str,\n    config: Dict[str, Any],\n) -&gt; Res[ProjectStatus]:\n    \"\"\"Run the processor on the given payload.\n\n    Args:\n        payload: The payload from the compiler/linter.\n        config: A dictionary with rule allowance/ignores.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the `ProjectStatus`.\n    \"\"\"\n    cap_name = self.name.capitalize()\n    allowed_rules = config.get(f'allowed{cap_name}Rules', {})\n    if self.celt_config.ignore_error_allowance:\n        allowed_rules = {}\n    ignored_rules = config.get(f'ignored{cap_name}Rules', {})\n    return process(\n        payload,\n        self.transform,\n        allowed_rules,\n        ignored_rules,\n        self.celt_config,\n    )\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.PostProcessor.stats_json","title":"<code>stats_json(project)</code>","text":"<p>Stringify a <code>ProjectStatus</code>.</p> <p>Show a dictionary with the total number of violations. Useful when writing an entry for the configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>ProjectStatus</code> <p>The <code>ProjectStatus</code> obtained by running the <code>run</code> method.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string version of the project status.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def stats_json(self, project: ProjectStatus) -&gt; str:\n    \"\"\"Stringify a `ProjectStatus`.\n\n    Show a dictionary with the total number of violations. Useful when\n    writing an entry for the configuration file.\n\n    Args:\n        project: The `ProjectStatus` obtained by running the `run` method.\n\n    Returns:\n        The string version of the project status.\n    \"\"\"\n    return project_stats_json(self.name, project)\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.PostProcessor.to_str","title":"<code>to_str(project)</code>","text":"<p>Stringify a <code>ProjectStatus</code>.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>ProjectStatus</code> <p>The <code>ProjectStatus</code> obtained by running the <code>run</code> method.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string version of the project status.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def to_str(self, project: ProjectStatus) -&gt; str:\n    \"\"\"Stringify a `ProjectStatus`.\n\n    Args:\n        project: The `ProjectStatus` obtained by running the `run` method.\n\n    Returns:\n        The string version of the project status.\n    \"\"\"\n    return project_status_str(project, self.celt_config)\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.filter_reports","title":"<code>filter_reports(reports, regex=None)</code>","text":"<p>Filter the list of file reports based on the file path.</p> <p>It also removes any file report that does not have any violations.</p> <p>Parameters:</p> Name Type Description Default <code>reports</code> <code>List[FileReport]</code> <p>List of file reports.</p> required <code>regex</code> <code>Optional[str]</code> <p>The post processor configuration.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[FileReport]</code> <p>A list of file reports with at least one violation and file_path</p> <code>List[FileReport]</code> <p>matching the provided regex.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def filter_reports(\n    reports: List[FileReport],\n    regex: Optional[str] = None,\n) -&gt; List[FileReport]:\n    \"\"\"Filter the list of file reports based on the file path.\n\n    It also removes any file report that does not have any violations.\n\n    Args:\n        reports: List of file reports.\n        regex: The post processor configuration.\n\n    Returns:\n        A list of file reports with at least one violation and file_path\n        matching the provided regex.\n    \"\"\"\n    return [\n        rpt\n        for rpt in reports\n        if rpt.violations and (not regex or re.match(regex, rpt.file_path))\n    ]\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.get_project_status","title":"<code>get_project_status(payload, reports, rules_dict, allowed_rules, ignored_rules)</code>","text":"<p>Analyze the rules_dictionary with the allowed and ignored rules.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The original payload from the compiler/linter.</p> required <code>reports</code> <code>List[FileReport]</code> <p>List of file reports.</p> required <code>rules_dict</code> <code>Dict[str, List[Violation]]</code> <p>A map of rule ids to a list of violations.</p> required <code>allowed_rules</code> <code>Dict[str, int]</code> <p>A dictionary specifying the allowed violations.</p> required <code>ignored_rules</code> <code>Dict[str, str]</code> <p>A dictionary specifying the rules to ignore.</p> required <p>Returns:</p> Type Description <code>ProjectStatus</code> <p>A ProjectStatus object.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def get_project_status(\n    payload: str,\n    reports: List[FileReport],\n    rules_dict: Dict[str, List[Violation]],\n    allowed_rules: Dict[str, int],\n    ignored_rules: Dict[str, str],\n) -&gt; ProjectStatus:\n    \"\"\"Analyze the rules_dictionary with the allowed and ignored rules.\n\n    Args:\n        payload: The original payload from the compiler/linter.\n        reports: List of file reports.\n        rules_dict: A map of rule ids to a list of violations.\n        allowed_rules: A dictionary specifying the allowed violations.\n        ignored_rules: A dictionary specifying the rules to ignore.\n\n    Returns:\n        A ProjectStatus object.\n    \"\"\"\n    rules: Dict[str, RuleInfo] = {}\n    files: Dict[str, List[Violation]] = {\n        x.file_path: x.violations\n        for x in reports\n    }\n\n    failed, needs_readjustment = _process_rules_dict(\n        rules_dict, allowed_rules, ignored_rules, rules,\n    )\n\n    for rule_id, allowed in allowed_rules.items():\n        if rule_id not in rules:\n            rules[rule_id] = RuleInfo(rule_id, [], 0, allowed, ignored=False)\n            if allowed &gt; 0:\n                needs_readjustment = True\n\n    status = ExitCode.ok\n    if failed:\n        status = ExitCode.error\n    elif needs_readjustment:\n        status = ExitCode.needs_readjustment\n    return ProjectStatus(status, payload, rules, files)\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.process","title":"<code>process(raw_payload, transform, allowed_rules, ignored_rules, celt_config)</code>","text":"<p>Process the output of a compiler/linter.</p> <p>Parameters:</p> Name Type Description Default <code>raw_payload</code> <code>str</code> <p>The payload from the compiler/linter.</p> required <code>transform</code> <code>Transform</code> <p>Function to generate a list of <code>FileReport</code> objects.</p> required <code>allowed_rules</code> <code>Dict[str, int]</code> <p>A dictionary specifying the allowed violations.</p> required <code>ignored_rules</code> <code>Dict[str, str]</code> <p>A dictionary specifying the rules to ignore.</p> required <code>celt_config</code> <code>Configuration</code> <p>The post processor configuration.</p> required <p>Returns:</p> Type Description <code>Res[ProjectStatus]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a <code>ProjectStatus</code> object.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def process(\n    raw_payload: str,\n    transform: Transform,\n    allowed_rules: Dict[str, int],\n    ignored_rules: Dict[str, str],\n    celt_config: Configuration,\n) -&gt; Res[ProjectStatus]:\n    \"\"\"Process the output of a compiler/linter.\n\n    Args:\n        raw_payload: The payload from the compiler/linter.\n        transform: Function to generate a list of `FileReport` objects.\n        allowed_rules: A dictionary specifying the allowed violations.\n        ignored_rules: A dictionary specifying the rules to ignore.\n        celt_config: The post processor configuration.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a `ProjectStatus` object.\n    \"\"\"\n    return one_of(lambda: [\n        project_status\n        for payload in replace_filenames(raw_payload, celt_config.file_prefix)\n        for reports in transform(payload)\n        for filtered in (filter_reports(reports, celt_config.file_regex),)\n        for rules_dict in (to_rules_dict(filtered),)\n        for project_status in (\n            get_project_status(\n                payload, filtered, rules_dict, allowed_rules, ignored_rules,\n            ),\n        )\n    ])\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.replace_filenames","title":"<code>replace_filenames(payload, file_prefix)</code>","text":"<p>Replace the prefix of file names.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>str The payload from a compiler/linter.</p> required <code>file_prefix</code> <code>Optional[str]</code> <p>Optional[str] A string of the form <code>[old]:[new]</code>. The old prefix can be a <code>|</code> separated list of strings. For instance <code>path/to/foo|path/to:bar</code></p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an Issue or the <code>payload</code> with all file path</p> <code>Res[str]</code> <p>replaced according to the file_prefix.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def replace_filenames(\n    payload: str,\n    file_prefix: Optional[str],\n) -&gt; Res[str]:\n    \"\"\"Replace the prefix of file names.\n\n    Args:\n        payload: str\n            The payload from a compiler/linter.\n        file_prefix: Optional[str]\n            A string of the form `[old]:[new]`. The old prefix can be\n            a `|` separated list of strings. For instance\n            `path/to/foo|path/to:bar`\n\n    Returns:\n        A `OneOf` containing an Issue or the `payload` with all file path\n        replaced according to the file_prefix.\n    \"\"\"\n    if not file_prefix:\n        return Good(payload)\n    try:\n        old, prefix = file_prefix.split(':')\n    except ValueError as ex:\n        return issue('file_prefix param missing `:`', cause=ex)\n    return Good(re.sub(\n        fr'({old})(.*?)\\.([a-z]+)',\n        lambda x: [\n            # Not sure how fix this mypy issue\n            f'{prefix}{filename}.{ext}'  # type: ignore\n            for _, filename, ext in (x.groups(),)\n        ][0],\n        payload,\n    ))\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.to_rules_dict","title":"<code>to_rules_dict(reports)</code>","text":"<p>Convert a list of <code>FileReport</code> to a map of rules to <code>Violation</code>.</p> <p>Parameters:</p> Name Type Description Default <code>reports</code> <code>List[FileReport]</code> <p>A list of <code>FileReport</code> instances.</p> required <p>Returns:</p> Type Description <code>Dict[str, List[Violation]]</code> <p>A dictionary mapping rules to a list of <code>Violation</code>.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def to_rules_dict(reports: List[FileReport]) -&gt; Dict[str, List[Violation]]:\n    \"\"\"Convert a list of `FileReport` to a map of rules to `Violation`.\n\n    Args:\n        reports: A list of `FileReport` instances.\n\n    Returns:\n        A dictionary mapping rules to a list of `Violation`.\n    \"\"\"\n    rules: Dict[str, List[Violation]] = {}\n    for report in reports:\n        for violation in report.violations:\n            if violation.rule_id not in rules:\n                rules[violation.rule_id] = []\n            rules[violation.rule_id].append(violation)\n    return rules\n</code></pre>"},{"location":"api/m/ci/celt/core/types/","title":"types","text":""},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>Options to control the output of the post processor.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>@dataclass\nclass Configuration:\n    \"\"\"Options to control the output of the post processor.\"\"\"\n\n    max_lines: int = 5\n    full_message: bool = False\n    ignore_error_allowance: bool = False\n    file_regex: Optional[str] = None\n    file_prefix: Optional[str] = None\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.ExitCode","title":"<code>ExitCode</code>","text":"<p>             Bases: <code>Enum</code></p> <p>One of the possible exit codes.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>class ExitCode(enum.Enum):\n    \"\"\"One of the possible exit codes.\"\"\"\n\n    ok = 0\n    error = 1\n    needs_readjustment = 2\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.FileReport","title":"<code>FileReport</code>  <code>dataclass</code>","text":"<p>Collection of violations triggered in a single file.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>@dataclass\nclass FileReport:\n    \"\"\"Collection of violations triggered in a single file.\"\"\"\n\n    file_path: str\n    violations: List[Violation]\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.ProjectStatus","title":"<code>ProjectStatus</code>  <code>dataclass</code>","text":"<p>Overview of a project.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>@dataclass\nclass ProjectStatus:\n    \"\"\"Overview of a project.\"\"\"\n\n    status: ExitCode\n    payload: str\n    rules: Dict[str, RuleInfo]\n    files: Dict[str, List[Violation]]\n    total_found: int = field(init=False)\n    total_allowed: int = field(init=False)\n    error_msg: str = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"Compute the rest of non initialized variables.\"\"\"\n        rules = self.rules.values()\n        total_found = sum((s.found for s in rules if not s.ignored))\n        total_allowed = sum((s.allowed for s in rules if not s.ignored))\n        error_msg = ''\n        if self.status == ExitCode.error:\n            diff = sum((\n                d\n                for s in rules\n                for d in (s.found - s.allowed,)\n                if d &gt; 0 and not s.ignored\n            ))\n            error_msg = f'{diff} extra errors were introduced'\n        elif self.status == ExitCode.needs_readjustment:\n            diff = total_allowed - total_found\n            error_msg = f'{diff} errors were removed - lower error allowance'\n\n        self.total_found = total_found  # noqa: WPS601\n        self.total_allowed = total_allowed  # noqa: WPS601\n        self.error_msg = error_msg  # noqa: WPS601\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.ProjectStatus.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Compute the rest of non initialized variables.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Compute the rest of non initialized variables.\"\"\"\n    rules = self.rules.values()\n    total_found = sum((s.found for s in rules if not s.ignored))\n    total_allowed = sum((s.allowed for s in rules if not s.ignored))\n    error_msg = ''\n    if self.status == ExitCode.error:\n        diff = sum((\n            d\n            for s in rules\n            for d in (s.found - s.allowed,)\n            if d &gt; 0 and not s.ignored\n        ))\n        error_msg = f'{diff} extra errors were introduced'\n    elif self.status == ExitCode.needs_readjustment:\n        diff = total_allowed - total_found\n        error_msg = f'{diff} errors were removed - lower error allowance'\n\n    self.total_found = total_found  # noqa: WPS601\n    self.total_allowed = total_allowed  # noqa: WPS601\n    self.error_msg = error_msg  # noqa: WPS601\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.RuleInfo","title":"<code>RuleInfo</code>  <code>dataclass</code>","text":"<p>Stats on a rule.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>@dataclass\nclass RuleInfo:\n    \"\"\"Stats on a rule.\"\"\"\n\n    rule_id: str\n    violations: List[Violation]\n    found: int\n    allowed: int = 0\n    ignored: bool = False\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.Violation","title":"<code>Violation</code>  <code>dataclass</code>","text":"<p>An error/warning/message provided by a compiler or linter.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>@dataclass\nclass Violation:\n    \"\"\"An error/warning/message provided by a compiler or linter.\"\"\"\n\n    rule_id: str\n    message: str\n    line: int\n    column: int\n    file_path: str\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/","title":"post_processors","text":""},{"location":"api/m/ci/celt/post_processors/eslint/","title":"eslint","text":""},{"location":"api/m/ci/celt/post_processors/eslint/#m.ci.celt.post_processors.eslint.read_payload","title":"<code>read_payload(payload)</code>","text":"<p>Transform an eslint payload to a list of <code>FileReport</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The raw payload from eslint.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, List[FileReport]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of <code>FileReport</code> instances.</p> Source code in <code>m/ci/celt/post_processors/eslint.py</code> <pre><code>def read_payload(payload: str) -&gt; OneOf[Issue, List[FileReport]]:\n    \"\"\"Transform an eslint payload to a list of `FileReport` instances.\n\n    Args:\n        payload: The raw payload from eslint.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of `FileReport` instances.\n    \"\"\"\n    return one_of(lambda: [\n        [\n            FileReport(\n                file_path=error['filePath'],\n                violations=[\n                    Violation(\n                        msg['ruleId'],\n                        msg['message'],\n                        msg['line'],\n                        msg['column'],\n                        error['filePath'],\n                    )\n                    for msg in error['messages']\n                ],\n            )\n            for error in json_payload\n        ]\n        for json_payload in json.parse_json(payload)\n    ])\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/pycodestyle/","title":"pycodestyle","text":""},{"location":"api/m/ci/celt/post_processors/pycodestyle/#m.ci.celt.post_processors.pycodestyle.read_payload","title":"<code>read_payload(payload)</code>","text":"<p>Transform a pycodestyle payload to a list of <code>FileReport</code> instances.</p> <p>This function can be used with flake8 and other tools that emit similar output.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The raw payload from pycodestyle.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, List[FileReport]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of <code>FileReport</code> instances.</p> Source code in <code>m/ci/celt/post_processors/pycodestyle.py</code> <pre><code>def read_payload(payload: str) -&gt; OneOf[Issue, List[FileReport]]:\n    \"\"\"Transform a pycodestyle payload to a list of `FileReport` instances.\n\n    This function can be used with flake8 and other tools that emit similar\n    output.\n\n    Args:\n        payload: The raw payload from pycodestyle.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of `FileReport` instances.\n    \"\"\"\n    regex = r'(.*):(\\d+):(\\d+): (\\w+) (.*)'\n    report: Dict[str, List[Violation]] = {}\n    for line in payload.splitlines():\n        match = re.match(regex, line)\n        if match:\n            group = match.groups()\n            violation = Violation(\n                file_path=group[0],\n                line=int(group[1]),\n                column=int(group[2]),\n                rule_id=group[3],\n                message=group[4],\n            )\n            if violation.file_path not in report:\n                report[violation.file_path] = []\n            report[violation.file_path].append(violation)\n    return Good([\n        FileReport(file_path=name, violations=violations)\n        for name, violations in report.items()\n    ])\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/pylint/","title":"pylint","text":""},{"location":"api/m/ci/celt/post_processors/pylint/#m.ci.celt.post_processors.pylint.read_payload","title":"<code>read_payload(payload)</code>","text":"<p>Transform a pylint payload to a list of <code>FileReport</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The raw payload from pylint.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, List[FileReport]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of <code>FileReport</code> instances.</p> Source code in <code>m/ci/celt/post_processors/pylint.py</code> <pre><code>def read_payload(payload: str) -&gt; OneOf[Issue, List[FileReport]]:\n    \"\"\"Transform a pylint payload to a list of `FileReport` instances.\n\n    Args:\n        payload: The raw payload from pylint.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of `FileReport` instances.\n    \"\"\"\n    res = json.parse_json(payload)\n    if res.is_bad:\n        return res\n    violations = cast(List[Any], res.value)\n    report: Dict[str, List[Violation]] = {}\n    for v_item in violations:\n        violation = Violation(\n            rule_id=v_item['symbol'],\n            message=v_item['message'],\n            line=int(v_item['line']),\n            column=int(v_item['column']),\n            file_path=v_item['path'],\n        )\n        if violation.file_path not in report:\n            report[violation.file_path] = []\n        report[violation.file_path].append(violation)\n    return Good([\n        FileReport(file_path=name, violations=violations)\n        for name, violations in report.items()\n    ])\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/ruff/","title":"ruff","text":""},{"location":"api/m/ci/celt/post_processors/ruff/#m.ci.celt.post_processors.ruff.Location","title":"<code>Location</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A location in a file.</p> <p>Attributes:</p> Name Type Description <code>row</code> <code>int</code> <p>...</p> <code>column</code> <code>int</code> <p>...</p> Source code in <code>m/ci/celt/post_processors/ruff.py</code> <pre><code>class Location(BaseModel):\n    \"\"\"A location in a file.\"\"\"\n\n    row: int\n    column: int\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/ruff/#m.ci.celt.post_processors.ruff.RuffViolation","title":"<code>RuffViolation</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A violation from ruff.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str</code> <p>...</p> <code>filename</code> <code>str</code> <p>...</p> <code>location</code> <code>Location</code> <p>...</p> <code>message</code> <code>str</code> <p>...</p> Source code in <code>m/ci/celt/post_processors/ruff.py</code> <pre><code>class RuffViolation(BaseModel):\n    \"\"\"A violation from ruff.\"\"\"\n\n    code: str\n    filename: str\n    location: Location\n    message: str\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/ruff/#m.ci.celt.post_processors.ruff.read_payload","title":"<code>read_payload(payload)</code>","text":"<p>Transform a pylint payload to a list of <code>FileReport</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The raw payload from pylint.</p> required <p>Returns:</p> Type Description <code>Res[list[FileReport]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of <code>FileReport</code> instances.</p> Source code in <code>m/ci/celt/post_processors/ruff.py</code> <pre><code>def read_payload(payload: str) -&gt; Res[list[FileReport]]:\n    \"\"\"Transform a pylint payload to a list of `FileReport` instances.\n\n    Args:\n        payload: The raw payload from pylint.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of `FileReport` instances.\n    \"\"\"\n    context = {'suggestion': 'run ruff check --format json'}\n    return one_of(lambda: [\n        [\n            FileReport(file_path=name, violations=violations)\n            for name, violations in report.items()\n        ]\n        for json_payload in json.parse_json(payload)\n        for violations in parse_model(list[RuffViolation], json_payload)\n        for report in _index_violations(violations)\n    ]).flat_map_bad(hone('invalid_ruff_output_payload', context))\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/typescript/","title":"typescript","text":""},{"location":"api/m/ci/celt/post_processors/typescript/#m.ci.celt.post_processors.typescript.read_payload","title":"<code>read_payload(payload)</code>","text":"<p>Transform a typescript payload to a list of <code>FileReport</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The raw payload from typescript when <code>--pretty false</code> option.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, list[FileReport]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of <code>FileReport</code> instances.</p> Source code in <code>m/ci/celt/post_processors/typescript.py</code> <pre><code>def read_payload(payload: str) -&gt; OneOf[Issue, list[FileReport]]:\n    \"\"\"Transform a typescript payload to a list of `FileReport` instances.\n\n    Args:\n        payload: The raw payload from typescript when `--pretty false` option.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of `FileReport` instances.\n    \"\"\"\n    regex = r'(.*)\\((\\d+),(\\d+)\\): error (\\w+): (.*)'\n    report: dict[str, list[Violation]] = {}\n    for line in payload.splitlines():\n        if line.startswith(' '):\n            continue\n        match = re.match(regex, line)\n        if match:\n            group = match.groups()\n            violation = Violation(\n                file_path=group[0],\n                line=int(group[1]),\n                column=int(group[2]),\n                rule_id=group[3],\n                message=group[4],\n            )\n            if violation.file_path not in report:\n                report[violation.file_path] = []\n            report[violation.file_path].append(violation)\n    return Good([\n        FileReport(file_path=name, violations=violations)\n        for name, violations in report.items()\n    ])\n</code></pre>"},{"location":"api/m/ci/docker/","title":"docker","text":""},{"location":"api/m/ci/docker/config/","title":"config","text":""},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig","title":"<code>DockerConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Contains information about the docker images to build.</p> <p>Attributes:</p> Name Type Description <code>global_env</code> <code>dict[str, str] | None</code> <p>...</p> <code>default_runner</code> <code>str</code> <p>...</p> <code>architectures</code> <code>dict[str, str | list[str]] | None</code> <p>...</p> <code>platforms</code> <code>dict[str, str] | None</code> <p>...</p> <code>container</code> <code>dict[str, Any] | None</code> <p>...</p> <code>base_path</code> <code>str</code> <p>...</p> <code>docker_registry</code> <code>str</code> <p>...</p> <code>extra_build_steps</code> <code>list[dict[str, Any]] | None</code> <p>...</p> <code>workflow_inputs</code> <code>dict[str, GithubWorkflowInput] | None</code> <p>...</p> <code>max_parallel_manifests</code> <code>int | None</code> <p>...</p> <code>images</code> <code>list[DockerImage]</code> <p>...</p> <code>use_buildx</code> <code>bool</code> <p>...</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>class DockerConfig(BaseModel):\n    \"\"\"Contains information about the docker images to build.\"\"\"\n\n    # additional environment variables to inject globally.\n    global_env: dict[str, str] | None = None\n\n    # default runner to use when creating blueprints and manifests\n    default_runner: str = 'ubuntu-22.04'\n\n    # A map of the architectures to build. It maps say `amd64` to a Github\n    # runner that will build the image for that architecture.\n    #    amd64: Ubuntu 20.04\n    architectures: dict[str, str | list[str]] | None\n\n    # A map of the platforms to build. It maps say `amd64` to a valid buildx\n    # supported platform. Using this allows us to build multi-arch images using\n    # buildx in an environment that may not have the necessary architecture.\n    # For instance: 'amd64: linux/amd64'\n    platforms: dict[str, str] | None = None\n\n    # Freeform object to allow us to specify a container in which to run\n    # the docker commands.\n    # https://docs.github.com/en/actions/using-jobs/running-jobs-in-a-container\n    # Note that this requires the mounting the following volume\n    # - /var/run/docker.sock:/var/run/docker.sock\n    # This may be needed for self-hosted runners that may not have python or pip.\n    container: dict[str, Any] | None = None\n\n    # Base path used to locate docker files. Defaults to `.` (root of project)\n    # but may be changed a specific directory.\n    base_path: str = '.'\n\n    # Name of the docker registry to push the images to. For Github container\n    # registry make sure to also include the github owner. For instance:\n    # ghcr.io/owner\n    docker_registry: str\n\n    # When executing docker build commands we may need to obtain external tokens\n    # via other github actions. These can be injected here. We can see those\n    # steps in the github workflow file before the actual docker shell scripts\n    # are run.\n    extra_build_steps: list[dict[str, Any]] | None = None\n\n    # Additional inputs to the github workflow file.\n    workflow_inputs: dict[str, GithubWorkflowInput] | None = None\n\n    # Maximum number of parallel manifests to build.\n    # https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs#defining-the-maximum-number-of-concurrent-jobs\n    max_parallel_manifests: int | None = None\n\n    # list of images to build\n    images: list[DockerImage]\n\n    # https://docs.docker.com/reference/cli/docker/buildx/imagetools/create/\n    use_buildx: bool = True\n\n    def makefile_targets(self: 'DockerConfig', files: FileNames) -&gt; str:\n        \"\"\"Create the Makefile targets to trigger the local builds.\n\n        Args:\n            files: Instance of FileNames to obtain the names of the scripts.\n\n        Returns:\n            A string with the Makefile targets.\n        \"\"\"\n        m_dir = files.m_dir\n        lines: list[str] = [\n            'define m_env',\n            f'\\t$(eval include {m_dir}/.m/m_env.sh)',\n            f'\\t$(eval $(cut -d= -f1 {m_dir}/.m/m_env.sh))',\n            'endef',\n            '',\n            'm-env:',\n            f'\\tmkdir -p {m_dir}/.m &amp;&amp; m ci env --bashrc &gt; {m_dir}/.m/m_env.sh',\n            '',\n            'm-blueprints: m-env',\n            '\\t$(call m_env)',\n            f'\\tm blueprints --skip-makefile --skip-workflow {m_dir}',\n            f'\\tchmod +x {m_dir}/.m/blueprints/local/*.sh\\n',\n        ]\n        for index, img in enumerate(self.images):\n            name = img.image_name\n            img_file = files.local_file(f'{name}.build.sh')\n            previous_img = (\n                self.images[index - 1].image_name\n                if index &gt; 0\n                else None\n            )\n            dep = f' dev-{previous_img}' if previous_img else ' m-blueprints'\n            lines.append(f'dev-{name}:{dep}')\n            lines.append('\\t$(call m_env)')\n            lines.append(f'\\t{img_file}\\n')\n        return '\\n'.join(lines)\n\n    def update_makefile(self: 'DockerConfig', files: FileNames) -&gt; Res[int]:\n        \"\"\"Update the Makefile with the docker images targets.\n\n        Args:\n            files: Instance of FileNames to obtain the names of the scripts.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        return rw.insert_to_file(\n            files.makefile,\n            '\\n# START: M-DOCKER-IMAGES\\n',\n            self.makefile_targets(files),\n            '\\n# END: M-DOCKER-IMAGES\\n',\n        )\n\n    def update_github_workflow(\n        self: 'DockerConfig',\n        files: FileNames,\n    ) -&gt; Res[int]:\n        \"\"\"Update the github workflow with the docker images targets.\n\n        Args:\n            files: Instance of FileNames to obtain the names of the scripts.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        global_env: dict[str, str] = self.global_env or {}\n        multi_workflow = MultiWorkflow(\n            m_dir=files.m_dir,\n            ci_dir=files.ci_dir,\n            global_env=global_env,\n            default_runner=self.default_runner,\n            architectures=self.architectures or {},\n            platforms=self.platforms,\n            images=self.images,\n            extra_build_steps=self.extra_build_steps,\n            docker_registry=self.docker_registry,\n            extra_inputs=self.workflow_inputs,\n            max_parallel_manifests=self.max_parallel_manifests,\n            container=self.container,\n            use_buildx=self.use_buildx,\n        )\n        single_workflow = SingleWorkflow(\n            m_dir=files.m_dir,\n            ci_dir=files.ci_dir,\n            global_env=global_env,\n            default_runner=self.default_runner,\n            images=self.images,\n            extra_build_steps=self.extra_build_steps,\n            extra_inputs=self.workflow_inputs,\n            docker_registry=self.docker_registry,\n            container=self.container,\n        )\n        workflow = multi_workflow if self.architectures else single_workflow\n        return rw.write_file(files.gh_workflow, str(workflow))\n\n    def write_local_steps(\n        self: 'DockerConfig',\n        files: FileNames,\n        m_env: MEnvDocker,\n    ) -&gt; Res[None]:\n        \"\"\"Write local entry point files.\n\n        Args:\n            files: The FileNames instance with the file names.\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        issues: list[dict] = []\n        for img in self.images:\n            write_res = _write_local_step(files, img, m_env)\n            _append_issue(write_res, issues)\n        if issues:\n            return issue(\n                'write_local_steps_failure',\n                context={'issues': issues},\n            )\n        return Good(None)\n\n    def write_ci_steps(\n        self: 'DockerConfig',\n        files: FileNames,\n        m_env: MEnvDocker,\n    ) -&gt; Res[None]:\n        \"\"\"Write ci entry point files.\n\n        Args:\n            files: The FileNames instance with the file names.\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        issues: list[dict] = []\n        registry = self.docker_registry\n        cache_script = create_cache_script(m_env.cache_from_pr, registry)\n        push_script = (\n            create_push_script(registry)\n            if self.architectures\n            else create_push_script_tags(registry, m_env.m_tag)\n        )\n        script_results = [\n            rw.write_file(f'{files.ci_dir}/_find-cache.sh', cache_script),\n            rw.write_file(f'{files.ci_dir}/_push-image.sh', push_script),\n        ]\n        for script_res in script_results:\n            _append_issue(script_res, issues)\n        for img in self.images:\n            file_name = f'{files.ci_dir}/{img.image_name}.build.sh'\n            write_res = _write_build_script(file_name, img, m_env)\n            _append_issue(write_res, issues)\n            if self.use_buildx:\n                file_name = f'{files.ci_dir}/{img.image_name}.manifest.sh'\n                write_res = _write_manifest_script(file_name, img, m_env)\n                _append_issue(write_res, issues)\n        if issues:\n            return issue(\n                'write_ci_steps_failure',\n                context={'issues': issues},\n            )\n        return Good(None)\n\n    def write_ci_manifest_info(\n        self: 'DockerConfig',\n        files: FileNames,\n        m_env: MEnvDocker,\n    ) -&gt; Res[None]:\n        \"\"\"Write ci entry point files.\n\n        Args:\n            files: The FileNames instance with the file names.\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        if not self.architectures:\n            return Good(None)\n        m_tag = m_env.m_tag\n        if not m_tag and os.environ.get('CI') != 'true':\n            logger.warning('M_TAG not found in non-CI environment. Using 1.1.1')\n            m_tag = '1.1.1'\n        names = [img.image_name for img in self.images]\n        tags = [m_tag, *docker_tags(m_tag)]\n        names_json = json.dumps(names, separators=(',', ':'))\n        tags_json = json.dumps(tags, separators=(',', ':'))\n        files_res = [\n            rw.write_file(f'{files.ci_dir}/_image-names.json', names_json),\n            rw.write_file(f'{files.ci_dir}/_image-tags.json', tags_json),\n        ]\n        issues: list[dict] = []\n        for file_res in files_res:\n            _append_issue(file_res, issues)\n        if issues:\n            return issue(\n                'write_ci_manifest_info_failure',\n                context={'issues': issues},\n            )\n        return Good(None)\n\n    def write_blueprints(\n        self: 'DockerConfig',\n        m_dir: str,\n        m_env: MEnvDocker,\n    ) -&gt; Res[None]:\n        \"\"\"Write entry point files.\n\n        Writes shell files for both local and ci. Updates the Makefile and\n        github workflow file.\n\n        Args:\n            m_dir: The m directory.\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        files = FileNames.create_instance(m_dir)\n        return one_of(lambda: [\n            None\n            for _ in self.write_local_steps(files, m_env)\n            for _ in self.write_ci_steps(files, m_env)\n            for _ in self.write_ci_manifest_info(files, m_env)\n        ])\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.makefile_targets","title":"<code>makefile_targets(files)</code>","text":"<p>Create the Makefile targets to trigger the local builds.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>Instance of FileNames to obtain the names of the scripts.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string with the Makefile targets.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def makefile_targets(self: 'DockerConfig', files: FileNames) -&gt; str:\n    \"\"\"Create the Makefile targets to trigger the local builds.\n\n    Args:\n        files: Instance of FileNames to obtain the names of the scripts.\n\n    Returns:\n        A string with the Makefile targets.\n    \"\"\"\n    m_dir = files.m_dir\n    lines: list[str] = [\n        'define m_env',\n        f'\\t$(eval include {m_dir}/.m/m_env.sh)',\n        f'\\t$(eval $(cut -d= -f1 {m_dir}/.m/m_env.sh))',\n        'endef',\n        '',\n        'm-env:',\n        f'\\tmkdir -p {m_dir}/.m &amp;&amp; m ci env --bashrc &gt; {m_dir}/.m/m_env.sh',\n        '',\n        'm-blueprints: m-env',\n        '\\t$(call m_env)',\n        f'\\tm blueprints --skip-makefile --skip-workflow {m_dir}',\n        f'\\tchmod +x {m_dir}/.m/blueprints/local/*.sh\\n',\n    ]\n    for index, img in enumerate(self.images):\n        name = img.image_name\n        img_file = files.local_file(f'{name}.build.sh')\n        previous_img = (\n            self.images[index - 1].image_name\n            if index &gt; 0\n            else None\n        )\n        dep = f' dev-{previous_img}' if previous_img else ' m-blueprints'\n        lines.append(f'dev-{name}:{dep}')\n        lines.append('\\t$(call m_env)')\n        lines.append(f'\\t{img_file}\\n')\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.update_github_workflow","title":"<code>update_github_workflow(files)</code>","text":"<p>Update the github workflow with the docker images targets.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>Instance of FileNames to obtain the names of the scripts.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def update_github_workflow(\n    self: 'DockerConfig',\n    files: FileNames,\n) -&gt; Res[int]:\n    \"\"\"Update the github workflow with the docker images targets.\n\n    Args:\n        files: Instance of FileNames to obtain the names of the scripts.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    global_env: dict[str, str] = self.global_env or {}\n    multi_workflow = MultiWorkflow(\n        m_dir=files.m_dir,\n        ci_dir=files.ci_dir,\n        global_env=global_env,\n        default_runner=self.default_runner,\n        architectures=self.architectures or {},\n        platforms=self.platforms,\n        images=self.images,\n        extra_build_steps=self.extra_build_steps,\n        docker_registry=self.docker_registry,\n        extra_inputs=self.workflow_inputs,\n        max_parallel_manifests=self.max_parallel_manifests,\n        container=self.container,\n        use_buildx=self.use_buildx,\n    )\n    single_workflow = SingleWorkflow(\n        m_dir=files.m_dir,\n        ci_dir=files.ci_dir,\n        global_env=global_env,\n        default_runner=self.default_runner,\n        images=self.images,\n        extra_build_steps=self.extra_build_steps,\n        extra_inputs=self.workflow_inputs,\n        docker_registry=self.docker_registry,\n        container=self.container,\n    )\n    workflow = multi_workflow if self.architectures else single_workflow\n    return rw.write_file(files.gh_workflow, str(workflow))\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.update_makefile","title":"<code>update_makefile(files)</code>","text":"<p>Update the Makefile with the docker images targets.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>Instance of FileNames to obtain the names of the scripts.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def update_makefile(self: 'DockerConfig', files: FileNames) -&gt; Res[int]:\n    \"\"\"Update the Makefile with the docker images targets.\n\n    Args:\n        files: Instance of FileNames to obtain the names of the scripts.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    return rw.insert_to_file(\n        files.makefile,\n        '\\n# START: M-DOCKER-IMAGES\\n',\n        self.makefile_targets(files),\n        '\\n# END: M-DOCKER-IMAGES\\n',\n    )\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.write_blueprints","title":"<code>write_blueprints(m_dir, m_env)</code>","text":"<p>Write entry point files.</p> <p>Writes shell files for both local and ci. Updates the Makefile and github workflow file.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The m directory.</p> required <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def write_blueprints(\n    self: 'DockerConfig',\n    m_dir: str,\n    m_env: MEnvDocker,\n) -&gt; Res[None]:\n    \"\"\"Write entry point files.\n\n    Writes shell files for both local and ci. Updates the Makefile and\n    github workflow file.\n\n    Args:\n        m_dir: The m directory.\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    files = FileNames.create_instance(m_dir)\n    return one_of(lambda: [\n        None\n        for _ in self.write_local_steps(files, m_env)\n        for _ in self.write_ci_steps(files, m_env)\n        for _ in self.write_ci_manifest_info(files, m_env)\n    ])\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.write_ci_manifest_info","title":"<code>write_ci_manifest_info(files, m_env)</code>","text":"<p>Write ci entry point files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>The FileNames instance with the file names.</p> required <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def write_ci_manifest_info(\n    self: 'DockerConfig',\n    files: FileNames,\n    m_env: MEnvDocker,\n) -&gt; Res[None]:\n    \"\"\"Write ci entry point files.\n\n    Args:\n        files: The FileNames instance with the file names.\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    if not self.architectures:\n        return Good(None)\n    m_tag = m_env.m_tag\n    if not m_tag and os.environ.get('CI') != 'true':\n        logger.warning('M_TAG not found in non-CI environment. Using 1.1.1')\n        m_tag = '1.1.1'\n    names = [img.image_name for img in self.images]\n    tags = [m_tag, *docker_tags(m_tag)]\n    names_json = json.dumps(names, separators=(',', ':'))\n    tags_json = json.dumps(tags, separators=(',', ':'))\n    files_res = [\n        rw.write_file(f'{files.ci_dir}/_image-names.json', names_json),\n        rw.write_file(f'{files.ci_dir}/_image-tags.json', tags_json),\n    ]\n    issues: list[dict] = []\n    for file_res in files_res:\n        _append_issue(file_res, issues)\n    if issues:\n        return issue(\n            'write_ci_manifest_info_failure',\n            context={'issues': issues},\n        )\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.write_ci_steps","title":"<code>write_ci_steps(files, m_env)</code>","text":"<p>Write ci entry point files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>The FileNames instance with the file names.</p> required <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def write_ci_steps(\n    self: 'DockerConfig',\n    files: FileNames,\n    m_env: MEnvDocker,\n) -&gt; Res[None]:\n    \"\"\"Write ci entry point files.\n\n    Args:\n        files: The FileNames instance with the file names.\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    issues: list[dict] = []\n    registry = self.docker_registry\n    cache_script = create_cache_script(m_env.cache_from_pr, registry)\n    push_script = (\n        create_push_script(registry)\n        if self.architectures\n        else create_push_script_tags(registry, m_env.m_tag)\n    )\n    script_results = [\n        rw.write_file(f'{files.ci_dir}/_find-cache.sh', cache_script),\n        rw.write_file(f'{files.ci_dir}/_push-image.sh', push_script),\n    ]\n    for script_res in script_results:\n        _append_issue(script_res, issues)\n    for img in self.images:\n        file_name = f'{files.ci_dir}/{img.image_name}.build.sh'\n        write_res = _write_build_script(file_name, img, m_env)\n        _append_issue(write_res, issues)\n        if self.use_buildx:\n            file_name = f'{files.ci_dir}/{img.image_name}.manifest.sh'\n            write_res = _write_manifest_script(file_name, img, m_env)\n            _append_issue(write_res, issues)\n    if issues:\n        return issue(\n            'write_ci_steps_failure',\n            context={'issues': issues},\n        )\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.write_local_steps","title":"<code>write_local_steps(files, m_env)</code>","text":"<p>Write local entry point files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>The FileNames instance with the file names.</p> required <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def write_local_steps(\n    self: 'DockerConfig',\n    files: FileNames,\n    m_env: MEnvDocker,\n) -&gt; Res[None]:\n    \"\"\"Write local entry point files.\n\n    Args:\n        files: The FileNames instance with the file names.\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    issues: list[dict] = []\n    for img in self.images:\n        write_res = _write_local_step(files, img, m_env)\n        _append_issue(write_res, issues)\n    if issues:\n        return issue(\n            'write_local_steps_failure',\n            context={'issues': issues},\n        )\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/docker/docker_build/","title":"docker_build","text":""},{"location":"api/m/ci/docker/docker_build/#m.ci.docker.docker_build.DockerBuild","title":"<code>DockerBuild</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Representation of a <code>docker build</code> command.</p> <p>See https://docs.docker.com/engine/reference/commandline/build</p> <p>Attributes:</p> Name Type Description <code>add_host</code> <code>list[str] | None</code> <p>...</p> <code>build_arg</code> <code>list[str] | None</code> <p>...</p> <code>cache_from</code> <code>str | None</code> <p>...</p> <code>cgroup_parent</code> <code>str | None</code> <p>...</p> <code>compress</code> <code>bool | None</code> <p>...</p> <code>cpu_period</code> <code>int | None</code> <p>...</p> <code>cpu_quota</code> <code>int | None</code> <p>...</p> <code>cpu_shares</code> <code>int | None</code> <p>...</p> <code>cpuset_cpus</code> <code>str | None</code> <p>...</p> <code>cpuset_mems</code> <code>str | None</code> <p>...</p> <code>disable_content_trust</code> <code>bool | None</code> <p>...</p> <code>file</code> <code>str | None</code> <p>...</p> <code>force_rm</code> <code>bool | None</code> <p>...</p> <code>iidfile</code> <code>str | None</code> <p>...</p> <code>isolation</code> <code>str | None</code> <p>...</p> <code>label</code> <code>list[str] | None</code> <p>...</p> <code>memory</code> <code>str | None</code> <p>...</p> <code>memory_swap</code> <code>str | None</code> <p>...</p> <code>network</code> <code>str | None</code> <p>...</p> <code>no_cache</code> <code>bool | None</code> <p>...</p> <code>pull</code> <code>bool | None</code> <p>...</p> <code>quiet</code> <code>bool | None</code> <p>...</p> <code>rm</code> <code>bool | None</code> <p>...</p> <code>security_opt</code> <code>str | None</code> <p>...</p> <code>secret</code> <code>list[str] | None</code> <p>...</p> <code>progress</code> <code>str | None</code> <p>...</p> <code>shm_size</code> <code>str | None</code> <p>...</p> <code>tag</code> <code>list[str] | None</code> <p>...</p> <code>target</code> <code>str | None</code> <p>...</p> <code>ulimit</code> <code>str | None</code> <p>...</p> Source code in <code>m/ci/docker/docker_build.py</code> <pre><code>class DockerBuild(BaseModel):\n    \"\"\"Representation of a `docker build` command.\n\n    See https://docs.docker.com/engine/reference/commandline/build\n    \"\"\"\n\n    # Add a custom host-to-IP mapping (host:ip)\n    add_host: list[str] | None = None\n\n    # Set build-time variables\n    build_arg: list[str] | None = None\n\n    # Images to consider as cache sources\n    cache_from: str | None = None\n\n    # Optional parent cgroup for the container\n    cgroup_parent: str | None = None\n\n    # Compress the build context using gzip\n    compress: bool | None = None\n\n    # Limit the CPU CFS (Completely Fair Scheduler) period\n    cpu_period: int | None = None\n\n    # Limit the CPU CFS (Completely Fair Scheduler) quota\n    cpu_quota: int | None = None\n\n    # CPU shares (relative weight)\n    cpu_shares: int | None = None\n\n    # CPUs in which to allow execution (0-3, 0,1)\n    cpuset_cpus: str | None = None\n\n    # MEMs in which to allow execution (0-3, 0,1)\n    cpuset_mems: str | None = None\n\n    # Skip image verification (default true)\n    disable_content_trust: bool | None = None\n\n    # Name of the Dockerfile (Default is 'PATH/Dockerfile')\n    file: str | None = None  # noqa: WPS110 - docker build optional argument\n\n    # Always remove intermediate containers\n    force_rm: bool | None = None\n\n    # Write the image ID to the file\n    iidfile: str | None = None\n\n    # Container isolation technology\n    isolation: str | None = None\n\n    # Set metadata for an image\n    label: list[str] | None = None\n\n    # Memory limit\n    memory: str | None = None\n\n    # Swap limit equal to memory plus swap: '-1' to enable unlimited swap\n    memory_swap: str | None = None\n\n    # Set the networking mode for the RUN instructions during build (default \"default\")\n    network: str | None = None\n\n    # Do not use cache when building the image\n    no_cache: bool | None = None\n\n    # Always attempt to pull a newer version of the image\n    pull: bool | None = None\n\n    # Suppress the build output and print image ID on success\n    quiet: bool | None = None\n\n    # Remove intermediate containers after a successful build (default true)\n    rm: bool | None = None\n\n    # Security options\n    security_opt: str | None = None\n\n    # Available with DOCKER_BUILDKIT=1\n    #   see https://pythonspeed.com/articles/docker-build-secrets\n    # Use as `--secret id=ENVVAR` in the docker build command.\n    # Then in the `RUN` statement in the docker file do `RUN --mount=type=secret,id=ENVVAR`.\n    # Then you may access that value by doing `ENVVAR=$(cat /run/secrets/ENVVAR)`.\n    # Best to use that in a script that that executes inside the docker file.\n    secret: list[str] | None = None\n\n    # Available with DOCKER_BUILDKIT=1\n    progress: str | None = None\n\n    # Size of /dev/shm\n    shm_size: str | None = None\n\n    # Name and optionally a tag in the 'name:tag' format\n    tag: list[str] | None = None\n\n    # Set the target build stage to build\n    target: str | None = None\n\n    # Ulimit options (default [])\n    ulimit: str | None = None\n\n    def __str__(self) -&gt; str:\n        \"\"\"Convert the docker build command to a string.\n\n        Returns:\n            The docker build command.\n        \"\"\"\n        cmd = ShellCommand(\n            prog='docker build',\n            positional=['.'],\n            options=self.model_dump(exclude_none=True),\n        )\n        return str(cmd)\n\n    def buildx_str(self) -&gt; str:\n        \"\"\"Convert the docker build command to a string.\n\n        Returns:\n            The docker build command.\n        \"\"\"\n        cmd = ShellCommand(\n            prog='docker buildx build --platform \"$PLATFORM\"',\n            positional=['.'],\n            options=self.model_dump(exclude_none=True),\n        )\n        return str(cmd)\n</code></pre>"},{"location":"api/m/ci/docker/docker_build/#m.ci.docker.docker_build.DockerBuild.__str__","title":"<code>__str__()</code>","text":"<p>Convert the docker build command to a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The docker build command.</p> Source code in <code>m/ci/docker/docker_build.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Convert the docker build command to a string.\n\n    Returns:\n        The docker build command.\n    \"\"\"\n    cmd = ShellCommand(\n        prog='docker build',\n        positional=['.'],\n        options=self.model_dump(exclude_none=True),\n    )\n    return str(cmd)\n</code></pre>"},{"location":"api/m/ci/docker/docker_build/#m.ci.docker.docker_build.DockerBuild.buildx_str","title":"<code>buildx_str()</code>","text":"<p>Convert the docker build command to a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The docker build command.</p> Source code in <code>m/ci/docker/docker_build.py</code> <pre><code>def buildx_str(self) -&gt; str:\n    \"\"\"Convert the docker build command to a string.\n\n    Returns:\n        The docker build command.\n    \"\"\"\n    cmd = ShellCommand(\n        prog='docker buildx build --platform \"$PLATFORM\"',\n        positional=['.'],\n        options=self.model_dump(exclude_none=True),\n    )\n    return str(cmd)\n</code></pre>"},{"location":"api/m/ci/docker/env/","title":"env","text":""},{"location":"api/m/ci/docker/env/#m.ci.docker.env.MEnvDocker","title":"<code>MEnvDocker</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Values from <code>MEnv</code> needed by docker.</p> <p>Attributes:</p> Name Type Description <code>m_tag</code> <code>str</code> <p>...</p> <code>cache_from_pr</code> <code>str</code> <p>...</p> <code>base_path</code> <code>str</code> <p>...</p> <code>registry</code> <code>str</code> <p>...</p> <code>multi_arch</code> <code>bool</code> <p>...</p> <code>architectures</code> <code>list[str]</code> <p>...</p> <code>use_buildx</code> <code>bool</code> <p>...</p> Source code in <code>m/ci/docker/env.py</code> <pre><code>class MEnvDocker(BaseModel):\n    \"\"\"Values from `MEnv` needed by docker.\"\"\"\n\n    # The m tag to build the images.\n    m_tag: str\n\n    # The pull request number to attempt to use as cache.\n    cache_from_pr: str\n\n    # base path to locate docker file.\n    base_path: str\n\n    # docker registry\n    registry: str\n\n    # Flag to indicate if multi-arch is enabled.\n    multi_arch: bool\n\n    # The list of all the architectures if multi-arch is enabled.\n    architectures: list[str]\n\n    # Flag to indicate if buildx should be used.\n    use_buildx: bool = False\n</code></pre>"},{"location":"api/m/ci/docker/filenames/","title":"filenames","text":""},{"location":"api/m/ci/docker/filenames/#m.ci.docker.filenames.FileNames","title":"<code>FileNames</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Name of files that need to be written.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <code>str</code> <p>...</p> <code>local_dir</code> <code>str</code> <p>...</p> <code>ci_dir</code> <code>str</code> <p>...</p> <code>manifests_dir</code> <code>str</code> <p>...</p> <code>makefile</code> <code>str</code> <p>...</p> <code>gh_workflow</code> <code>str</code> <p>...</p> Source code in <code>m/ci/docker/filenames.py</code> <pre><code>class FileNames(BaseModel):\n    \"\"\"Name of files that need to be written.\"\"\"\n\n    m_dir: str\n    local_dir: str\n    ci_dir: str\n    manifests_dir: str\n    makefile: str\n    gh_workflow: str\n\n    @classmethod\n    def create_instance(cls: type['FileNames'], m_dir: str) -&gt; 'FileNames':\n        \"\"\"Create and instance of FileNames.\n\n        Args:\n            m_dir: The m directory.\n\n        Returns:\n            An instance of FileNames.\n        \"\"\"\n        gh_dir = Path(f'{m_dir}/../.github/workflows')\n        gh_dir.mkdir(parents=True, exist_ok=True)\n        return FileNames(\n            m_dir=m_dir,\n            local_dir=f'{m_dir}/.m/blueprints/local',\n            ci_dir=f'{m_dir}/.m/blueprints/ci',\n            manifests_dir=f'{m_dir}/.m/blueprints/ci/manifests',\n            makefile=f'{m_dir}/../Makefile',\n            gh_workflow=f'{m_dir}/../.github/workflows/m.yaml',\n        )\n\n    def local_file(self: 'FileNames', filename: str) -&gt; str:\n        \"\"\"Generate the name of a local script.\n\n        Args:\n            filename: The name of the file.\n\n        Returns:\n            The full name of the file.\n        \"\"\"\n        return f'{self.local_dir}/{filename}'\n</code></pre>"},{"location":"api/m/ci/docker/filenames/#m.ci.docker.filenames.FileNames.create_instance","title":"<code>create_instance(m_dir)</code>  <code>classmethod</code>","text":"<p>Create and instance of FileNames.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The m directory.</p> required <p>Returns:</p> Type Description <code>FileNames</code> <p>An instance of FileNames.</p> Source code in <code>m/ci/docker/filenames.py</code> <pre><code>@classmethod\ndef create_instance(cls: type['FileNames'], m_dir: str) -&gt; 'FileNames':\n    \"\"\"Create and instance of FileNames.\n\n    Args:\n        m_dir: The m directory.\n\n    Returns:\n        An instance of FileNames.\n    \"\"\"\n    gh_dir = Path(f'{m_dir}/../.github/workflows')\n    gh_dir.mkdir(parents=True, exist_ok=True)\n    return FileNames(\n        m_dir=m_dir,\n        local_dir=f'{m_dir}/.m/blueprints/local',\n        ci_dir=f'{m_dir}/.m/blueprints/ci',\n        manifests_dir=f'{m_dir}/.m/blueprints/ci/manifests',\n        makefile=f'{m_dir}/../Makefile',\n        gh_workflow=f'{m_dir}/../.github/workflows/m.yaml',\n    )\n</code></pre>"},{"location":"api/m/ci/docker/filenames/#m.ci.docker.filenames.FileNames.local_file","title":"<code>local_file(filename)</code>","text":"<p>Generate the name of a local script.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The full name of the file.</p> Source code in <code>m/ci/docker/filenames.py</code> <pre><code>def local_file(self: 'FileNames', filename: str) -&gt; str:\n    \"\"\"Generate the name of a local script.\n\n    Args:\n        filename: The name of the file.\n\n    Returns:\n        The full name of the file.\n    \"\"\"\n    return f'{self.local_dir}/{filename}'\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/","title":"gh_workflow_multi","text":""},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.TemplateVars","title":"<code>TemplateVars</code>","text":"<p>             Bases: <code>TemplateVars</code></p> <p>Template variables.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <p>...</p> <code>ci_dir</code> <p>...</p> <code>default_runner</code> <p>...</p> <code>container</code> <p>...</p> <code>global_env</code> <p>...</p> <code>docker_login</code> <p>...</p> <code>build_steps</code> <p>...</p> <code>extra_inputs</code> <p>...</p> <code>build_architectures</code> <code>str</code> <p>...</p> <code>create_manifest</code> <code>str</code> <p>...</p> <code>push_manifest</code> <code>str</code> <p>...</p> <code>manifest_strategy_options</code> <code>str</code> <p>...</p> <code>buildx_setup</code> <code>str</code> <p>...</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>class TemplateVars(DefaultTemplateVars):\n    \"\"\"Template variables.\"\"\"\n\n    build_architectures: str\n\n    create_manifest: str\n\n    push_manifest: str\n\n    manifest_strategy_options: str\n\n    buildx_setup: str\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow","title":"<code>Workflow</code>","text":"<p>             Bases: <code>Workflow</code></p> <p>Helper class to write the <code>m</code> workflow.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <p>...</p> <code>ci_dir</code> <p>...</p> <code>global_env</code> <p>...</p> <code>default_runner</code> <p>...</p> <code>docker_registry</code> <p>...</p> <code>extra_build_steps</code> <p>...</p> <code>extra_inputs</code> <p>...</p> <code>container</code> <p>...</p> <code>images</code> <p>...</p> <code>architectures</code> <code>dict[str, str | list[str]]</code> <p>...</p> <code>max_parallel_manifests</code> <code>int | None</code> <p>...</p> <code>use_buildx</code> <code>bool</code> <p>...</p> <code>platforms</code> <code>dict[str, str] | None</code> <p>...</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>class Workflow(DefaultWorkflow):\n    \"\"\"Helper class to write the `m` workflow.\"\"\"\n\n    architectures: dict[str, str | list[str]]\n\n    max_parallel_manifests: int | None\n\n    use_buildx: bool = False\n\n    platforms: dict[str, str] | None\n\n    def build_architectures(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a github action str with the build architectures.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        arch_strs = '\\n'.join([\n            f'- arch: {arch}\\n  os: {os}{platform}'\n            for arch, os in self.architectures.items()\n            for platform in (self._add_platform(arch),)\n        ])\n        return _indent(f'\\n{arch_strs}', 5)\n\n    def buildx_setup_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a github action str to setup buildx.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        if not self.platforms:\n            return ''\n        platforms = ','.join(self.platforms.values())\n        setup_obj = f\"\"\"\n            - name: buildx-setup\n              uses: docker/setup-buildx-action@v3\n              with:\n                platforms: {platforms}\"\"\"\n        return _indent(dedent(setup_obj), 3)\n\n    def create_manifest_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate the script to create the manifest.\n\n        Returns:\n            The manifest create script.\n        \"\"\"\n        cmd = 'docker manifest create'\n        registry = self.docker_registry\n        image = '${{ matrix.image-name }}'\n        tag = '${{ matrix.image-tag }}'\n        m_tag = '${{ inputs.m-tag }}'\n        lines = [f'{cmd} {registry}/{image}:{tag}']\n        for arch in self.architectures:\n            lines.append(f'  {registry}/{arch}-{image}:{m_tag}')\n        # wants it be a raw string but i need a new line after `\\`\n        full_cmd = ' \\\\\\n'.join(lines)   # noqa: WPS342\n        return _indent(f'|-\\n{full_cmd}', 5)\n\n    def push_manifest_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate the script to run to push the manifest.\n\n        Returns:\n            The command to push.\n        \"\"\"\n        cmd = 'docker manifest push'\n        registry = self.docker_registry\n        image = '${{ matrix.image-name }}'\n        tag = '${{ matrix.image-tag }}'\n        full_cmd = f'|-\\n{cmd} {registry}/{image}:{tag}'\n        return _indent(full_cmd, 5)\n\n    def manifest_strategy_options_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate the strategy options for the manifest job.\n\n        Returns:\n            The strategy options.\n        \"\"\"\n        options = ''\n        if self.max_parallel_manifests:\n            options = f'\\n      max-parallel: {self.max_parallel_manifests}'\n        return options\n\n    def container_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a string specifying a container to run on.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        if not self.container:\n            lines = [\n                '',\n                '    env:',\n                '      ARCH: ${{ matrix.arch }}',\n            ]\n            if self.platforms:\n                lines.append('      PLATFORM: ${{ matrix.platform }}')\n            return '\\n'.join(lines)\n        lines = ['\\n    container:']\n        content_str = _indent(yaml.dumps(self.container), 3)\n        lines.append(f'      {content_str}')\n        return '\\n'.join(lines).rstrip()\n\n    def __str__(self: 'Workflow') -&gt; str:\n        \"\"\"Stringify the workflow file.\n\n        Returns:\n            The github workflow.\n        \"\"\"\n        template_vars = TemplateVars(\n            m_dir=self.m_dir,\n            default_runner=self.default_runner,\n            global_env=self.global_env_str(),\n            extra_inputs=self.extra_inputs_str(),\n            ci_dir=self.ci_dir,\n            build_architectures=self.build_architectures(),\n            docker_login=self.docker_login_str(),\n            buildx_setup=self.buildx_setup_str(),\n            build_steps=self.build_steps_str(),\n            create_manifest=self.create_manifest_str(),\n            push_manifest=self.push_manifest_str(),\n            manifest_strategy_options=self.manifest_strategy_options_str(),\n            container=self.container_str(),\n        )\n        template = TEMPLATE_BUILDX if self.use_buildx else TEMPLATE\n        return template.format(**template_vars.model_dump())\n\n    def _add_platform(self: 'Workflow', arch: str) -&gt; str:\n        if not self.platforms:\n            return ''\n        platform = self.platforms[arch]\n        return f'\\n  platform: {platform}'\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.__str__","title":"<code>__str__()</code>","text":"<p>Stringify the workflow file.</p> <p>Returns:</p> Type Description <code>str</code> <p>The github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def __str__(self: 'Workflow') -&gt; str:\n    \"\"\"Stringify the workflow file.\n\n    Returns:\n        The github workflow.\n    \"\"\"\n    template_vars = TemplateVars(\n        m_dir=self.m_dir,\n        default_runner=self.default_runner,\n        global_env=self.global_env_str(),\n        extra_inputs=self.extra_inputs_str(),\n        ci_dir=self.ci_dir,\n        build_architectures=self.build_architectures(),\n        docker_login=self.docker_login_str(),\n        buildx_setup=self.buildx_setup_str(),\n        build_steps=self.build_steps_str(),\n        create_manifest=self.create_manifest_str(),\n        push_manifest=self.push_manifest_str(),\n        manifest_strategy_options=self.manifest_strategy_options_str(),\n        container=self.container_str(),\n    )\n    template = TEMPLATE_BUILDX if self.use_buildx else TEMPLATE\n    return template.format(**template_vars.model_dump())\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.build_architectures","title":"<code>build_architectures()</code>","text":"<p>Generate a github action str with the build architectures.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def build_architectures(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a github action str with the build architectures.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    arch_strs = '\\n'.join([\n        f'- arch: {arch}\\n  os: {os}{platform}'\n        for arch, os in self.architectures.items()\n        for platform in (self._add_platform(arch),)\n    ])\n    return _indent(f'\\n{arch_strs}', 5)\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.buildx_setup_str","title":"<code>buildx_setup_str()</code>","text":"<p>Generate a github action str to setup buildx.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def buildx_setup_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a github action str to setup buildx.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    if not self.platforms:\n        return ''\n    platforms = ','.join(self.platforms.values())\n    setup_obj = f\"\"\"\n        - name: buildx-setup\n          uses: docker/setup-buildx-action@v3\n          with:\n            platforms: {platforms}\"\"\"\n    return _indent(dedent(setup_obj), 3)\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.container_str","title":"<code>container_str()</code>","text":"<p>Generate a string specifying a container to run on.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def container_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a string specifying a container to run on.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    if not self.container:\n        lines = [\n            '',\n            '    env:',\n            '      ARCH: ${{ matrix.arch }}',\n        ]\n        if self.platforms:\n            lines.append('      PLATFORM: ${{ matrix.platform }}')\n        return '\\n'.join(lines)\n    lines = ['\\n    container:']\n    content_str = _indent(yaml.dumps(self.container), 3)\n    lines.append(f'      {content_str}')\n    return '\\n'.join(lines).rstrip()\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.create_manifest_str","title":"<code>create_manifest_str()</code>","text":"<p>Generate the script to create the manifest.</p> <p>Returns:</p> Type Description <code>str</code> <p>The manifest create script.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def create_manifest_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate the script to create the manifest.\n\n    Returns:\n        The manifest create script.\n    \"\"\"\n    cmd = 'docker manifest create'\n    registry = self.docker_registry\n    image = '${{ matrix.image-name }}'\n    tag = '${{ matrix.image-tag }}'\n    m_tag = '${{ inputs.m-tag }}'\n    lines = [f'{cmd} {registry}/{image}:{tag}']\n    for arch in self.architectures:\n        lines.append(f'  {registry}/{arch}-{image}:{m_tag}')\n    # wants it be a raw string but i need a new line after `\\`\n    full_cmd = ' \\\\\\n'.join(lines)   # noqa: WPS342\n    return _indent(f'|-\\n{full_cmd}', 5)\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.manifest_strategy_options_str","title":"<code>manifest_strategy_options_str()</code>","text":"<p>Generate the strategy options for the manifest job.</p> <p>Returns:</p> Type Description <code>str</code> <p>The strategy options.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def manifest_strategy_options_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate the strategy options for the manifest job.\n\n    Returns:\n        The strategy options.\n    \"\"\"\n    options = ''\n    if self.max_parallel_manifests:\n        options = f'\\n      max-parallel: {self.max_parallel_manifests}'\n    return options\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.push_manifest_str","title":"<code>push_manifest_str()</code>","text":"<p>Generate the script to run to push the manifest.</p> <p>Returns:</p> Type Description <code>str</code> <p>The command to push.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def push_manifest_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate the script to run to push the manifest.\n\n    Returns:\n        The command to push.\n    \"\"\"\n    cmd = 'docker manifest push'\n    registry = self.docker_registry\n    image = '${{ matrix.image-name }}'\n    tag = '${{ matrix.image-tag }}'\n    full_cmd = f'|-\\n{cmd} {registry}/{image}:{tag}'\n    return _indent(full_cmd, 5)\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/","title":"gh_workflow_single","text":""},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.TemplateVars","title":"<code>TemplateVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Template variables.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <code>str</code> <p>...</p> <code>ci_dir</code> <code>str</code> <p>...</p> <code>default_runner</code> <code>str</code> <p>...</p> <code>container</code> <code>str</code> <p>...</p> <code>global_env</code> <code>str</code> <p>...</p> <code>docker_login</code> <code>str</code> <p>...</p> <code>build_steps</code> <code>str</code> <p>...</p> <code>extra_inputs</code> <code>str</code> <p>...</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>class TemplateVars(BaseModel):\n    \"\"\"Template variables.\"\"\"\n\n    m_dir: str\n\n    ci_dir: str\n\n    default_runner: str\n\n    container: str\n\n    global_env: str\n\n    docker_login: str\n\n    build_steps: str\n\n    extra_inputs: str\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow","title":"<code>Workflow</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Helper class to write the <code>m</code> workflow.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <code>str</code> <p>...</p> <code>ci_dir</code> <code>str</code> <p>...</p> <code>global_env</code> <code>dict[str, str] | None</code> <p>...</p> <code>default_runner</code> <code>str</code> <p>...</p> <code>docker_registry</code> <code>str</code> <p>...</p> <code>extra_build_steps</code> <code>list[dict[str, Any]] | None</code> <p>...</p> <code>extra_inputs</code> <code>dict[str, GithubWorkflowInput] | None</code> <p>...</p> <code>container</code> <code>dict[str, Any] | None</code> <p>...</p> <code>images</code> <code>list[DockerImage]</code> <p>...</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>class Workflow(BaseModel):\n    \"\"\"Helper class to write the `m` workflow.\"\"\"\n\n    m_dir: str\n\n    ci_dir: str\n\n    global_env: dict[str, str] | None\n\n    default_runner: str\n\n    docker_registry: str\n\n    extra_build_steps: list[dict[str, Any]] | None\n\n    extra_inputs: dict[str, GithubWorkflowInput] | None\n\n    container: dict[str, Any] | None\n\n    images: list[DockerImage]\n\n    def docker_login_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a github action str to login to docker.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        login_obj = \"\"\"\\\n            name: docker-login\n            uses: docker/login-action@v3\n            with:\n              registry: ghcr.io\n              username: ${{ github.actor }}\n              password: ${{ secrets.GITHUB_TOKEN }}\"\"\"\n        return _indent(dedent(login_obj), 4)\n\n    def global_env_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a github action str with the global environment variables.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        all_vars = {\n            'GITHUB_TOKEN': '${{ secrets.GITHUB_TOKEN }}',\n            'M_TAG': '${{ inputs.m-tag }}',\n            'M_CACHE_FROM_PR': '${{ inputs.cache-from-pr }}',\n            **(self.global_env or {}),\n        }\n        vars_str = '\\n'.join([\n            f'  {env_var}: {env_val}'\n            for env_var, env_val in all_vars.items()\n        ])\n        return f'\\n{vars_str}'\n\n    def extra_inputs_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a github action str with the extra inputs.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        if not self.extra_inputs:\n            return ''\n        lines: list[str] = []\n        extras = {\n            key: input_inst.model_dump()\n            for key, input_inst in self.extra_inputs.items()\n        }\n        inputs_str = _indent(yaml.dumps(extras), 3)\n        lines.append(f'\\n      {inputs_str}')\n        return '\\n'.join(lines).rstrip()\n\n    def container_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a string specifying a container to run on.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        if not self.container:\n            return '\\n'.join([\n                '',\n                '    env:',\n                '      ARCH: ${{ matrix.arch }}',\n            ])\n        lines: list[str] = ['\\n    container:']\n        content_str = _indent(yaml.dumps(self.container), 3)\n        lines.append(f'      {content_str}')\n        return '\\n'.join(lines).rstrip()\n\n    def build_steps_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a github action str for the build steps.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        lines: list[str] = []\n        for step in self.extra_build_steps or []:\n            step_str = _indent(yaml.dumps(step)[:-1], 1)\n            lines.append(f'- {step_str}')\n        for img in self.images:\n            cache_sh = f'{self.ci_dir}/_find-cache.sh'\n            build_sh = f'{self.ci_dir}/{img.image_name}.build.sh'\n            push_sh = f'{self.ci_dir}/_push-image.sh'\n            image_steps = [\n                f'- name: {img.image_name} - cache',\n                f'  run: {cache_sh} {img.image_name}',\n                f'- name: {img.image_name} - build',\n                f'  run: {build_sh}',\n                f'- name: {img.image_name} - push',\n                f'  run: {push_sh} {img.image_name}',\n            ]\n            lines.extend(image_steps)\n        return _indent('\\n'.join(lines), 3)\n\n    def __str__(self: 'Workflow') -&gt; str:\n        \"\"\"Stringify the workflow file.\n\n        Returns:\n            The github workflow.\n        \"\"\"\n        template_vars = TemplateVars(\n            m_dir=self.m_dir,\n            default_runner=self.default_runner,\n            global_env=self.global_env_str(),\n            ci_dir=self.ci_dir,\n            docker_login=self.docker_login_str(),\n            build_steps=self.build_steps_str(),\n            extra_inputs=self.extra_inputs_str(),\n            container=self.container_str(),\n        )\n        return TEMPLATE.format(**template_vars.model_dump())\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow.__str__","title":"<code>__str__()</code>","text":"<p>Stringify the workflow file.</p> <p>Returns:</p> Type Description <code>str</code> <p>The github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>def __str__(self: 'Workflow') -&gt; str:\n    \"\"\"Stringify the workflow file.\n\n    Returns:\n        The github workflow.\n    \"\"\"\n    template_vars = TemplateVars(\n        m_dir=self.m_dir,\n        default_runner=self.default_runner,\n        global_env=self.global_env_str(),\n        ci_dir=self.ci_dir,\n        docker_login=self.docker_login_str(),\n        build_steps=self.build_steps_str(),\n        extra_inputs=self.extra_inputs_str(),\n        container=self.container_str(),\n    )\n    return TEMPLATE.format(**template_vars.model_dump())\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow.build_steps_str","title":"<code>build_steps_str()</code>","text":"<p>Generate a github action str for the build steps.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>def build_steps_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a github action str for the build steps.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    lines: list[str] = []\n    for step in self.extra_build_steps or []:\n        step_str = _indent(yaml.dumps(step)[:-1], 1)\n        lines.append(f'- {step_str}')\n    for img in self.images:\n        cache_sh = f'{self.ci_dir}/_find-cache.sh'\n        build_sh = f'{self.ci_dir}/{img.image_name}.build.sh'\n        push_sh = f'{self.ci_dir}/_push-image.sh'\n        image_steps = [\n            f'- name: {img.image_name} - cache',\n            f'  run: {cache_sh} {img.image_name}',\n            f'- name: {img.image_name} - build',\n            f'  run: {build_sh}',\n            f'- name: {img.image_name} - push',\n            f'  run: {push_sh} {img.image_name}',\n        ]\n        lines.extend(image_steps)\n    return _indent('\\n'.join(lines), 3)\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow.container_str","title":"<code>container_str()</code>","text":"<p>Generate a string specifying a container to run on.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>def container_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a string specifying a container to run on.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    if not self.container:\n        return '\\n'.join([\n            '',\n            '    env:',\n            '      ARCH: ${{ matrix.arch }}',\n        ])\n    lines: list[str] = ['\\n    container:']\n    content_str = _indent(yaml.dumps(self.container), 3)\n    lines.append(f'      {content_str}')\n    return '\\n'.join(lines).rstrip()\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow.docker_login_str","title":"<code>docker_login_str()</code>","text":"<p>Generate a github action str to login to docker.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>def docker_login_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a github action str to login to docker.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    login_obj = \"\"\"\\\n        name: docker-login\n        uses: docker/login-action@v3\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\"\"\"\n    return _indent(dedent(login_obj), 4)\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow.extra_inputs_str","title":"<code>extra_inputs_str()</code>","text":"<p>Generate a github action str with the extra inputs.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>def extra_inputs_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a github action str with the extra inputs.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    if not self.extra_inputs:\n        return ''\n    lines: list[str] = []\n    extras = {\n        key: input_inst.model_dump()\n        for key, input_inst in self.extra_inputs.items()\n    }\n    inputs_str = _indent(yaml.dumps(extras), 3)\n    lines.append(f'\\n      {inputs_str}')\n    return '\\n'.join(lines).rstrip()\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow.global_env_str","title":"<code>global_env_str()</code>","text":"<p>Generate a github action str with the global environment variables.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>def global_env_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a github action str with the global environment variables.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    all_vars = {\n        'GITHUB_TOKEN': '${{ secrets.GITHUB_TOKEN }}',\n        'M_TAG': '${{ inputs.m-tag }}',\n        'M_CACHE_FROM_PR': '${{ inputs.cache-from-pr }}',\n        **(self.global_env or {}),\n    }\n    vars_str = '\\n'.join([\n        f'  {env_var}: {env_val}'\n        for env_var, env_val in all_vars.items()\n    ])\n    return f'\\n{vars_str}'\n</code></pre>"},{"location":"api/m/ci/docker/image/","title":"image","text":""},{"location":"api/m/ci/docker/image/#m.ci.docker.image.DockerImage","title":"<code>DockerImage</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Information describing how to a docker image.</p> <p>Attributes:</p> Name Type Description <code>step_name</code> <code>str</code> <p>...</p> <code>image_name</code> <code>str</code> <p>...</p> <code>docker_file</code> <code>str</code> <p>...</p> <code>target_stage</code> <code>str | None</code> <p>...</p> <code>build_args</code> <code>dict[str, str]</code> <p>...</p> <code>env_secrets</code> <code>list[str] | None</code> <p>...</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>class DockerImage(BaseModel):\n    \"\"\"Information describing how to a docker image.\"\"\"\n\n    # String used to describe the step in the workflow.\n    step_name: str\n\n    # The name of the image - usually prefixed with the name of the repo.\n    image_name: str\n\n    # Name of the docker file to use for the build step.\n    docker_file: str\n\n    # Name of a target stage to build. Leave empty to build the whole file.\n    target_stage: str | None = None\n\n    # Arguments to pass to the docker build command, they will only be injected\n    # if they appear within the docker file.\n    build_args: dict[str, str] = {}\n\n    # name of envvars to be treated as secrets.\n    env_secrets: list[str] | None = None\n\n    def format_build_args(\n        self: 'DockerImage',\n        m_env: MEnvDocker,\n        arch: str,\n        extras: dict[str, str] | None = None,\n    ) -&gt; Res[list[str]]:\n        \"\"\"Format the arguments to pass to the docker build command.\n\n        Docker will only inject build args if they appear in the docker file.\n\n        Args:\n            m_env: The MEnvDocker instance with the environment variables.\n            arch: The architecture to build for.\n            extras: Extra build arguments.\n\n        Returns:\n            A list with the build arguments.\n        \"\"\"\n        docker_file = f'{m_env.base_path}/{self.docker_file}'\n        docker_file_res = read_file(docker_file)\n        if isinstance(docker_file_res, Bad):\n            return Bad(docker_file_res.value)\n        docker_file_contents = docker_file_res.value\n        all_args = {\n            'M_TAG': m_env.m_tag,\n            **(extras or {}),\n            **self.build_args,\n        }\n        # Only add the arch if multi-arch is enabled.\n        if m_env.multi_arch:\n            all_args['ARCH'] = arch\n        return Good([\n            f'{key}={arg_value}'\n            for key, arg_value in all_args.items()\n            if f'ARG {key}' in docker_file_contents\n        ])\n\n    def format_env_secrets(self: 'DockerImage') -&gt; list[str] | None:\n        \"\"\"Format the environment secrets to pass to the docker build command.\n\n        Returns:\n            A list of valid `secret` arguments.\n        \"\"\"\n        env_sec = self.env_secrets or []\n        return [f'id={env}' for env in env_sec] if env_sec else None\n\n    def ci_build(self: 'DockerImage', m_env: MEnvDocker) -&gt; Res[str]:\n        \"\"\"Generate a shell script to build an image in the CI pipelines.\n\n        Args:\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            A shell snippet with a docker build command.\n        \"\"\"\n        build_args = self.format_build_args(m_env, '\"$ARCH\"')\n        if isinstance(build_args, Bad):\n            return Bad(build_args.value)\n        build_args.value.append('BUILDKIT_INLINE_CACHE=1')\n\n        docker_file = f'{m_env.base_path}/{self.docker_file}'\n        img_name = f'{m_env.registry}/{self.image_name}'\n        build_cmd = DockerBuild(\n            progress='plain',\n            cache_from='staged-image:cache',\n            secret=self.format_env_secrets(),\n            tag=[\n                'staged-image:latest',\n                f'{img_name}:{m_env.m_tag}',\n            ],\n            build_arg=build_args.value,\n            target=self.target_stage,\n            file=docker_file,\n        )\n        build_cmd_str = (\n            build_cmd.buildx_str()\n            if m_env.use_buildx\n            else str(build_cmd)\n        )\n        script = [\n            BASH_SHEBANG,\n            'export DOCKER_BUILDKIT=1',\n            SET_STRICT_BASH,\n            '',\n            build_cmd_str,\n            '',\n        ]\n        return Good('\\n'.join(script))\n\n    def ci_manifest(self: 'DockerImage', m_env: MEnvDocker) -&gt; Res[str]:\n        \"\"\"Generate a shell script to handle multi-arch manifests.\n\n        Args:\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            A shell snippet with a docker buildx command.\n        \"\"\"\n        m_tag = m_env.m_tag\n        if not m_tag and os.environ.get('CI') != 'true':\n            logger.warning('M_TAG not found in non-CI environment. Using 1.1.1')\n            m_tag = '1.1.1'\n        registry = m_env.registry\n        tags = [m_tag, *docker_tags(m_tag)]\n        img_name = f'{registry}/{self.image_name}'\n        all_tags = [\n            f'  -t {img_name}:{tag} \\\\'\n            for tag in tags\n        ]\n        all_archs_str = ' \\\\\\n'.join([\n            f'  {registry}/{arch}-{self.image_name}:{m_tag}'\n            for arch in m_env.architectures\n        ])\n        script = [\n            BASH_SHEBANG,\n            SET_STRICT_BASH,\n            '',\n            'docker buildx imagetools create \\\\',\n            *all_tags,\n            all_archs_str,\n            '',\n        ]\n        return Good('\\n'.join(script))\n\n    def local_build(self: 'DockerImage', m_env: MEnvDocker) -&gt; Res[str]:\n        \"\"\"Generate a shell script to build an image.\n\n        Args:\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            A shell snippet with a docker build command.\n        \"\"\"\n        arch = get_arch()\n        build_args = self.format_build_args(m_env, arch)\n        if isinstance(build_args, Bad):\n            return Bad(build_args.value)\n\n        docker_file = f'{m_env.base_path}/{self.docker_file}'\n        img_name = f'{m_env.registry}/{self.image_name}'\n        build_cmd = DockerBuild(\n            progress='plain',\n            secret=self.format_env_secrets(),\n            tag=[\n                'staged-image:latest',\n                f'{img_name}:{m_env.m_tag}',\n            ],\n            build_arg=build_args.value,\n            target=self.target_stage,\n            file=docker_file,\n        )\n        script = [\n            BASH_SHEBANG,\n            'export DOCKER_BUILDKIT=1',\n            SET_STRICT_BASH,\n            '',\n            str(build_cmd),\n            '',\n        ]\n        return Good('\\n'.join(script))\n</code></pre>"},{"location":"api/m/ci/docker/image/#m.ci.docker.image.DockerImage.ci_build","title":"<code>ci_build(m_env)</code>","text":"<p>Generate a shell script to build an image in the CI pipelines.</p> <p>Parameters:</p> Name Type Description Default <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A shell snippet with a docker build command.</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>def ci_build(self: 'DockerImage', m_env: MEnvDocker) -&gt; Res[str]:\n    \"\"\"Generate a shell script to build an image in the CI pipelines.\n\n    Args:\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        A shell snippet with a docker build command.\n    \"\"\"\n    build_args = self.format_build_args(m_env, '\"$ARCH\"')\n    if isinstance(build_args, Bad):\n        return Bad(build_args.value)\n    build_args.value.append('BUILDKIT_INLINE_CACHE=1')\n\n    docker_file = f'{m_env.base_path}/{self.docker_file}'\n    img_name = f'{m_env.registry}/{self.image_name}'\n    build_cmd = DockerBuild(\n        progress='plain',\n        cache_from='staged-image:cache',\n        secret=self.format_env_secrets(),\n        tag=[\n            'staged-image:latest',\n            f'{img_name}:{m_env.m_tag}',\n        ],\n        build_arg=build_args.value,\n        target=self.target_stage,\n        file=docker_file,\n    )\n    build_cmd_str = (\n        build_cmd.buildx_str()\n        if m_env.use_buildx\n        else str(build_cmd)\n    )\n    script = [\n        BASH_SHEBANG,\n        'export DOCKER_BUILDKIT=1',\n        SET_STRICT_BASH,\n        '',\n        build_cmd_str,\n        '',\n    ]\n    return Good('\\n'.join(script))\n</code></pre>"},{"location":"api/m/ci/docker/image/#m.ci.docker.image.DockerImage.ci_manifest","title":"<code>ci_manifest(m_env)</code>","text":"<p>Generate a shell script to handle multi-arch manifests.</p> <p>Parameters:</p> Name Type Description Default <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A shell snippet with a docker buildx command.</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>def ci_manifest(self: 'DockerImage', m_env: MEnvDocker) -&gt; Res[str]:\n    \"\"\"Generate a shell script to handle multi-arch manifests.\n\n    Args:\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        A shell snippet with a docker buildx command.\n    \"\"\"\n    m_tag = m_env.m_tag\n    if not m_tag and os.environ.get('CI') != 'true':\n        logger.warning('M_TAG not found in non-CI environment. Using 1.1.1')\n        m_tag = '1.1.1'\n    registry = m_env.registry\n    tags = [m_tag, *docker_tags(m_tag)]\n    img_name = f'{registry}/{self.image_name}'\n    all_tags = [\n        f'  -t {img_name}:{tag} \\\\'\n        for tag in tags\n    ]\n    all_archs_str = ' \\\\\\n'.join([\n        f'  {registry}/{arch}-{self.image_name}:{m_tag}'\n        for arch in m_env.architectures\n    ])\n    script = [\n        BASH_SHEBANG,\n        SET_STRICT_BASH,\n        '',\n        'docker buildx imagetools create \\\\',\n        *all_tags,\n        all_archs_str,\n        '',\n    ]\n    return Good('\\n'.join(script))\n</code></pre>"},{"location":"api/m/ci/docker/image/#m.ci.docker.image.DockerImage.format_build_args","title":"<code>format_build_args(m_env, arch, extras=None)</code>","text":"<p>Format the arguments to pass to the docker build command.</p> <p>Docker will only inject build args if they appear in the docker file.</p> <p>Parameters:</p> Name Type Description Default <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <code>arch</code> <code>str</code> <p>The architecture to build for.</p> required <code>extras</code> <code>dict[str, str] | None</code> <p>Extra build arguments.</p> <code>None</code> <p>Returns:</p> Type Description <code>Res[list[str]]</code> <p>A list with the build arguments.</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>def format_build_args(\n    self: 'DockerImage',\n    m_env: MEnvDocker,\n    arch: str,\n    extras: dict[str, str] | None = None,\n) -&gt; Res[list[str]]:\n    \"\"\"Format the arguments to pass to the docker build command.\n\n    Docker will only inject build args if they appear in the docker file.\n\n    Args:\n        m_env: The MEnvDocker instance with the environment variables.\n        arch: The architecture to build for.\n        extras: Extra build arguments.\n\n    Returns:\n        A list with the build arguments.\n    \"\"\"\n    docker_file = f'{m_env.base_path}/{self.docker_file}'\n    docker_file_res = read_file(docker_file)\n    if isinstance(docker_file_res, Bad):\n        return Bad(docker_file_res.value)\n    docker_file_contents = docker_file_res.value\n    all_args = {\n        'M_TAG': m_env.m_tag,\n        **(extras or {}),\n        **self.build_args,\n    }\n    # Only add the arch if multi-arch is enabled.\n    if m_env.multi_arch:\n        all_args['ARCH'] = arch\n    return Good([\n        f'{key}={arg_value}'\n        for key, arg_value in all_args.items()\n        if f'ARG {key}' in docker_file_contents\n    ])\n</code></pre>"},{"location":"api/m/ci/docker/image/#m.ci.docker.image.DockerImage.format_env_secrets","title":"<code>format_env_secrets()</code>","text":"<p>Format the environment secrets to pass to the docker build command.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>A list of valid <code>secret</code> arguments.</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>def format_env_secrets(self: 'DockerImage') -&gt; list[str] | None:\n    \"\"\"Format the environment secrets to pass to the docker build command.\n\n    Returns:\n        A list of valid `secret` arguments.\n    \"\"\"\n    env_sec = self.env_secrets or []\n    return [f'id={env}' for env in env_sec] if env_sec else None\n</code></pre>"},{"location":"api/m/ci/docker/image/#m.ci.docker.image.DockerImage.local_build","title":"<code>local_build(m_env)</code>","text":"<p>Generate a shell script to build an image.</p> <p>Parameters:</p> Name Type Description Default <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A shell snippet with a docker build command.</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>def local_build(self: 'DockerImage', m_env: MEnvDocker) -&gt; Res[str]:\n    \"\"\"Generate a shell script to build an image.\n\n    Args:\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        A shell snippet with a docker build command.\n    \"\"\"\n    arch = get_arch()\n    build_args = self.format_build_args(m_env, arch)\n    if isinstance(build_args, Bad):\n        return Bad(build_args.value)\n\n    docker_file = f'{m_env.base_path}/{self.docker_file}'\n    img_name = f'{m_env.registry}/{self.image_name}'\n    build_cmd = DockerBuild(\n        progress='plain',\n        secret=self.format_env_secrets(),\n        tag=[\n            'staged-image:latest',\n            f'{img_name}:{m_env.m_tag}',\n        ],\n        build_arg=build_args.value,\n        target=self.target_stage,\n        file=docker_file,\n    )\n    script = [\n        BASH_SHEBANG,\n        'export DOCKER_BUILDKIT=1',\n        SET_STRICT_BASH,\n        '',\n        str(build_cmd),\n        '',\n    ]\n    return Good('\\n'.join(script))\n</code></pre>"},{"location":"api/m/ci/docker/image/#m.ci.docker.image.get_arch","title":"<code>get_arch()</code>","text":"<p>Get the architecture of the current machine.</p> <p>Returns:</p> Type Description <code>str</code> <p>The architecture of the current machine.</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>def get_arch() -&gt; str:\n    \"\"\"Get the architecture of the current machine.\n\n    Returns:\n        The architecture of the current machine.\n    \"\"\"\n    mapping = {\n        # amd\n        'i386': AMD64,\n        'x86_64': AMD64,\n        # arm\n        'aarch64': ARM64,\n    }\n    arch = platform.machine()\n    return mapping.get(arch, arch)\n</code></pre>"},{"location":"api/m/ci/docker/shell_command/","title":"shell_command","text":""},{"location":"api/m/ci/docker/shell_command/#m.ci.docker.shell_command.ShellCommand","title":"<code>ShellCommand</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Representation of a shell command.</p> <p>Attributes:</p> Name Type Description <code>prog</code> <code>str</code> <p>...</p> <code>options</code> <code>dict[str, str | list[str] | bool]</code> <p>...</p> <code>positional</code> <code>list[str]</code> <p>...</p> Source code in <code>m/ci/docker/shell_command.py</code> <pre><code>class ShellCommand(BaseModel):\n    \"\"\"Representation of a shell command.\"\"\"\n\n    # Name of the program to run. May contain spaces if the program is a subcommand.\n    prog: str\n\n    # Arguments to pass to the program.\n    # If the key starts with `--` it will be passed as is. Otherwise it will be\n    # considered as a python property and will be passed as `--key`.\n    options: dict[str, str | list[str] | bool] = {}\n\n    # Positional arguments to pass to the program.\n    positional: list[str] = []\n\n    def __str__(self) -&gt; str:\n        \"\"\"Render the command as a string.\n\n        A new line is not added to the end of the string in case the command\n        needs to be piped to another command.\n\n        Returns:\n            A string representation of the command.\n        \"\"\"\n        lines = [self.prog, *_to_list(self.options), *self.positional]\n        # We need to join with a backslash and a new line.\n        return' \\\\\\n  '.join(lines)  # noqa: WPS342\n</code></pre>"},{"location":"api/m/ci/docker/shell_command/#m.ci.docker.shell_command.ShellCommand.__str__","title":"<code>__str__()</code>","text":"<p>Render the command as a string.</p> <p>A new line is not added to the end of the string in case the command needs to be piped to another command.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the command.</p> Source code in <code>m/ci/docker/shell_command.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Render the command as a string.\n\n    A new line is not added to the end of the string in case the command\n    needs to be piped to another command.\n\n    Returns:\n        A string representation of the command.\n    \"\"\"\n    lines = [self.prog, *_to_list(self.options), *self.positional]\n    # We need to join with a backslash and a new line.\n    return' \\\\\\n  '.join(lines)  # noqa: WPS342\n</code></pre>"},{"location":"api/m/ci/docker/shell_scripts/","title":"shell_scripts","text":""},{"location":"api/m/ci/docker/shell_scripts/#m.ci.docker.shell_scripts.create_cache_script","title":"<code>create_cache_script(pr_num, docker_registry)</code>","text":"<p>Create a script to retrieve cache for an image.</p> <p>Parameters:</p> Name Type Description Default <code>pr_num</code> <code>str</code> <p>The pull request number where to pull the cache from.</p> required <code>docker_registry</code> <code>str</code> <p>The docker registry where the images are located.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A script to find the cache.</p> Source code in <code>m/ci/docker/shell_scripts.py</code> <pre><code>def create_cache_script(pr_num: str, docker_registry: str) -&gt; str:\n    \"\"\"Create a script to retrieve cache for an image.\n\n    Args:\n        pr_num: The pull request number where to pull the cache from.\n        docker_registry: The docker registry where the images are located.\n\n    Returns:\n        A script to find the cache.\n    \"\"\"\n    pulls = ['pullCache \"$1\" master', 'echo \"NO CACHE FOUND\"']\n    if pr_num:\n        pulls.insert(0, f'pullCache \"$1\" \"pr{pr_num}\"')\n    find_cache_implementation = ' || '.join(pulls)\n    replacements = {\n        'docker_registry': docker_registry,\n        'find_cache_implementation': find_cache_implementation,\n    }\n    return FIND_CACHE_SCRIPT.format(**replacements)\n</code></pre>"},{"location":"api/m/ci/docker/shell_scripts/#m.ci.docker.shell_scripts.create_push_script","title":"<code>create_push_script(docker_registry)</code>","text":"<p>Create a script to push an image.</p> <p>Parameters:</p> Name Type Description Default <code>docker_registry</code> <code>str</code> <p>The docker registry where the images will be pushed.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A script to push an image.</p> Source code in <code>m/ci/docker/shell_scripts.py</code> <pre><code>def create_push_script(docker_registry: str) -&gt; str:\n    \"\"\"Create a script to push an image.\n\n    Args:\n        docker_registry: The docker registry where the images will be pushed.\n\n    Returns:\n        A script to push an image.\n    \"\"\"\n    return PUSH_SCRIPT.format(docker_registry=docker_registry)\n</code></pre>"},{"location":"api/m/ci/docker/shell_scripts/#m.ci.docker.shell_scripts.create_push_script_tags","title":"<code>create_push_script_tags(docker_registry, m_tag)</code>","text":"<p>Create a script to push an image.</p> <p>This is meant to be used when building for a single architecture.</p> <p>Parameters:</p> Name Type Description Default <code>docker_registry</code> <code>str</code> <p>The docker registry where the images will be pushed.</p> required <code>m_tag</code> <code>str</code> <p>The unique tag for the image.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A script to push an image.</p> Source code in <code>m/ci/docker/shell_scripts.py</code> <pre><code>def create_push_script_tags(docker_registry: str, m_tag: str) -&gt; str:\n    \"\"\"Create a script to push an image.\n\n    This is meant to be used when building for a single architecture.\n\n    Args:\n        docker_registry: The docker registry where the images will be pushed.\n        m_tag: The unique tag for the image.\n\n    Returns:\n        A script to push an image.\n    \"\"\"\n    if not m_tag and os.environ.get('CI') != 'true':\n        logger.warning('M_TAG not found in non-CI environment. Using 1.1.1')\n        m_tag = '1.1.1'\n    tags = [m_tag, *docker_tags(m_tag)]\n    tagged_images = '\\n'.join([\n        f'docker tag staged-image:latest \"{docker_registry}/$imageName:{tag}\"'\n        for tag in tags\n    ])\n    return PUSH_SCRIPT_TAGS.format(\n        docker_registry=docker_registry,\n        tag_images=tagged_images,\n    )\n</code></pre>"},{"location":"api/m/ci/docker/tags/","title":"tags","text":""},{"location":"api/m/ci/docker/tags/#m.ci.docker.tags.docker_tags","title":"<code>docker_tags(m_tag, *, skip_floating=False)</code>","text":"<p>Convert an m_tag to docker tags.</p> <p>Floating tags include <code>latest</code> and any <code>vX</code> or <code>vX.Y</code> tags. The <code>skip_floating</code> argument is intended for use when building packages that have already been published in the past.</p> <p>Parameters:</p> Name Type Description Default <code>m_tag</code> <code>str</code> <p>A tag/version provided by m.</p> required <code>skip_floating</code> <code>bool</code> <p>If true, do not include floating tags.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A tag that can be used by docker during the publishing step.</p> Source code in <code>m/ci/docker/tags.py</code> <pre><code>def docker_tags(m_tag: str, *, skip_floating: bool = False) -&gt; list[str]:\n    \"\"\"Convert an m_tag to docker tags.\n\n    Floating tags include `latest` and any `vX` or `vX.Y` tags.\n    The `skip_floating` argument is intended for use when building packages\n    that have already been published in the past.\n\n    Args:\n        m_tag: A tag/version provided by m.\n        skip_floating: If true, do not include floating tags.\n\n    Returns:\n        A tag that can be used by docker during the publishing step.\n    \"\"\"\n    tags = []\n    regex = r'\\d+.\\d+.\\d+-(.*)\\.(.*)'\n    matches = re.match(regex, m_tag)\n    if matches:\n        tag, _ = matches.groups()\n        if tag.startswith('rc') or tag.startswith('hotfix'):\n            tags.append('next')\n            index = 2 if tag.startswith('rc') else 6\n            pr_num = tag[index:]\n            tags.append(f'pr{pr_num}')\n        else:\n            tags.append(tag)\n    else:\n        x, y, _ = m_tag.split('.')\n        if not skip_floating:\n            tags.append('latest')\n            tags.append(f'v{x}')\n            tags.append(f'v{x}.{y}')\n\n    return tags\n</code></pre>"},{"location":"api/m/ci/docker/workflow_input/","title":"workflow_input","text":""},{"location":"api/m/ci/docker/workflow_input/#m.ci.docker.workflow_input.GithubWorkflowInput","title":"<code>GithubWorkflowInput</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Declare extra workflow inputs.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>...</p> <code>description</code> <code>str</code> <p>...</p> <code>required</code> <code>bool</code> <p>...</p> Source code in <code>m/ci/docker/workflow_input.py</code> <pre><code>class GithubWorkflowInput(BaseModel):\n    \"\"\"Declare extra workflow inputs.\"\"\"\n\n    type: str = 'string'\n    description: str\n    required: bool = True\n</code></pre>"},{"location":"api/m/cli/","title":"cli","text":""},{"location":"api/m/cli/#m.cli.CliCommands","title":"<code>CliCommands</code>  <code>dataclass</code>","text":"<p>Container to store the commands and subcommands for the cli.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CliCommands:\n    \"\"\"Container to store the commands and subcommands for the cli.\"\"\"\n\n    commands: dict[str, CommandModule | CliSubcommands]\n\n    # Optional root meta data to provide information about the cli.\n    meta: MetaModule | None\n</code></pre>"},{"location":"api/m/cli/#m.cli.CommandModule","title":"<code>CommandModule</code>  <code>dataclass</code>","text":"<p>Container to store the run function from a \"command\" module.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CommandModule:\n    \"\"\"Container to store the run function from a \"command\" module.\"\"\"\n\n    run: DecoratedRunFunction\n</code></pre>"},{"location":"api/m/cli/#m.cli.FuncArgs","title":"<code>FuncArgs</code>  <code>dataclass</code>","text":"<p>Stores function arguments.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass FuncArgs:\n    \"\"\"Stores function arguments.\"\"\"\n\n    args: list[Any]\n    kwargs: dict[str, Any]\n</code></pre>"},{"location":"api/m/cli/#m.cli.MetaModule","title":"<code>MetaModule</code>  <code>dataclass</code>","text":"<p>Container to store a metadata dictionary from a \"meta\" module.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass MetaModule:\n    \"\"\"Container to store a metadata dictionary from a \"meta\" module.\"\"\"\n\n    meta: dict[str, str]\n    add_arguments: Callable[[ap.ArgumentParser], None] | None = None\n</code></pre>"},{"location":"api/m/cli/#m.cli.Arg","title":"<code>Arg(default=PydanticUndefined, *, help, positional=None, required=None, aliases=None, nargs=None, validator=None)</code>","text":"<p>Create a pydantic <code>Field</code>.</p> <p>Field docs: https://docs.pydantic.dev/2.2/usage/fields</p> <p>Defines properties used to create an argparse argument. This function should work for most cases. If we need something that is not covered we can use <code>ArgProxy</code> instead which is untyped but provides all the arguments and keyword arguments to argparse.</p> <p>See https://docs.python.org/3/library/argparse.html.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any</code> <p>Default value if the field is not set.</p> <code>PydanticUndefined</code> <code>help</code> <code>str</code> <p>Human-readable description.</p> required <code>positional</code> <code>bool | None</code> <p>Whether the argument is positional or not.</p> <code>None</code> <code>required</code> <code>bool | None</code> <p>Indicate whether an argument is required or optional.</p> <code>None</code> <code>aliases</code> <code>list[str] | None</code> <p>Alternative names for the argument.</p> <code>None</code> <code>nargs</code> <code>int | Literal['?', '*', '+'] | None</code> <p>Number of times the argument can be used.</p> <code>None</code> <code>validator</code> <code>Callable[[str], str] | None</code> <p>Function to validate the argument.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>. The return annotation is <code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def Arg(  # noqa: N802, WPS211\n    default: Any = PydanticUndefined,\n    *,\n    help: str,  # noqa: WPS125\n    positional: bool | None = None,\n    required: bool | None = None,\n    aliases: list[str] | None = None,\n    nargs: int | Literal['?', '*', '+'] | None = None,\n    validator: Callable[[str], str] | None = None,\n) -&gt; Any:\n    \"\"\"Create a pydantic `Field`.\n\n    Field docs: https://docs.pydantic.dev/2.2/usage/fields\n\n    Defines properties used to create an argparse argument. This function\n    should work for most cases. If we need something that is not covered\n    we can use `ArgProxy` instead which is untyped but provides all the arguments\n    and keyword arguments to argparse.\n\n    See https://docs.python.org/3/library/argparse.html.\n\n    Args:\n        default: Default value if the field is not set.\n        help: Human-readable description.\n        positional: Whether the argument is positional or not.\n        required: Indicate whether an argument is required or optional.\n        aliases: Alternative names for the argument.\n        nargs: Number of times the argument can be used.\n        validator: Function to validate the argument.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is\n            `Any` so `Arg` can be used on type annotated fields without causing\n            a typing error.\n    \"\"\"\n    extras = {\n        'positional': positional,\n        'validator': validator,\n        'aliases': aliases,\n        'nargs': nargs,\n        'required': required,\n    }\n    return FieldInfo.from_field(\n        default,\n        description=cleandoc(help),\n        json_schema_extra={k: v for k, v in extras.items() if v is not None},\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.ArgProxy","title":"<code>ArgProxy(*args, **kwargs)</code>","text":"<p>Wrap function to provide all argparse inputs.</p> <p>This is a escape hatch and does not provide any typings. See https://docs.python.org/3/library/argparse.html.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The arguments to argparse add_arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to argparse add arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>. The return annotation is <code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def ArgProxy(*args: Any, **kwargs: Any) -&gt; Any:  # noqa: N802\n    \"\"\"Wrap function to provide all argparse inputs.\n\n    This is a escape hatch and does not provide any typings.\n    See https://docs.python.org/3/library/argparse.html.\n\n    Args:\n        args: The arguments to argparse add_arguments.\n        kwargs: The keyword arguments to argparse add arguments.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is\n            `Any` so `Arg` can be used on type annotated fields without causing\n            a typing error.\n    \"\"\"\n    return FieldInfo.from_field(\n        json_schema_extra={\n            'proxy': FuncArgs(args=list(args), kwargs=kwargs),\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.Meta","title":"<code>Meta(*, help, description)</code>","text":"<p>Create the meta dictionary for a subcommand description.</p> <p>In the case of the root command the <code>help</code> may be set to empty since it is not used.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>The help message for the subcommand.</p> required <code>description</code> <code>str</code> <p>The description for the command/subcommand.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary with the help and description.</p> Source code in <code>m/cli/args.py</code> <pre><code>def Meta(  # noqa: N802\n    *,\n    help: str,  # noqa: WPS125\n    description: str,\n) -&gt; dict[str, str]:\n    \"\"\"Create the meta dictionary for a subcommand description.\n\n    In the case of the root command the `help` may be set to empty since it\n    is not used.\n\n    Args:\n        help: The help message for the subcommand.\n        description: The description for the command/subcommand.\n\n    Returns:\n        A dictionary with the help and description.\n    \"\"\"\n    return {\n        'help': help,\n        'description': cleandoc(description),\n    }\n</code></pre>"},{"location":"api/m/cli/#m.cli.RemainderArgs","title":"<code>RemainderArgs(*, help=_Unset)</code>","text":"<p>Provide a list of unrecognized arguments.</p> <p>This is a escape hatch and does not provide any typings. May be useful for commands that need to pass arguments to other commands.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str | None</code> <p>Human-readable description.</p> <code>_Unset</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>, the return annotation is</p> <code>Any</code> <p><code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def RemainderArgs(  # noqa: N802\n    *,\n    help: str | None = _Unset,  # noqa: WPS125\n) -&gt; Any:\n    \"\"\"Provide a list of unrecognized arguments.\n\n    This is a escape hatch and does not provide any typings. May be\n    useful for commands that need to pass arguments to other commands.\n\n    Args:\n        help: Human-readable description.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo], the return annotation is\n        `Any` so `Arg` can be used on type annotated fields without causing a typing error.\n    \"\"\"\n    return FieldInfo.from_field(\n        [],\n        description=help,\n        json_schema_extra={'__remainder_args': True},\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.add_arg","title":"<code>add_arg(*args, **kwargs)</code>","text":"<p>Wrap FuncArgs arguments in a function.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The arguments to argparse add_arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to argparse add arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FuncArgs</code> <p>A FuncArgs instance.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `add_arg` method is deprecated; use `m.cli.ArgProxy` instead.',\n)\ndef add_arg(*args: Any, **kwargs: Any) -&gt; FuncArgs:\n    \"\"\"Wrap FuncArgs arguments in a function.\n\n    Args:\n        args: The arguments to argparse add_arguments.\n        kwargs: The keyword arguments to argparse add arguments.\n\n    Returns:\n        A FuncArgs instance.\n    \"\"\"\n    # `m` does not reference this function anymore, excluding from coverage\n    return FuncArgs(args=list(args), kwargs=kwargs)  # pragma: no cover\n</code></pre>"},{"location":"api/m/cli/#m.cli.cli_commands","title":"<code>cli_commands(root_meta=None, **commands)</code>","text":"<p>Create a CliCommands instance.</p> <p>Parameters:</p> Name Type Description Default <code>root_meta</code> <code>MetaModule | None</code> <p>The meta for the root command.</p> <code>None</code> <code>commands</code> <code>DecoratedRunFunction | CliSubcommands</code> <p>The commands and subcommands for the cli.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliCommands</code> <p>An instance of CliCommands.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def cli_commands(\n    root_meta: MetaModule | None = None,\n    **commands: DecoratedRunFunction | CliSubcommands,\n) -&gt; CliCommands:\n    \"\"\"Create a CliCommands instance.\n\n    Args:\n        root_meta: The meta for the root command.\n        commands: The commands and subcommands for the cli.\n\n    Returns:\n        An instance of CliCommands.\n    \"\"\"\n    root_meta = root_meta or default_root_meta\n    return CliCommands(\n        meta=root_meta,\n        commands={\n            cmd_name: (\n                cmd_item\n                if isinstance(cmd_item, CliSubcommands)\n                else CommandModule(run=cmd_item)\n            )\n            for cmd_name, cmd_item in commands.items()\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.cli_integration_token","title":"<code>cli_integration_token(integration, env_var)</code>","text":"<p>Return a function that takes in a parser.</p> <p>This generated function registers a token argument in the parser which looks for its value in the environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>integration</code> <code>str</code> <p>The name of the integration.</p> required <code>env_var</code> <code>str</code> <p>The environment variable name.</p> required <p>Returns:</p> Type Description <code>cli_global_option</code> <p>A function to add arguments to an argparse parser.</p> Source code in <code>m/cli/cli.py</code> <pre><code>def cli_integration_token(\n    integration: str,\n    env_var: str,\n) -&gt; cli_global_option:\n    \"\"\"Return a function that takes in a parser.\n\n    This generated function registers a token argument in the parser\n    which looks for its value in the environment variables.\n\n    Args:\n        integration: The name of the integration.\n        env_var: The environment variable name.\n\n    Returns:\n        A function to add arguments to an argparse parser.\n    \"\"\"\n    return lambda parser: parser.add_argument(\n        '-t',\n        '--token',\n        type=validate_non_empty_str,\n        default=env(env_var),\n        help=f'{integration} access token (default: env.{env_var})',\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.command","title":"<code>command(*, help, model, name=None)</code>","text":"<p>Apply a decorator to the <code>run</code> function to make it into a command.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The command name.</p> <code>None</code> <code>help</code> <code>str</code> <p>A short description of the command.</p> required <code>model</code> <code>type[BaseModel]</code> <p>A pydantic model to describe the cli arguments.</p> required <p>Returns:</p> Type Description <code>partial[partial[int]]</code> <p>A transformed run function aware of the arguments model.</p> Source code in <code>m/cli/engine/argparse.py</code> <pre><code>def command(\n    *,\n    help: str,  # noqa: WPS125\n    model: type[BaseModel],\n    name: str | None = None,\n) -&gt; partial[partial[int]]:\n    \"\"\"Apply a decorator to the `run` function to make it into a command.\n\n    Args:\n        name: The command name.\n        help: A short description of the command.\n        model: A pydantic model to describe the cli arguments.\n\n    Returns:\n        A transformed run function aware of the arguments model.\n    \"\"\"\n    # m no longer uses the name argument but we keep it for now\n    if name:  # pragma: no cover\n        warn('`name` is no longer needed, please remove it', DeprecationWarning)\n    return partial(_handle_decorated_func, CommandInputs(help, model))\n</code></pre>"},{"location":"api/m/cli/#m.cli.command_group","title":"<code>command_group(*, help, description, add_arguments=None)</code>","text":"<p>Create an instance of a MetaModule.</p> <p>Named <code>cmd_group</code> since it is used to describe the group of commands.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>quick help describing the module.</p> required <code>description</code> <code>str</code> <p>Detailed description about the module.</p> required <code>add_arguments</code> <code>Callable[[ArgumentParser], None] | None</code> <p>Optional function to handle the argparse instance.</p> <code>None</code> <p>Returns:</p> Type Description <code>MetaModule</code> <p>An instance of a MetaModule.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def command_group(\n    *,\n    help: str,   # noqa: WPS125\n    description: str,\n    add_arguments: Callable[[ap.ArgumentParser], None] | None = None,\n) -&gt; MetaModule:\n    \"\"\"Create an instance of a MetaModule.\n\n    Named `cmd_group` since it is used to describe the group of commands.\n\n    Args:\n        help: quick help describing the module.\n        description: Detailed description about the module.\n        add_arguments: Optional function to handle the argparse instance.\n\n    Returns:\n        An instance of a MetaModule.\n    \"\"\"\n    return MetaModule(\n        meta=Meta(help=help, description=description),\n        add_arguments=add_arguments,\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.create_issue_handler","title":"<code>create_issue_handler(use_warning)</code>","text":"<p>Generate a function to log an issue.</p> <p>Parameters:</p> Name Type Description Default <code>use_warning</code> <code>bool</code> <p>Uses a warning log instead of an error.</p> required <p>Returns:</p> Type Description <code>Callable[[Issue], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_issue_handler(use_warning: bool) -&gt; Callable[[Issue], None]:\n    \"\"\"Generate a function to log an issue.\n\n    Args:\n        use_warning: Uses a warning log instead of an error.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_issue_handler, use_warning)\n</code></pre>"},{"location":"api/m/cli/#m.cli.create_json_handler","title":"<code>create_json_handler(pretty)</code>","text":"<p>Generate a function to display a value to stdout as json.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>If true, it formats with indentation of 2 spaces.</p> required <p>Returns:</p> Type Description <code>Callable[[Any], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_json_handler(pretty: bool) -&gt; Callable[[Any], None]:\n    \"\"\"Generate a function to display a value to stdout as json.\n\n    Args:\n        pretty: If true, it formats with indentation of 2 spaces.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_json_handler, pretty)\n</code></pre>"},{"location":"api/m/cli/#m.cli.create_yaml_handler","title":"<code>create_yaml_handler(pretty)</code>","text":"<p>Generate a function to display a value to stdout as yaml.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>If true, it highlights the output.</p> required <p>Returns:</p> Type Description <code>Callable[[Any], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_yaml_handler(pretty: bool) -&gt; Callable[[Any], None]:\n    \"\"\"Generate a function to display a value to stdout as yaml.\n\n    Args:\n        pretty: If true, it highlights the output.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_yaml_handler, pretty)\n</code></pre>"},{"location":"api/m/cli/#m.cli.env_var","title":"<code>env_var(arg_value)</code>","text":"<p>Read a value from the environment.</p> <p>Parameters:</p> Name Type Description Default <code>arg_value</code> <code>str</code> <p>The input provided by argparse.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The environment variable value if it exists. Otherwise, the input.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def env_var(arg_value: str) -&gt; str:\n    \"\"\"Read a value from the environment.\n\n    Args:\n        arg_value: The input provided by argparse.\n\n    Returns:\n        The environment variable value if it exists. Otherwise, the input.\n    \"\"\"\n    return os.environ.get(arg_value, arg_value)\n</code></pre>"},{"location":"api/m/cli/#m.cli.env_var_or_empty","title":"<code>env_var_or_empty(arg_value)</code>","text":"<p>Read a value from the environment.</p> <p>Unlike the env_var validator, this will only allow the <code>arg_value</code> to pass through if is not in the form of an environment variable. That is, if the value is all uppercase letters and underscores it will attempt to read from the environment and return an empty string if not defined.</p> <p>Parameters:</p> Name Type Description Default <code>arg_value</code> <code>str</code> <p>The input provided by argparse.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The environment variable value if it exists. Otherwise, empty string.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def env_var_or_empty(arg_value: str) -&gt; str:\n    \"\"\"Read a value from the environment.\n\n    Unlike the [env_var][m.cli.validators.env_var] validator, this will only\n    allow the `arg_value` to pass through if is not in the form of an\n    environment variable. That is, if the value is all uppercase letters and\n    underscores it will attempt to read from the environment and return an empty\n    string if not defined.\n\n    Args:\n        arg_value: The input provided by argparse.\n\n    Returns:\n        The environment variable value if it exists. Otherwise, empty string.\n    \"\"\"\n    env_form = arg_value.upper().replace('-', '_', -1)\n    if arg_value == env_form:\n        return os.environ.get(arg_value, '')\n    return arg_value\n</code></pre>"},{"location":"api/m/cli/#m.cli.exec_cli","title":"<code>exec_cli(cli_commands)</code>","text":"<p>Execute the cli application.</p> <p>usage::</p> <pre><code>def create_cli_commands() -&gt; CliCommands:\n    # We may import CliCommand objects from other projects and create\n    # a new one with them.\n    return import_cli_commands('cli.command.module')\n\ndef main():\n    cli_commands = create_cli_commands()\n    exec_cli(cli_commands)\n</code></pre> <p>This is the preferred way to execute the cli application as it will allow other potential applications to use the cli commands.</p> <p>Parameters:</p> Name Type Description Default <code>cli_commands</code> <code>CliCommands</code> <p>The cli commands to execute.</p> required Source code in <code>m/cli/cli.py</code> <pre><code>def exec_cli(cli_commands: CliCommands) -&gt; None:\n    \"\"\"Execute the cli application.\n\n    usage::\n\n        def create_cli_commands() -&gt; CliCommands:\n            # We may import CliCommand objects from other projects and create\n            # a new one with them.\n            return import_cli_commands('cli.command.module')\n\n        def main():\n            cli_commands = create_cli_commands()\n            exec_cli(cli_commands)\n\n    This is the preferred way to execute the cli application as it will allow\n    other potential applications to use the cli commands.\n\n    Args:\n        cli_commands: The cli commands to execute.\n    \"\"\"\n    arg = _main_parser(cli_commands)\n\n    run_func = None\n    command_name = ''\n\n    commands = cli_commands.commands\n    # WPS421 encourages to use try/except instead of hasattr but in this\n    # case we want explicitly before using it.\n    if hasattr(arg, 'subcommand_name'):  # noqa: WPS421\n        command_name = arg.subcommand_name\n        sub_mod = cast(CliSubcommands, commands[arg.command_name])\n        run_func = sub_mod.subcommands[command_name].run\n    else:\n        command_name = arg.command_name\n        run_func = cast(CommandModule, commands[command_name]).run\n\n    len_run_args = params_count(run_func)\n    run_args = [command_name, arg, None][:len_run_args]\n    exit_code = 0\n    try:\n        # mypy is having a hard time figuring out the type of run_args\n        exit_code = run_func(*run_args)  # type:ignore[arg-type]\n    except Exception as ex:\n        default_issue_handler(\n            Issue('unknown cli run function exception', cause=ex),\n        )\n        exit_code = 5\n    sys.exit(exit_code)\n</code></pre>"},{"location":"api/m/cli/#m.cli.import_cli_commands","title":"<code>import_cli_commands(commands_module)</code>","text":"<p>Gather the commands and subcommands for the cli.</p> <p>Parameters:</p> Name Type Description Default <code>commands_module</code> <code>str</code> <p>module containing all the commands.</p> required <p>Returns:</p> Type Description <code>CliCommands</code> <p>An instance of CliCommands gathered from the commands_module.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def import_cli_commands(commands_module: str) -&gt; CliCommands:\n    \"\"\"Gather the commands and subcommands for the cli.\n\n    Args:\n        commands_module: module containing all the commands.\n\n    Returns:\n        An instance of CliCommands gathered from the commands_module.\n    \"\"\"\n    cmd_module = import_module(commands_module)\n    if hasattr(cmd_module, 'create_cli_commands'):\n        # No extra checks for now, if a module has this we assume that\n        # it has the right signature.\n        return cast(CliCommands, cmd_module.create_cli_commands())\n\n    commands: dict[str, CommandModule | CliSubcommands] = {}\n    root_cmd = get_command_modules(commands_module)\n\n    for key, cmd_mod in root_cmd.items():\n        commands[key] = cmd_mod\n\n    root = pth.split(cmd_module.__file__ or '')[0]\n    for cmd_name in iglob(f'{root}/*'):\n        if cmd_name.endswith('.py') or cmd_name.endswith('__'):\n            continue\n        name = pth.split(cmd_name)[1]\n        commands[name] = CliSubcommands(\n            meta=_get_meta_module(f'{commands_module}.{name}', default_meta),\n            subcommands=get_command_modules(f'{commands_module}.{name}'),\n        )\n\n    return CliCommands(\n        meta=_get_meta_module(commands_module, default_root_meta),\n        commands=commands,\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.merge_cli_commands","title":"<code>merge_cli_commands(base, overrides, **resolutions)</code>","text":"<p>Merge two CliCommands instances.</p> <p>Resolutions may be provided to resolve merge conflicts between two subcommands.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>CliCommands</code> <p>The base CliCommands instance.</p> required <code>overrides</code> <code>CliCommands</code> <p>The overrides CliCommands instance.</p> required <code>resolutions</code> <code>SubCmdResolution</code> <p>A dictionary of resolutions for subcommands.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliCommands</code> <p>A new CliCommands instance.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def merge_cli_commands(\n    base: CliCommands,\n    overrides: CliCommands,\n    **resolutions: SubCmdResolution,\n) -&gt; CliCommands:\n    \"\"\"Merge two CliCommands instances.\n\n    Resolutions may be provided to resolve merge conflicts between two\n    subcommands.\n\n    Args:\n        base: The base CliCommands instance.\n        overrides: The overrides CliCommands instance.\n        resolutions: A dictionary of resolutions for subcommands.\n\n    Returns:\n        A new CliCommands instance.\n    \"\"\"\n    commands: dict[str, CommandModule | CliSubcommands] = {**base.commands}\n    for cmd_name, cmd_item in overrides.commands.items():\n        resolution = resolutions.get(cmd_name)\n        commands[cmd_name] = _get_new_command(cmd_name, commands, cmd_item, resolution)\n\n    return CliCommands(\n        meta=base.meta or overrides.meta,\n        commands=commands,\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.run_cli","title":"<code>run_cli(commands_module, add_args=None)</code>","text":"<p>Run the cli application.</p> <p>Deprecated, use <code>exec_cli</code> instead.</p> <p>usage::</p> <pre><code>def add_args(argp):\n    argp.add_argument(...)\ndef main():\n    run_cli('m.cli.commands', add_args)\n</code></pre> <p>We only need <code>add_args</code> if we need to gain access to the <code>argparse.ArgumentParser</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>commands_module</code> <code>str | None</code> <p>The full name of the module containing the commands.</p> required <code>add_args</code> <code>Callable[[ArgumentParser], None] | None</code> <p>Optional callback to gain access to the ArgumentParser.</p> <code>None</code> Source code in <code>m/cli/cli.py</code> <pre><code>@typing_extensions.deprecated(\n    '`run_cli` deprecated; use `exec_cli` instead.',\n)\ndef run_cli(\n    commands_module: str | None,\n    add_args: Callable[[argparse.ArgumentParser], None] | None = None,\n) -&gt; None:  # pragma: no cover\n    \"\"\"Run the cli application.\n\n    Deprecated, use `exec_cli` instead.\n\n    usage::\n\n        def add_args(argp):\n            argp.add_argument(...)\n        def main():\n            run_cli('m.cli.commands', add_args)\n\n    We only need `add_args` if we need to gain access to the\n    `argparse.ArgumentParser` instance.\n\n    Args:\n        commands_module: The full name of the module containing the commands.\n        add_args: Optional callback to gain access to the ArgumentParser.\n    \"\"\"\n    # NOTE: This is a deprecated feature and will be removed in the future.\n    if commands_module and '/' in commands_module:\n        warn(\n            '`run_cli(__file__)` is deprecated, use `run_cli(\"commands.module\") instead',\n            DeprecationWarning,\n        )\n        root = pth.split(pth.split(commands_module)[0])[1]\n        commands_module = f'{root}.cli.commands'\n    cli_commands: CliCommands = CliCommands(commands={}, meta=default_root_meta)\n    if commands_module:\n        cli_commands = import_cli_commands(commands_module)\n    if add_args:\n        warn('run_cli add_args is deprecated, use meta.add_arguments instead', DeprecationWarning)\n        if not cli_commands.meta:\n            cli_commands.meta = MetaModule(\n                meta=default_root_meta.meta,\n                add_arguments=add_args,\n            )\n        cli_commands.meta.add_arguments = add_args\n    exec_cli(cli_commands)\n</code></pre>"},{"location":"api/m/cli/#m.cli.run_main","title":"<code>run_main(callback, result_handler=default_result_handler, issue_handler=default_issue_handler)</code>","text":"<p>Run the callback and print the returned value.</p> <p>To change how the result or an issue should be display provide the optional arguments <code>handle_result</code> and <code>handle_issue</code>. For instance, to display the raw value provide the <code>print</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[], OneOf[Issue, Any]]</code> <p>A function that returns a <code>OneOf</code>.</p> required <code>result_handler</code> <code>Callable[[Any], None]</code> <p>A function that takes in the Good result.</p> <code>default_result_handler</code> <code>issue_handler</code> <code>Callable[[Issue], None]</code> <p>A function that takes in the Issue.</p> <code>default_issue_handler</code> <p>Returns:</p> Type Description <code>int</code> <p>0 if the callback is a <code>Good</code> result otherwise return 1.</p> Source code in <code>m/cli/cli.py</code> <pre><code>def run_main(\n    callback: Callable[[], OneOf[Issue, Any]],\n    result_handler: Callable[[Any], None] = default_result_handler,\n    issue_handler: Callable[[Issue], None] = default_issue_handler,\n) -&gt; int:\n    \"\"\"Run the callback and print the returned value.\n\n    To change how the result or an issue should be display provide the optional\n    arguments `handle_result` and `handle_issue`. For instance, to display the\n    raw value provide the `print` function.\n\n    Args:\n        callback: A function that returns a `OneOf`.\n        result_handler: A function that takes in the Good result.\n        issue_handler: A function that takes in the Issue.\n\n    Returns:\n        0 if the callback is a `Good` result otherwise return 1.\n    \"\"\"\n    res = None\n    try:\n        res = callback()\n    except Exception as ex:\n        issue_handler(Issue('unknown caught exception', cause=ex))\n        return 2\n    if isinstance(res, Bad):\n        problem = res.value\n        if isinstance(problem, Issue):\n            issue_handler(problem)\n        else:\n            issue_handler(Issue('non-issue exception', cause=problem))\n        return 1\n    result_handler(res.value)\n    return 0\n</code></pre>"},{"location":"api/m/cli/#m.cli.subcommands","title":"<code>subcommands(meta=None, **commands)</code>","text":"<p>Create a CliSubcommands instance.</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>MetaModule | None</code> <p>The meta for the command group.</p> <code>None</code> <code>commands</code> <code>DecoratedRunFunction</code> <p>The commands the group.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliSubcommands</code> <p>An instance of CliSubcommands.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def subcommands(\n    meta: MetaModule | None = None,\n    **commands: DecoratedRunFunction,\n) -&gt; CliSubcommands:\n    \"\"\"Create a CliSubcommands instance.\n\n    Args:\n        meta: The meta for the command group.\n        commands: The commands the group.\n\n    Returns:\n        An instance of CliSubcommands.\n    \"\"\"\n    return CliSubcommands(\n        meta=meta,\n        subcommands={\n            cmd_name: CommandModule(run=cmd_item)\n            for cmd_name, cmd_item in commands.items()\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.validate_file_exists","title":"<code>validate_file_exists(path)</code>","text":"<p>Assert that a file exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the file does not exist.</p> <p>Returns:</p> Type Description <code>str</code> <p>The path if it exists.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_file_exists(path: str) -&gt; str:\n    \"\"\"Assert that a file exists.\n\n    Args:\n        path: The path to the file.\n\n    Raises:\n        ArgumentTypeError: If the file does not exist.\n\n    Returns:\n        The path if it exists.\n    \"\"\"\n    path_inst = Path(path)\n    if path_inst.exists():\n        return path\n    raise ArgumentTypeError('file does not exist')\n</code></pre>"},{"location":"api/m/cli/#m.cli.validate_json_payload","title":"<code>validate_json_payload(file_path)</code>","text":"<p>Return a dictionary from the contents of file_path.</p> <p>This is a string that tell us to read from a file, stdin or just plain json data.</p> <p>It can be used parse <code>yaml</code> files as well. The extension should be <code>.yaml</code> or <code>.yml</code>.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A string with the json payload. If it starts with <code>@</code> then the name of a valid json file from where the payload will be read.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the file_path is meant to be a valid path and it does not exist.</p> <p>Returns:</p> Type Description <code>Any</code> <p>A parsed json payload</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_json_payload(file_path: str) -&gt; Any:\n    \"\"\"Return a dictionary from the contents of file_path.\n\n    This is a string that tell us to read from a file, stdin or just\n    plain json data.\n\n    It can be used parse `yaml` files as well. The extension should be\n    `.yaml` or `.yml`.\n\n    Args:\n        file_path: A string with the json payload. If it starts with `@` then\n            the name of a valid json file from where the payload will be read.\n\n    Raises:\n        ArgumentTypeError: If the file_path is meant to be a valid path and it\n            does not exist.\n\n    Returns:\n        A parsed json payload\n    \"\"\"\n    if file_path == '@-':\n        res = read_json(None)\n        if res.is_bad:\n            msg = f'invalid json payload in SYS.STDIN\\n{res.value}'\n            raise ArgumentTypeError(msg)\n        return res.value\n    if file_path.startswith('@'):\n        err = ''\n        filename = file_path[1:]\n        if Path.exists(Path(filename)):\n            res = read_yson(filename)\n            if not res.is_bad:\n                return res.value\n            err = f'invalid json payload in {filename}\\n{res.value}'\n        else:\n            err = f'file \"{filename}\" does not exist'\n        if err:\n            raise ArgumentTypeError(err)\n    res = parse_json(file_path)\n    if res.is_bad:\n        raise ArgumentTypeError(f'invalid json payload\\n{res.value}')\n    return res.value\n</code></pre>"},{"location":"api/m/cli/#m.cli.validate_payload","title":"<code>validate_payload(file_path)</code>","text":"<p>Return the raw payload.</p> <p>This allows us to read from a file or the stdin stream.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A string with the payload. If it starts with <code>@</code> then the name of a valid file from where the payload will be read.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the file_path is meant to be a valid path and it does not exist.</p> <p>Returns:</p> Type Description <code>str</code> <p>The payload found in the file.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_payload(file_path: str) -&gt; str:\n    \"\"\"Return the raw payload.\n\n    This allows us to read from a file or the stdin stream.\n\n    Args:\n        file_path: A string with the payload. If it starts with `@` then the\n            name of a valid file from where the payload will be read.\n\n    Raises:\n        ArgumentTypeError: If the file_path is meant to be a valid path and it\n            does not exist.\n\n    Returns:\n        The payload found in the file.\n    \"\"\"\n    if file_path.startswith(r'\\@'):\n        # escape @ with \\ to let the cli know that the payload starts with @\n        return file_path[1:]\n    if file_path == '@-':\n        return sys.stdin.read()\n    if file_path.startswith('@'):\n        filename = file_path[1:]\n        path_handle = Path(filename)\n        if not Path.exists(path_handle):\n            raise ArgumentTypeError(f'file \"{filename}\" does not exist')\n        with Path.open(path_handle, encoding='UTF-8') as fp:\n            return fp.read()\n    return file_path\n</code></pre>"},{"location":"api/m/cli/args/","title":"args","text":""},{"location":"api/m/cli/args/#m.cli.args.Arg","title":"<code>Arg(default=PydanticUndefined, *, help, positional=None, required=None, aliases=None, nargs=None, validator=None)</code>","text":"<p>Create a pydantic <code>Field</code>.</p> <p>Field docs: https://docs.pydantic.dev/2.2/usage/fields</p> <p>Defines properties used to create an argparse argument. This function should work for most cases. If we need something that is not covered we can use <code>ArgProxy</code> instead which is untyped but provides all the arguments and keyword arguments to argparse.</p> <p>See https://docs.python.org/3/library/argparse.html.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any</code> <p>Default value if the field is not set.</p> <code>PydanticUndefined</code> <code>help</code> <code>str</code> <p>Human-readable description.</p> required <code>positional</code> <code>bool | None</code> <p>Whether the argument is positional or not.</p> <code>None</code> <code>required</code> <code>bool | None</code> <p>Indicate whether an argument is required or optional.</p> <code>None</code> <code>aliases</code> <code>list[str] | None</code> <p>Alternative names for the argument.</p> <code>None</code> <code>nargs</code> <code>int | Literal['?', '*', '+'] | None</code> <p>Number of times the argument can be used.</p> <code>None</code> <code>validator</code> <code>Callable[[str], str] | None</code> <p>Function to validate the argument.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>. The return annotation is <code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def Arg(  # noqa: N802, WPS211\n    default: Any = PydanticUndefined,\n    *,\n    help: str,  # noqa: WPS125\n    positional: bool | None = None,\n    required: bool | None = None,\n    aliases: list[str] | None = None,\n    nargs: int | Literal['?', '*', '+'] | None = None,\n    validator: Callable[[str], str] | None = None,\n) -&gt; Any:\n    \"\"\"Create a pydantic `Field`.\n\n    Field docs: https://docs.pydantic.dev/2.2/usage/fields\n\n    Defines properties used to create an argparse argument. This function\n    should work for most cases. If we need something that is not covered\n    we can use `ArgProxy` instead which is untyped but provides all the arguments\n    and keyword arguments to argparse.\n\n    See https://docs.python.org/3/library/argparse.html.\n\n    Args:\n        default: Default value if the field is not set.\n        help: Human-readable description.\n        positional: Whether the argument is positional or not.\n        required: Indicate whether an argument is required or optional.\n        aliases: Alternative names for the argument.\n        nargs: Number of times the argument can be used.\n        validator: Function to validate the argument.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is\n            `Any` so `Arg` can be used on type annotated fields without causing\n            a typing error.\n    \"\"\"\n    extras = {\n        'positional': positional,\n        'validator': validator,\n        'aliases': aliases,\n        'nargs': nargs,\n        'required': required,\n    }\n    return FieldInfo.from_field(\n        default,\n        description=cleandoc(help),\n        json_schema_extra={k: v for k, v in extras.items() if v is not None},\n    )\n</code></pre>"},{"location":"api/m/cli/args/#m.cli.args.ArgProxy","title":"<code>ArgProxy(*args, **kwargs)</code>","text":"<p>Wrap function to provide all argparse inputs.</p> <p>This is a escape hatch and does not provide any typings. See https://docs.python.org/3/library/argparse.html.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The arguments to argparse add_arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to argparse add arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>. The return annotation is <code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def ArgProxy(*args: Any, **kwargs: Any) -&gt; Any:  # noqa: N802\n    \"\"\"Wrap function to provide all argparse inputs.\n\n    This is a escape hatch and does not provide any typings.\n    See https://docs.python.org/3/library/argparse.html.\n\n    Args:\n        args: The arguments to argparse add_arguments.\n        kwargs: The keyword arguments to argparse add arguments.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is\n            `Any` so `Arg` can be used on type annotated fields without causing\n            a typing error.\n    \"\"\"\n    return FieldInfo.from_field(\n        json_schema_extra={\n            'proxy': FuncArgs(args=list(args), kwargs=kwargs),\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/args/#m.cli.args.Meta","title":"<code>Meta(*, help, description)</code>","text":"<p>Create the meta dictionary for a subcommand description.</p> <p>In the case of the root command the <code>help</code> may be set to empty since it is not used.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>The help message for the subcommand.</p> required <code>description</code> <code>str</code> <p>The description for the command/subcommand.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary with the help and description.</p> Source code in <code>m/cli/args.py</code> <pre><code>def Meta(  # noqa: N802\n    *,\n    help: str,  # noqa: WPS125\n    description: str,\n) -&gt; dict[str, str]:\n    \"\"\"Create the meta dictionary for a subcommand description.\n\n    In the case of the root command the `help` may be set to empty since it\n    is not used.\n\n    Args:\n        help: The help message for the subcommand.\n        description: The description for the command/subcommand.\n\n    Returns:\n        A dictionary with the help and description.\n    \"\"\"\n    return {\n        'help': help,\n        'description': cleandoc(description),\n    }\n</code></pre>"},{"location":"api/m/cli/args/#m.cli.args.RemainderArgs","title":"<code>RemainderArgs(*, help=_Unset)</code>","text":"<p>Provide a list of unrecognized arguments.</p> <p>This is a escape hatch and does not provide any typings. May be useful for commands that need to pass arguments to other commands.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str | None</code> <p>Human-readable description.</p> <code>_Unset</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>, the return annotation is</p> <code>Any</code> <p><code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def RemainderArgs(  # noqa: N802\n    *,\n    help: str | None = _Unset,  # noqa: WPS125\n) -&gt; Any:\n    \"\"\"Provide a list of unrecognized arguments.\n\n    This is a escape hatch and does not provide any typings. May be\n    useful for commands that need to pass arguments to other commands.\n\n    Args:\n        help: Human-readable description.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo], the return annotation is\n        `Any` so `Arg` can be used on type annotated fields without causing a typing error.\n    \"\"\"\n    return FieldInfo.from_field(\n        [],\n        description=help,\n        json_schema_extra={'__remainder_args': True},\n    )\n</code></pre>"},{"location":"api/m/cli/cli/","title":"cli","text":""},{"location":"api/m/cli/cli/#m.cli.cli.cli_integration_token","title":"<code>cli_integration_token(integration, env_var)</code>","text":"<p>Return a function that takes in a parser.</p> <p>This generated function registers a token argument in the parser which looks for its value in the environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>integration</code> <code>str</code> <p>The name of the integration.</p> required <code>env_var</code> <code>str</code> <p>The environment variable name.</p> required <p>Returns:</p> Type Description <code>cli_global_option</code> <p>A function to add arguments to an argparse parser.</p> Source code in <code>m/cli/cli.py</code> <pre><code>def cli_integration_token(\n    integration: str,\n    env_var: str,\n) -&gt; cli_global_option:\n    \"\"\"Return a function that takes in a parser.\n\n    This generated function registers a token argument in the parser\n    which looks for its value in the environment variables.\n\n    Args:\n        integration: The name of the integration.\n        env_var: The environment variable name.\n\n    Returns:\n        A function to add arguments to an argparse parser.\n    \"\"\"\n    return lambda parser: parser.add_argument(\n        '-t',\n        '--token',\n        type=validate_non_empty_str,\n        default=env(env_var),\n        help=f'{integration} access token (default: env.{env_var})',\n    )\n</code></pre>"},{"location":"api/m/cli/cli/#m.cli.cli.exec_cli","title":"<code>exec_cli(cli_commands)</code>","text":"<p>Execute the cli application.</p> <p>usage::</p> <pre><code>def create_cli_commands() -&gt; CliCommands:\n    # We may import CliCommand objects from other projects and create\n    # a new one with them.\n    return import_cli_commands('cli.command.module')\n\ndef main():\n    cli_commands = create_cli_commands()\n    exec_cli(cli_commands)\n</code></pre> <p>This is the preferred way to execute the cli application as it will allow other potential applications to use the cli commands.</p> <p>Parameters:</p> Name Type Description Default <code>cli_commands</code> <code>CliCommands</code> <p>The cli commands to execute.</p> required Source code in <code>m/cli/cli.py</code> <pre><code>def exec_cli(cli_commands: CliCommands) -&gt; None:\n    \"\"\"Execute the cli application.\n\n    usage::\n\n        def create_cli_commands() -&gt; CliCommands:\n            # We may import CliCommand objects from other projects and create\n            # a new one with them.\n            return import_cli_commands('cli.command.module')\n\n        def main():\n            cli_commands = create_cli_commands()\n            exec_cli(cli_commands)\n\n    This is the preferred way to execute the cli application as it will allow\n    other potential applications to use the cli commands.\n\n    Args:\n        cli_commands: The cli commands to execute.\n    \"\"\"\n    arg = _main_parser(cli_commands)\n\n    run_func = None\n    command_name = ''\n\n    commands = cli_commands.commands\n    # WPS421 encourages to use try/except instead of hasattr but in this\n    # case we want explicitly before using it.\n    if hasattr(arg, 'subcommand_name'):  # noqa: WPS421\n        command_name = arg.subcommand_name\n        sub_mod = cast(CliSubcommands, commands[arg.command_name])\n        run_func = sub_mod.subcommands[command_name].run\n    else:\n        command_name = arg.command_name\n        run_func = cast(CommandModule, commands[command_name]).run\n\n    len_run_args = params_count(run_func)\n    run_args = [command_name, arg, None][:len_run_args]\n    exit_code = 0\n    try:\n        # mypy is having a hard time figuring out the type of run_args\n        exit_code = run_func(*run_args)  # type:ignore[arg-type]\n    except Exception as ex:\n        default_issue_handler(\n            Issue('unknown cli run function exception', cause=ex),\n        )\n        exit_code = 5\n    sys.exit(exit_code)\n</code></pre>"},{"location":"api/m/cli/cli/#m.cli.cli.run_cli","title":"<code>run_cli(commands_module, add_args=None)</code>","text":"<p>Run the cli application.</p> <p>Deprecated, use <code>exec_cli</code> instead.</p> <p>usage::</p> <pre><code>def add_args(argp):\n    argp.add_argument(...)\ndef main():\n    run_cli('m.cli.commands', add_args)\n</code></pre> <p>We only need <code>add_args</code> if we need to gain access to the <code>argparse.ArgumentParser</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>commands_module</code> <code>str | None</code> <p>The full name of the module containing the commands.</p> required <code>add_args</code> <code>Callable[[ArgumentParser], None] | None</code> <p>Optional callback to gain access to the ArgumentParser.</p> <code>None</code> Source code in <code>m/cli/cli.py</code> <pre><code>@typing_extensions.deprecated(\n    '`run_cli` deprecated; use `exec_cli` instead.',\n)\ndef run_cli(\n    commands_module: str | None,\n    add_args: Callable[[argparse.ArgumentParser], None] | None = None,\n) -&gt; None:  # pragma: no cover\n    \"\"\"Run the cli application.\n\n    Deprecated, use `exec_cli` instead.\n\n    usage::\n\n        def add_args(argp):\n            argp.add_argument(...)\n        def main():\n            run_cli('m.cli.commands', add_args)\n\n    We only need `add_args` if we need to gain access to the\n    `argparse.ArgumentParser` instance.\n\n    Args:\n        commands_module: The full name of the module containing the commands.\n        add_args: Optional callback to gain access to the ArgumentParser.\n    \"\"\"\n    # NOTE: This is a deprecated feature and will be removed in the future.\n    if commands_module and '/' in commands_module:\n        warn(\n            '`run_cli(__file__)` is deprecated, use `run_cli(\"commands.module\") instead',\n            DeprecationWarning,\n        )\n        root = pth.split(pth.split(commands_module)[0])[1]\n        commands_module = f'{root}.cli.commands'\n    cli_commands: CliCommands = CliCommands(commands={}, meta=default_root_meta)\n    if commands_module:\n        cli_commands = import_cli_commands(commands_module)\n    if add_args:\n        warn('run_cli add_args is deprecated, use meta.add_arguments instead', DeprecationWarning)\n        if not cli_commands.meta:\n            cli_commands.meta = MetaModule(\n                meta=default_root_meta.meta,\n                add_arguments=add_args,\n            )\n        cli_commands.meta.add_arguments = add_args\n    exec_cli(cli_commands)\n</code></pre>"},{"location":"api/m/cli/cli/#m.cli.cli.run_main","title":"<code>run_main(callback, result_handler=default_result_handler, issue_handler=default_issue_handler)</code>","text":"<p>Run the callback and print the returned value.</p> <p>To change how the result or an issue should be display provide the optional arguments <code>handle_result</code> and <code>handle_issue</code>. For instance, to display the raw value provide the <code>print</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[], OneOf[Issue, Any]]</code> <p>A function that returns a <code>OneOf</code>.</p> required <code>result_handler</code> <code>Callable[[Any], None]</code> <p>A function that takes in the Good result.</p> <code>default_result_handler</code> <code>issue_handler</code> <code>Callable[[Issue], None]</code> <p>A function that takes in the Issue.</p> <code>default_issue_handler</code> <p>Returns:</p> Type Description <code>int</code> <p>0 if the callback is a <code>Good</code> result otherwise return 1.</p> Source code in <code>m/cli/cli.py</code> <pre><code>def run_main(\n    callback: Callable[[], OneOf[Issue, Any]],\n    result_handler: Callable[[Any], None] = default_result_handler,\n    issue_handler: Callable[[Issue], None] = default_issue_handler,\n) -&gt; int:\n    \"\"\"Run the callback and print the returned value.\n\n    To change how the result or an issue should be display provide the optional\n    arguments `handle_result` and `handle_issue`. For instance, to display the\n    raw value provide the `print` function.\n\n    Args:\n        callback: A function that returns a `OneOf`.\n        result_handler: A function that takes in the Good result.\n        issue_handler: A function that takes in the Issue.\n\n    Returns:\n        0 if the callback is a `Good` result otherwise return 1.\n    \"\"\"\n    res = None\n    try:\n        res = callback()\n    except Exception as ex:\n        issue_handler(Issue('unknown caught exception', cause=ex))\n        return 2\n    if isinstance(res, Bad):\n        problem = res.value\n        if isinstance(problem, Issue):\n            issue_handler(problem)\n        else:\n            issue_handler(Issue('non-issue exception', cause=problem))\n        return 1\n    result_handler(res.value)\n    return 0\n</code></pre>"},{"location":"api/m/cli/handlers/","title":"handlers","text":""},{"location":"api/m/cli/handlers/#m.cli.handlers.create_dict_handler","title":"<code>create_dict_handler(pretty, as_yaml)</code>","text":"<p>Create a json or yaml handler.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>If true, t highlights the output.</p> required <code>as_yaml</code> <code>bool</code> <p>If true, it formats using yaml.</p> required <p>Returns:</p> Type Description <code>Callable[[Any], None]</code> <p>A function that uses the arguments</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_dict_handler(pretty: bool, as_yaml: bool) -&gt; Callable[[Any], None]:\n    \"\"\"Create a json or yaml handler.\n\n    Args:\n        pretty: If true, t highlights the output.\n        as_yaml: If true, it formats using yaml.\n\n    Returns:\n        A function that uses the arguments\n    \"\"\"\n    return (\n        create_yaml_handler(pretty)\n        if as_yaml\n        else create_json_handler(pretty)\n    )\n</code></pre>"},{"location":"api/m/cli/handlers/#m.cli.handlers.create_issue_handler","title":"<code>create_issue_handler(use_warning)</code>","text":"<p>Generate a function to log an issue.</p> <p>Parameters:</p> Name Type Description Default <code>use_warning</code> <code>bool</code> <p>Uses a warning log instead of an error.</p> required <p>Returns:</p> Type Description <code>Callable[[Issue], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_issue_handler(use_warning: bool) -&gt; Callable[[Issue], None]:\n    \"\"\"Generate a function to log an issue.\n\n    Args:\n        use_warning: Uses a warning log instead of an error.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_issue_handler, use_warning)\n</code></pre>"},{"location":"api/m/cli/handlers/#m.cli.handlers.create_json_handler","title":"<code>create_json_handler(pretty)</code>","text":"<p>Generate a function to display a value to stdout as json.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>If true, it formats with indentation of 2 spaces.</p> required <p>Returns:</p> Type Description <code>Callable[[Any], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_json_handler(pretty: bool) -&gt; Callable[[Any], None]:\n    \"\"\"Generate a function to display a value to stdout as json.\n\n    Args:\n        pretty: If true, it formats with indentation of 2 spaces.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_json_handler, pretty)\n</code></pre>"},{"location":"api/m/cli/handlers/#m.cli.handlers.create_yaml_handler","title":"<code>create_yaml_handler(pretty)</code>","text":"<p>Generate a function to display a value to stdout as yaml.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>If true, it highlights the output.</p> required <p>Returns:</p> Type Description <code>Callable[[Any], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_yaml_handler(pretty: bool) -&gt; Callable[[Any], None]:\n    \"\"\"Generate a function to display a value to stdout as yaml.\n\n    Args:\n        pretty: If true, it highlights the output.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_yaml_handler, pretty)\n</code></pre>"},{"location":"api/m/cli/validators/","title":"validators","text":""},{"location":"api/m/cli/validators/#m.cli.validators.env_var","title":"<code>env_var(arg_value)</code>","text":"<p>Read a value from the environment.</p> <p>Parameters:</p> Name Type Description Default <code>arg_value</code> <code>str</code> <p>The input provided by argparse.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The environment variable value if it exists. Otherwise, the input.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def env_var(arg_value: str) -&gt; str:\n    \"\"\"Read a value from the environment.\n\n    Args:\n        arg_value: The input provided by argparse.\n\n    Returns:\n        The environment variable value if it exists. Otherwise, the input.\n    \"\"\"\n    return os.environ.get(arg_value, arg_value)\n</code></pre>"},{"location":"api/m/cli/validators/#m.cli.validators.env_var_or_empty","title":"<code>env_var_or_empty(arg_value)</code>","text":"<p>Read a value from the environment.</p> <p>Unlike the env_var validator, this will only allow the <code>arg_value</code> to pass through if is not in the form of an environment variable. That is, if the value is all uppercase letters and underscores it will attempt to read from the environment and return an empty string if not defined.</p> <p>Parameters:</p> Name Type Description Default <code>arg_value</code> <code>str</code> <p>The input provided by argparse.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The environment variable value if it exists. Otherwise, empty string.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def env_var_or_empty(arg_value: str) -&gt; str:\n    \"\"\"Read a value from the environment.\n\n    Unlike the [env_var][m.cli.validators.env_var] validator, this will only\n    allow the `arg_value` to pass through if is not in the form of an\n    environment variable. That is, if the value is all uppercase letters and\n    underscores it will attempt to read from the environment and return an empty\n    string if not defined.\n\n    Args:\n        arg_value: The input provided by argparse.\n\n    Returns:\n        The environment variable value if it exists. Otherwise, empty string.\n    \"\"\"\n    env_form = arg_value.upper().replace('-', '_', -1)\n    if arg_value == env_form:\n        return os.environ.get(arg_value, '')\n    return arg_value\n</code></pre>"},{"location":"api/m/cli/validators/#m.cli.validators.validate_file_exists","title":"<code>validate_file_exists(path)</code>","text":"<p>Assert that a file exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the file does not exist.</p> <p>Returns:</p> Type Description <code>str</code> <p>The path if it exists.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_file_exists(path: str) -&gt; str:\n    \"\"\"Assert that a file exists.\n\n    Args:\n        path: The path to the file.\n\n    Raises:\n        ArgumentTypeError: If the file does not exist.\n\n    Returns:\n        The path if it exists.\n    \"\"\"\n    path_inst = Path(path)\n    if path_inst.exists():\n        return path\n    raise ArgumentTypeError('file does not exist')\n</code></pre>"},{"location":"api/m/cli/validators/#m.cli.validators.validate_json_payload","title":"<code>validate_json_payload(file_path)</code>","text":"<p>Return a dictionary from the contents of file_path.</p> <p>This is a string that tell us to read from a file, stdin or just plain json data.</p> <p>It can be used parse <code>yaml</code> files as well. The extension should be <code>.yaml</code> or <code>.yml</code>.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A string with the json payload. If it starts with <code>@</code> then the name of a valid json file from where the payload will be read.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the file_path is meant to be a valid path and it does not exist.</p> <p>Returns:</p> Type Description <code>Any</code> <p>A parsed json payload</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_json_payload(file_path: str) -&gt; Any:\n    \"\"\"Return a dictionary from the contents of file_path.\n\n    This is a string that tell us to read from a file, stdin or just\n    plain json data.\n\n    It can be used parse `yaml` files as well. The extension should be\n    `.yaml` or `.yml`.\n\n    Args:\n        file_path: A string with the json payload. If it starts with `@` then\n            the name of a valid json file from where the payload will be read.\n\n    Raises:\n        ArgumentTypeError: If the file_path is meant to be a valid path and it\n            does not exist.\n\n    Returns:\n        A parsed json payload\n    \"\"\"\n    if file_path == '@-':\n        res = read_json(None)\n        if res.is_bad:\n            msg = f'invalid json payload in SYS.STDIN\\n{res.value}'\n            raise ArgumentTypeError(msg)\n        return res.value\n    if file_path.startswith('@'):\n        err = ''\n        filename = file_path[1:]\n        if Path.exists(Path(filename)):\n            res = read_yson(filename)\n            if not res.is_bad:\n                return res.value\n            err = f'invalid json payload in {filename}\\n{res.value}'\n        else:\n            err = f'file \"{filename}\" does not exist'\n        if err:\n            raise ArgumentTypeError(err)\n    res = parse_json(file_path)\n    if res.is_bad:\n        raise ArgumentTypeError(f'invalid json payload\\n{res.value}')\n    return res.value\n</code></pre>"},{"location":"api/m/cli/validators/#m.cli.validators.validate_non_empty_str","title":"<code>validate_non_empty_str(arg_value)</code>","text":"<p>Return the value as long as its not empty.</p> <p>Parameters:</p> Name Type Description Default <code>arg_value</code> <code>str</code> <p>The input provided by argparse.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the input is not provided.</p> <p>Returns:</p> Type Description <code>str</code> <p>The value if non empty.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_non_empty_str(arg_value: str) -&gt; str:\n    \"\"\"Return the value as long as its not empty.\n\n    Args:\n        arg_value: The input provided by argparse.\n\n    Raises:\n        ArgumentTypeError: If the input is not provided.\n\n    Returns:\n        The value if non empty.\n    \"\"\"\n    if not arg_value:\n        raise ArgumentTypeError('empty value not allowed')\n    return arg_value\n</code></pre>"},{"location":"api/m/cli/validators/#m.cli.validators.validate_payload","title":"<code>validate_payload(file_path)</code>","text":"<p>Return the raw payload.</p> <p>This allows us to read from a file or the stdin stream.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A string with the payload. If it starts with <code>@</code> then the name of a valid file from where the payload will be read.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the file_path is meant to be a valid path and it does not exist.</p> <p>Returns:</p> Type Description <code>str</code> <p>The payload found in the file.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_payload(file_path: str) -&gt; str:\n    \"\"\"Return the raw payload.\n\n    This allows us to read from a file or the stdin stream.\n\n    Args:\n        file_path: A string with the payload. If it starts with `@` then the\n            name of a valid file from where the payload will be read.\n\n    Raises:\n        ArgumentTypeError: If the file_path is meant to be a valid path and it\n            does not exist.\n\n    Returns:\n        The payload found in the file.\n    \"\"\"\n    if file_path.startswith(r'\\@'):\n        # escape @ with \\ to let the cli know that the payload starts with @\n        return file_path[1:]\n    if file_path == '@-':\n        return sys.stdin.read()\n    if file_path.startswith('@'):\n        filename = file_path[1:]\n        path_handle = Path(filename)\n        if not Path.exists(path_handle):\n            raise ArgumentTypeError(f'file \"{filename}\" does not exist')\n        with Path.open(path_handle, encoding='UTF-8') as fp:\n            return fp.read()\n    return file_path\n</code></pre>"},{"location":"api/m/cli/engine/","title":"engine","text":""},{"location":"api/m/cli/engine/argparse/","title":"argparse","text":""},{"location":"api/m/cli/engine/argparse/#m.cli.engine.argparse.add_model","title":"<code>add_model(parser, model)</code>","text":"<p>Add a pydantic model to an argparse ArgumentParser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The ArgumentParser instance.</p> required <code>model</code> <code>type[BaseModel]</code> <p>The pydantic model declaring the cli options.</p> required Source code in <code>m/cli/engine/argparse.py</code> <pre><code>def add_model(\n    parser: argparse.ArgumentParser,\n    model: type[BaseModel],\n) -&gt; None:\n    \"\"\"Add a pydantic model to an argparse ArgumentParser.\n\n    Args:\n        parser: The ArgumentParser instance.\n        model: The pydantic model declaring the cli options.\n    \"\"\"\n    parser.description = cleandoc(model.__doc__ or '')\n    parser.formatter_class = argparse.RawTextHelpFormatter\n    for name, field in model.model_fields.items():\n        arg_inputs = _parse_field(name, field)\n        parser.add_argument(*arg_inputs.args, **arg_inputs.kwargs)\n</code></pre>"},{"location":"api/m/cli/engine/argparse/#m.cli.engine.argparse.command","title":"<code>command(*, help, model, name=None)</code>","text":"<p>Apply a decorator to the <code>run</code> function to make it into a command.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The command name.</p> <code>None</code> <code>help</code> <code>str</code> <p>A short description of the command.</p> required <code>model</code> <code>type[BaseModel]</code> <p>A pydantic model to describe the cli arguments.</p> required <p>Returns:</p> Type Description <code>partial[partial[int]]</code> <p>A transformed run function aware of the arguments model.</p> Source code in <code>m/cli/engine/argparse.py</code> <pre><code>def command(\n    *,\n    help: str,  # noqa: WPS125\n    model: type[BaseModel],\n    name: str | None = None,\n) -&gt; partial[partial[int]]:\n    \"\"\"Apply a decorator to the `run` function to make it into a command.\n\n    Args:\n        name: The command name.\n        help: A short description of the command.\n        model: A pydantic model to describe the cli arguments.\n\n    Returns:\n        A transformed run function aware of the arguments model.\n    \"\"\"\n    # m no longer uses the name argument but we keep it for now\n    if name:  # pragma: no cover\n        warn('`name` is no longer needed, please remove it', DeprecationWarning)\n    return partial(_handle_decorated_func, CommandInputs(help, model))\n</code></pre>"},{"location":"api/m/cli/engine/misc/","title":"misc","text":""},{"location":"api/m/cli/engine/misc/#m.cli.engine.misc.argument_description","title":"<code>argument_description(description, default=MISSING)</code>","text":"<p>Append default value to argument description.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>argument description.</p> required <code>default</code> <code>Any | None</code> <p>Argument's default value.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>str</code> <p>The description of the argument.</p> Source code in <code>m/cli/engine/misc.py</code> <pre><code>def argument_description(\n    description: str,\n    default: Any | None = MISSING,\n) -&gt; str:\n    \"\"\"Append default value to argument description.\n\n    Args:\n        description: argument description.\n        default: Argument's default value.\n\n    Returns:\n        The description of the argument.\n    \"\"\"\n    default = f'(default: {default})' if default is not MISSING else ''\n    return f'{description} {default}'.strip()\n</code></pre>"},{"location":"api/m/cli/engine/misc/#m.cli.engine.misc.argument_name","title":"<code>argument_name(name)</code>","text":"<p>Normalize an argument name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the argument.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normalized name of the argument.</p> Source code in <code>m/cli/engine/misc.py</code> <pre><code>def argument_name(name: str) -&gt; str:\n    \"\"\"Normalize an argument name.\n\n    Args:\n        name: Name of the argument.\n\n    Returns:\n        Normalized name of the argument.\n    \"\"\"\n    cli_arg_name = name.replace('_', '-')\n    dashes = '-' if len(cli_arg_name) == 1 else '--'\n    return f'{dashes}{cli_arg_name}'\n</code></pre>"},{"location":"api/m/cli/engine/misc/#m.cli.engine.misc.params_count","title":"<code>params_count(func)</code>","text":"<p>Compute the number of parameters in a function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function in question.</p> required <p>Returns:</p> Type Description <code>int</code> <p>the number of parameters.</p> Source code in <code>m/cli/engine/misc.py</code> <pre><code>def params_count(func: Callable) -&gt; int:\n    \"\"\"Compute the number of parameters in a function.\n\n    Args:\n        func: The function in question.\n\n    Returns:\n        the number of parameters.\n    \"\"\"\n    sig = signature(func)\n    return len(sig.parameters)\n</code></pre>"},{"location":"api/m/cli/engine/sys/","title":"sys","text":""},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.cli_commands","title":"<code>cli_commands(root_meta=None, **commands)</code>","text":"<p>Create a CliCommands instance.</p> <p>Parameters:</p> Name Type Description Default <code>root_meta</code> <code>MetaModule | None</code> <p>The meta for the root command.</p> <code>None</code> <code>commands</code> <code>DecoratedRunFunction | CliSubcommands</code> <p>The commands and subcommands for the cli.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliCommands</code> <p>An instance of CliCommands.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def cli_commands(\n    root_meta: MetaModule | None = None,\n    **commands: DecoratedRunFunction | CliSubcommands,\n) -&gt; CliCommands:\n    \"\"\"Create a CliCommands instance.\n\n    Args:\n        root_meta: The meta for the root command.\n        commands: The commands and subcommands for the cli.\n\n    Returns:\n        An instance of CliCommands.\n    \"\"\"\n    root_meta = root_meta or default_root_meta\n    return CliCommands(\n        meta=root_meta,\n        commands={\n            cmd_name: (\n                cmd_item\n                if isinstance(cmd_item, CliSubcommands)\n                else CommandModule(run=cmd_item)\n            )\n            for cmd_name, cmd_item in commands.items()\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.command_group","title":"<code>command_group(*, help, description, add_arguments=None)</code>","text":"<p>Create an instance of a MetaModule.</p> <p>Named <code>cmd_group</code> since it is used to describe the group of commands.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>quick help describing the module.</p> required <code>description</code> <code>str</code> <p>Detailed description about the module.</p> required <code>add_arguments</code> <code>Callable[[ArgumentParser], None] | None</code> <p>Optional function to handle the argparse instance.</p> <code>None</code> <p>Returns:</p> Type Description <code>MetaModule</code> <p>An instance of a MetaModule.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def command_group(\n    *,\n    help: str,   # noqa: WPS125\n    description: str,\n    add_arguments: Callable[[ap.ArgumentParser], None] | None = None,\n) -&gt; MetaModule:\n    \"\"\"Create an instance of a MetaModule.\n\n    Named `cmd_group` since it is used to describe the group of commands.\n\n    Args:\n        help: quick help describing the module.\n        description: Detailed description about the module.\n        add_arguments: Optional function to handle the argparse instance.\n\n    Returns:\n        An instance of a MetaModule.\n    \"\"\"\n    return MetaModule(\n        meta=Meta(help=help, description=description),\n        add_arguments=add_arguments,\n    )\n</code></pre>"},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.get_command_modules","title":"<code>get_command_modules(commands_module)</code>","text":"<p>Create a dictionary of a file name to its module.</p> <p>These modules should define a <code>run</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>commands_module</code> <code>str</code> <p>The full module resolution. For instance <code>m.cli.commands</code>.</p> required <p>Returns:</p> Type Description <code>dict[str, CommandModule]</code> <p>A dictionary of command modules.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def get_command_modules(commands_module: str) -&gt; dict[str, CommandModule]:\n    \"\"\"Create a dictionary of a file name to its module.\n\n    These modules should define a `run` function.\n\n    Args:\n        commands_module: The full module resolution. For instance\n            `m.cli.commands`.\n\n    Returns:\n        A dictionary of command modules.\n    \"\"\"\n    cmd_module = import_module(commands_module)\n    dir_name = pth.split(cmd_module.__file__ or '')[0]\n    mod_names = list(iglob(f'{dir_name}/*.py'))\n    mod = {}\n    for mod_name in mod_names:\n        name = pth.split(mod_name)[1][:-3]\n        cmd_mod = _get_command_module(f'{commands_module}.{name}')\n        if cmd_mod:\n            mod[name] = cmd_mod\n    return mod\n</code></pre>"},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.import_cli_commands","title":"<code>import_cli_commands(commands_module)</code>","text":"<p>Gather the commands and subcommands for the cli.</p> <p>Parameters:</p> Name Type Description Default <code>commands_module</code> <code>str</code> <p>module containing all the commands.</p> required <p>Returns:</p> Type Description <code>CliCommands</code> <p>An instance of CliCommands gathered from the commands_module.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def import_cli_commands(commands_module: str) -&gt; CliCommands:\n    \"\"\"Gather the commands and subcommands for the cli.\n\n    Args:\n        commands_module: module containing all the commands.\n\n    Returns:\n        An instance of CliCommands gathered from the commands_module.\n    \"\"\"\n    cmd_module = import_module(commands_module)\n    if hasattr(cmd_module, 'create_cli_commands'):\n        # No extra checks for now, if a module has this we assume that\n        # it has the right signature.\n        return cast(CliCommands, cmd_module.create_cli_commands())\n\n    commands: dict[str, CommandModule | CliSubcommands] = {}\n    root_cmd = get_command_modules(commands_module)\n\n    for key, cmd_mod in root_cmd.items():\n        commands[key] = cmd_mod\n\n    root = pth.split(cmd_module.__file__ or '')[0]\n    for cmd_name in iglob(f'{root}/*'):\n        if cmd_name.endswith('.py') or cmd_name.endswith('__'):\n            continue\n        name = pth.split(cmd_name)[1]\n        commands[name] = CliSubcommands(\n            meta=_get_meta_module(f'{commands_module}.{name}', default_meta),\n            subcommands=get_command_modules(f'{commands_module}.{name}'),\n        )\n\n    return CliCommands(\n        meta=_get_meta_module(commands_module, default_root_meta),\n        commands=commands,\n    )\n</code></pre>"},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.merge_cli_commands","title":"<code>merge_cli_commands(base, overrides, **resolutions)</code>","text":"<p>Merge two CliCommands instances.</p> <p>Resolutions may be provided to resolve merge conflicts between two subcommands.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>CliCommands</code> <p>The base CliCommands instance.</p> required <code>overrides</code> <code>CliCommands</code> <p>The overrides CliCommands instance.</p> required <code>resolutions</code> <code>SubCmdResolution</code> <p>A dictionary of resolutions for subcommands.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliCommands</code> <p>A new CliCommands instance.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def merge_cli_commands(\n    base: CliCommands,\n    overrides: CliCommands,\n    **resolutions: SubCmdResolution,\n) -&gt; CliCommands:\n    \"\"\"Merge two CliCommands instances.\n\n    Resolutions may be provided to resolve merge conflicts between two\n    subcommands.\n\n    Args:\n        base: The base CliCommands instance.\n        overrides: The overrides CliCommands instance.\n        resolutions: A dictionary of resolutions for subcommands.\n\n    Returns:\n        A new CliCommands instance.\n    \"\"\"\n    commands: dict[str, CommandModule | CliSubcommands] = {**base.commands}\n    for cmd_name, cmd_item in overrides.commands.items():\n        resolution = resolutions.get(cmd_name)\n        commands[cmd_name] = _get_new_command(cmd_name, commands, cmd_item, resolution)\n\n    return CliCommands(\n        meta=base.meta or overrides.meta,\n        commands=commands,\n    )\n</code></pre>"},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.subcommands","title":"<code>subcommands(meta=None, **commands)</code>","text":"<p>Create a CliSubcommands instance.</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>MetaModule | None</code> <p>The meta for the command group.</p> <code>None</code> <code>commands</code> <code>DecoratedRunFunction</code> <p>The commands the group.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliSubcommands</code> <p>An instance of CliSubcommands.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def subcommands(\n    meta: MetaModule | None = None,\n    **commands: DecoratedRunFunction,\n) -&gt; CliSubcommands:\n    \"\"\"Create a CliSubcommands instance.\n\n    Args:\n        meta: The meta for the command group.\n        commands: The commands the group.\n\n    Returns:\n        An instance of CliSubcommands.\n    \"\"\"\n    return CliSubcommands(\n        meta=meta,\n        subcommands={\n            cmd_name: CommandModule(run=cmd_item)\n            for cmd_name, cmd_item in commands.items()\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/engine/types/","title":"types","text":""},{"location":"api/m/cli/engine/types/#m.cli.engine.types.CliCommands","title":"<code>CliCommands</code>  <code>dataclass</code>","text":"<p>Container to store the commands and subcommands for the cli.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CliCommands:\n    \"\"\"Container to store the commands and subcommands for the cli.\"\"\"\n\n    commands: dict[str, CommandModule | CliSubcommands]\n\n    # Optional root meta data to provide information about the cli.\n    meta: MetaModule | None\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.CliSubcommands","title":"<code>CliSubcommands</code>  <code>dataclass</code>","text":"<p>Container to store subcommands.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CliSubcommands:\n    \"\"\"Container to store subcommands.\"\"\"\n\n    # Dictionary of subcommands.\n    subcommands: CommandModuleMap\n\n    # Each subcommand needs to provide metadata to create the help message.\n    meta: MetaModule | None\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.CommandInputs","title":"<code>CommandInputs</code>  <code>dataclass</code>","text":"<p>Inputs to command decorator.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CommandInputs:\n    \"\"\"Inputs to command decorator.\"\"\"\n\n    help: str\n\n    model: type[BaseModel]\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.CommandModule","title":"<code>CommandModule</code>  <code>dataclass</code>","text":"<p>Container to store the run function from a \"command\" module.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CommandModule:\n    \"\"\"Container to store the run function from a \"command\" module.\"\"\"\n\n    run: DecoratedRunFunction\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.FuncArgs","title":"<code>FuncArgs</code>  <code>dataclass</code>","text":"<p>Stores function arguments.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass FuncArgs:\n    \"\"\"Stores function arguments.\"\"\"\n\n    args: list[Any]\n    kwargs: dict[str, Any]\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.MetaModule","title":"<code>MetaModule</code>  <code>dataclass</code>","text":"<p>Container to store a metadata dictionary from a \"meta\" module.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass MetaModule:\n    \"\"\"Container to store a metadata dictionary from a \"meta\" module.\"\"\"\n\n    meta: dict[str, str]\n    add_arguments: Callable[[ap.ArgumentParser], None] | None = None\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.add_arg","title":"<code>add_arg(*args, **kwargs)</code>","text":"<p>Wrap FuncArgs arguments in a function.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The arguments to argparse add_arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to argparse add arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FuncArgs</code> <p>A FuncArgs instance.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `add_arg` method is deprecated; use `m.cli.ArgProxy` instead.',\n)\ndef add_arg(*args: Any, **kwargs: Any) -&gt; FuncArgs:\n    \"\"\"Wrap FuncArgs arguments in a function.\n\n    Args:\n        args: The arguments to argparse add_arguments.\n        kwargs: The keyword arguments to argparse add arguments.\n\n    Returns:\n        A FuncArgs instance.\n    \"\"\"\n    # `m` does not reference this function anymore, excluding from coverage\n    return FuncArgs(args=list(args), kwargs=kwargs)  # pragma: no cover\n</code></pre>"},{"location":"api/m/cli/engine/parsers/","title":"parsers","text":""},{"location":"api/m/cli/engine/parsers/boolean/","title":"boolean","text":""},{"location":"api/m/cli/engine/parsers/boolean/#m.cli.engine.parsers.boolean.handle_field","title":"<code>handle_field(name, field)</code>","text":"<p>Treat the field as a boolean field.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument.</p> required <code>field</code> <code>FieldInfo</code> <p>A dictionary representation of the field.</p> required <p>Returns:</p> Type Description <code>FuncArgs</code> <p>Function arguments for the parser <code>add_argument</code> method.</p> Source code in <code>m/cli/engine/parsers/boolean.py</code> <pre><code>def handle_field(name: str, field: FieldInfo) -&gt; FuncArgs:\n    \"\"\"Treat the field as a boolean field.\n\n    Args:\n        name: The name of the argument.\n        field: A dictionary representation of the field.\n\n    Returns:\n        Function arguments for the parser `add_argument` method.\n    \"\"\"\n    default = field.default\n    extras = cast(dict, field.json_schema_extra or {})\n    aliases = cast(list[str], extras.get('aliases', None))\n    args: AnyMap = {\n        'help': argument_description(field.description or '', MISSING),\n        'required': extras.get('required', False),\n    }\n\n    if default:\n        args['action'] = 'store_false'\n        args['dest'] = name\n        names = [argument_name(f'no-{name}')]\n        if aliases:\n            names = [argument_name(f'no-{alias}') for alias in aliases]\n    else:\n        args['action'] = 'store_true'\n        names = [argument_name(name)]\n        if aliases:\n            names = [argument_name(alias) for alias in aliases]\n\n    return FuncArgs(args=names, kwargs=args)\n</code></pre>"},{"location":"api/m/cli/engine/parsers/positional/","title":"positional","text":""},{"location":"api/m/cli/engine/parsers/positional/#m.cli.engine.parsers.positional.handle_field","title":"<code>handle_field(name, field)</code>","text":"<p>Treat the field as a positional field.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument.</p> required <code>field</code> <code>FieldInfo</code> <p>A dictionary representation of the field.</p> required <p>Returns:</p> Type Description <code>FuncArgs</code> <p>Function arguments for the parser <code>add_argument</code> method.</p> Source code in <code>m/cli/engine/parsers/positional.py</code> <pre><code>def handle_field(name: str, field: FieldInfo) -&gt; FuncArgs:\n    \"\"\"Treat the field as a positional field.\n\n    Args:\n        name: The name of the argument.\n        field: A dictionary representation of the field.\n\n    Returns:\n        Function arguments for the parser `add_argument` method.\n    \"\"\"\n    extras = cast(dict, field.json_schema_extra)\n    default = field.default\n    validator = extras.get('validator', None)\n    is_required = extras.get('required', False)\n    nargs = extras.get('nargs', None)\n    arg_default = default if default is MISSING else repr(default)\n    args: AnyMap = {\n        'help': argument_description(field.description or '', arg_default),\n    }\n    if default is not MISSING:\n        args['default'] = default\n\n    if validator:\n        args['type'] = validator\n\n    if nargs:\n        args['nargs'] = nargs\n    elif not is_required:\n        args['nargs'] = '?'\n\n    return FuncArgs(args=[name], kwargs=args)\n</code></pre>"},{"location":"api/m/cli/engine/parsers/positional/#m.cli.engine.parsers.positional.should_handle","title":"<code>should_handle(extras)</code>","text":"<p>Handle a positional field.</p> <p>Parameters:</p> Name Type Description Default <code>extras</code> <code>AnyMap</code> <p>A dictionary with information for a cli argument.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it should handle the field as positional</p> Source code in <code>m/cli/engine/parsers/positional.py</code> <pre><code>def should_handle(extras: AnyMap) -&gt; bool:\n    \"\"\"Handle a positional field.\n\n    Args:\n        extras: A dictionary with information for a cli argument.\n\n    Returns:\n        True if it should handle the field as positional\n    \"\"\"\n    return extras.get('positional', False) is True\n</code></pre>"},{"location":"api/m/cli/engine/parsers/proxy/","title":"proxy","text":""},{"location":"api/m/cli/engine/parsers/proxy/#m.cli.engine.parsers.proxy.handle_field","title":"<code>handle_field(extras)</code>","text":"<p>Pass the <code>proxy</code> property in the field as is.</p> <p>Parameters:</p> Name Type Description Default <code>extras</code> <code>AnyMap</code> <p>A dictionary representation of the field.</p> required <p>Returns:</p> Type Description <code>FuncArgs</code> <p>Function arguments for the parser <code>add_argument</code> method.</p> Source code in <code>m/cli/engine/parsers/proxy.py</code> <pre><code>def handle_field(extras: AnyMap) -&gt; FuncArgs:\n    \"\"\"Pass the `proxy` property in the field as is.\n\n    Args:\n        extras: A dictionary representation of the field.\n\n    Returns:\n        Function arguments for the parser `add_argument` method.\n    \"\"\"\n    # proxy field is expected to be a FuncArgs instance.\n    return cast(FuncArgs, extras['proxy'])\n</code></pre>"},{"location":"api/m/cli/engine/parsers/proxy/#m.cli.engine.parsers.proxy.should_handle","title":"<code>should_handle(extras)</code>","text":"<p>Handle the proxy field.</p> <p>Parameters:</p> Name Type Description Default <code>extras</code> <code>AnyMap</code> <p>A dictionary with information for a cli argument.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it should handle the field as a proxy to the parser.</p> Source code in <code>m/cli/engine/parsers/proxy.py</code> <pre><code>def should_handle(extras: AnyMap) -&gt; bool:\n    \"\"\"Handle the proxy field.\n\n    Args:\n        extras: A dictionary with information for a cli argument.\n\n    Returns:\n        True if it should handle the field as a proxy to the parser.\n    \"\"\"\n    return extras.get('proxy', None) is not None\n</code></pre>"},{"location":"api/m/cli/engine/parsers/remainder/","title":"remainder","text":""},{"location":"api/m/cli/engine/parsers/remainder/#m.cli.engine.parsers.remainder.handle_field","title":"<code>handle_field(name, field)</code>","text":"<p>Set the remainder arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the field.</p> required <code>field</code> <code>FieldInfo</code> <p>A dictionary representation of the field.</p> required <p>Returns:</p> Type Description <code>FuncArgs</code> <p>Function arguments for the parser <code>add_argument</code> method.</p> Source code in <code>m/cli/engine/parsers/remainder.py</code> <pre><code>def handle_field(name: str, field: FieldInfo) -&gt; FuncArgs:\n    \"\"\"Set the remainder arguments.\n\n    Args:\n        name: The name of the field.\n        field: A dictionary representation of the field.\n\n    Returns:\n        Function arguments for the parser `add_argument` method.\n    \"\"\"\n    args: AnyMap = {\n        'help': argument_description(field.description or '', MISSING),\n        'nargs': argparse.REMAINDER,\n    }\n    return FuncArgs(args=[name], kwargs=args)\n</code></pre>"},{"location":"api/m/cli/engine/parsers/remainder/#m.cli.engine.parsers.remainder.should_handle","title":"<code>should_handle(extras)</code>","text":"<p>Handle the __remainder_args field.</p> <p>Parameters:</p> Name Type Description Default <code>extras</code> <code>AnyMap</code> <p>A dictionary with information for a cli argument.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it should provide the remainder arguments.</p> Source code in <code>m/cli/engine/parsers/remainder.py</code> <pre><code>def should_handle(extras: AnyMap) -&gt; bool:\n    \"\"\"Handle the __remainder_args field.\n\n    Args:\n        extras: A dictionary with information for a cli argument.\n\n    Returns:\n        True if it should provide the remainder arguments.\n    \"\"\"\n    return extras.get('__remainder_args') is True\n</code></pre>"},{"location":"api/m/cli/engine/parsers/standard/","title":"standard","text":""},{"location":"api/m/cli/engine/parsers/standard/#m.cli.engine.parsers.standard.handle_field","title":"<code>handle_field(name, field)</code>","text":"<p>Handle a standard field as an argument.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument.</p> required <code>field</code> <code>FieldInfo</code> <p>A dictionary representation of the field.</p> required <p>Returns:</p> Type Description <code>FuncArgs</code> <p>Function arguments for the parser <code>add_argument</code> method.</p> Source code in <code>m/cli/engine/parsers/standard.py</code> <pre><code>def handle_field(name: str, field: FieldInfo) -&gt; FuncArgs:\n    \"\"\"Handle a standard field as an argument.\n\n    Args:\n        name: The name of the argument.\n        field: A dictionary representation of the field.\n\n    Returns:\n        Function arguments for the parser `add_argument` method.\n    \"\"\"\n    extras = cast(dict, field.json_schema_extra or {})\n    default = field.default\n    validator = extras.get('validator', None)\n    required = extras.get('required', False)\n    aliases = cast(list[str], extras.get('aliases', None))\n\n    arg_default = default if default is MISSING else repr(default)\n    if 'env_var' in repr(validator):\n        # special case - do not repr\n        arg_default = f'env.{default}'\n    args: AnyMap = {\n        'help': argument_description(field.description or '', arg_default),\n        'required': required,\n        'type': str,\n    }\n\n    if default is not MISSING:\n        args['default'] = default\n\n    if validator:\n        args['type'] = validator\n\n    names = [argument_name(name)]\n    if aliases:\n        names = [argument_name(alias) for alias in aliases]\n\n    return FuncArgs(args=names, kwargs=args)\n</code></pre>"},{"location":"api/m/color/","title":"color","text":""},{"location":"api/m/color/#m.color.color","title":"<code>color(*args, auto_end=True)</code>","text":"<p>Color a message.</p> <p>Format the arguments by replacing the colors in the Colors class. For instance::</p> <pre><code>color('{blue}Hello there{end}\\n{yellow}WARNING')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>str</code> <p>Strings to color</p> <code>()</code> <code>auto_end</code> <code>bool</code> <p>Add a string to end coloring</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>A formatted message.</p> Source code in <code>m/color/colors.py</code> <pre><code>def color(*args: str, auto_end: bool = True) -&gt; str:\n    r\"\"\"Color a message.\n\n    Format the arguments by replacing the colors in the Colors class.\n    For instance::\n\n        color('{blue}Hello there{end}\\n{yellow}WARNING')\n\n    Args:\n        args: Strings to color\n        auto_end: Add a string to end coloring\n\n    Returns:\n        A formatted message.\n    \"\"\"\n    no_color = color_disabled()\n    color_map = no_color_dict if no_color else color_dict\n    end = '' if no_color or not auto_end else Color.end\n    msg_list = [msg.format(**color_map) for msg in args]\n    return ''.join(msg_list) + end\n</code></pre>"},{"location":"api/m/color/#m.color.color_disabled","title":"<code>color_disabled()</code>","text":"<p>Check for environment variable NO_COLOR.</p> <p>Utilities that format strings with color should call this function to determine if the user wants color in the final output.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if it exists and its set to true or 1.</p> Source code in <code>m/color/disable.py</code> <pre><code>def color_disabled() -&gt; bool:\n    \"\"\"Check for environment variable NO_COLOR.\n\n    Utilities that format strings with color should call this function\n    to determine if the user wants color in the final output.\n\n    Returns:\n        True if it exists and its set to true or 1.\n    \"\"\"\n    return os.environ.get('NO_COLOR', 'false') in {'true', '1', 'True'}\n</code></pre>"},{"location":"api/m/color/#m.color.highlight_json","title":"<code>highlight_json(text)</code>","text":"<p>Highlight a json string.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The json string to highlight.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A colorized json string.</p> Source code in <code>m/color/pygment.py</code> <pre><code>def highlight_json(text: str) -&gt; str:\n    \"\"\"Highlight a json string.\n\n    Args:\n        text: The json string to highlight.\n\n    Returns:\n        A colorized json string.\n    \"\"\"\n    return _highlight(text, JsonLexer())\n</code></pre>"},{"location":"api/m/color/#m.color.highlight_yaml","title":"<code>highlight_yaml(text)</code>","text":"<p>Highlight a yaml string.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The yaml string to highlight.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A colorized yaml string.</p> Source code in <code>m/color/pygment.py</code> <pre><code>def highlight_yaml(text: str) -&gt; str:\n    \"\"\"Highlight a yaml string.\n\n    Args:\n        text: The yaml string to highlight.\n\n    Returns:\n        A colorized yaml string.\n    \"\"\"\n    return _highlight(text, YamlLexer())\n</code></pre>"},{"location":"api/m/color/colors/","title":"colors","text":""},{"location":"api/m/color/colors/#m.color.colors.Color","title":"<code>Color</code>","text":"<p>A class for terminal color codes.</p> Source code in <code>m/color/colors.py</code> <pre><code>class Color:\n    \"\"\"A class for terminal color codes.\"\"\"\n\n    bold = '\\033[1m'\n    blue = '\\033[94m'\n    aqua = '\\033[96m'\n    white = '\\033[97m'\n    green = '\\033[92m'\n    orange = '\\033[38;5;172m'\n    yellow = '\\033[93m'\n    gray = '\\033[90m'\n    red = '\\033[91m'\n    purple = '\\033[95m'\n    bold_white = bold + white\n    bold_blue = bold + blue\n    bold_aqua = bold + aqua\n    bold_green = bold + green\n    bold_orange = bold + orange\n    bold_yellow = bold + yellow\n    bold_gray = bold + gray\n    bold_red = bold + red\n    bold_purple = bold + purple\n    end = '\\033[0m'\n</code></pre>"},{"location":"api/m/color/colors/#m.color.colors.color","title":"<code>color(*args, auto_end=True)</code>","text":"<p>Color a message.</p> <p>Format the arguments by replacing the colors in the Colors class. For instance::</p> <pre><code>color('{blue}Hello there{end}\\n{yellow}WARNING')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>str</code> <p>Strings to color</p> <code>()</code> <code>auto_end</code> <code>bool</code> <p>Add a string to end coloring</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>A formatted message.</p> Source code in <code>m/color/colors.py</code> <pre><code>def color(*args: str, auto_end: bool = True) -&gt; str:\n    r\"\"\"Color a message.\n\n    Format the arguments by replacing the colors in the Colors class.\n    For instance::\n\n        color('{blue}Hello there{end}\\n{yellow}WARNING')\n\n    Args:\n        args: Strings to color\n        auto_end: Add a string to end coloring\n\n    Returns:\n        A formatted message.\n    \"\"\"\n    no_color = color_disabled()\n    color_map = no_color_dict if no_color else color_dict\n    end = '' if no_color or not auto_end else Color.end\n    msg_list = [msg.format(**color_map) for msg in args]\n    return ''.join(msg_list) + end\n</code></pre>"},{"location":"api/m/color/disable/","title":"disable","text":""},{"location":"api/m/color/disable/#m.color.disable.color_disabled","title":"<code>color_disabled()</code>","text":"<p>Check for environment variable NO_COLOR.</p> <p>Utilities that format strings with color should call this function to determine if the user wants color in the final output.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if it exists and its set to true or 1.</p> Source code in <code>m/color/disable.py</code> <pre><code>def color_disabled() -&gt; bool:\n    \"\"\"Check for environment variable NO_COLOR.\n\n    Utilities that format strings with color should call this function\n    to determine if the user wants color in the final output.\n\n    Returns:\n        True if it exists and its set to true or 1.\n    \"\"\"\n    return os.environ.get('NO_COLOR', 'false') in {'true', '1', 'True'}\n</code></pre>"},{"location":"api/m/color/pygment/","title":"pygment","text":""},{"location":"api/m/color/pygment/#m.color.pygment.highlight_json","title":"<code>highlight_json(text)</code>","text":"<p>Highlight a json string.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The json string to highlight.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A colorized json string.</p> Source code in <code>m/color/pygment.py</code> <pre><code>def highlight_json(text: str) -&gt; str:\n    \"\"\"Highlight a json string.\n\n    Args:\n        text: The json string to highlight.\n\n    Returns:\n        A colorized json string.\n    \"\"\"\n    return _highlight(text, JsonLexer())\n</code></pre>"},{"location":"api/m/color/pygment/#m.color.pygment.highlight_yaml","title":"<code>highlight_yaml(text)</code>","text":"<p>Highlight a yaml string.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The yaml string to highlight.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A colorized yaml string.</p> Source code in <code>m/color/pygment.py</code> <pre><code>def highlight_yaml(text: str) -&gt; str:\n    \"\"\"Highlight a yaml string.\n\n    Args:\n        text: The yaml string to highlight.\n\n    Returns:\n        A colorized yaml string.\n    \"\"\"\n    return _highlight(text, YamlLexer())\n</code></pre>"},{"location":"api/m/core/","title":"core","text":""},{"location":"api/m/core/#m.core.Bad","title":"<code>Bad</code>","text":"<p>             Bases: <code>Generic[B, G]</code></p> <p>The bad side of the disjoint union.</p> Source code in <code>m/core/fp.py</code> <pre><code>class Bad(Generic[B, G]):\n    \"\"\"The bad side of the disjoint union.\"\"\"\n\n    value: B\n    is_bad = True\n\n    def __init__(self, value: B):\n        \"\"\"Initialize a `Bad` instance.\n\n        Args:\n            value: The \"bad\" value to store in the instance.\n        \"\"\"\n        self.value = value\n\n    def __iter__(self) -&gt; Iterator[G]:\n        \"\"\"Iterate over values of an instance.\n\n        The intention is to raise a `StopBadIteration` exception to\n        be able to break out of for loop comprehensions.\n\n        Raises:\n            StopBadIteration: If the instance has a \"Bad\" value.\n        \"\"\"\n        raise StopBadIteration(self)\n\n    def iter(self) -&gt; Iterator[G]:\n        \"\"\"Shortcut to transform to a list.\n\n        Can be used as `list(x.iter())`. It will either contain a value or be\n        an empty list.\n\n        Yields:\n            The value if the instance is a \"Good\" value.\n        \"\"\"\n        empty = ()\n        yield from empty\n\n    def get_or_else(self, default: LazyArg[G]) -&gt; G:\n        \"\"\"Return the value if its Good or the given argument if its a Bad.\n\n        Args:\n            default: The default value in case the instance is \"Bad\".\n\n        Returns:\n            Either the value or the default specified by \"default\".\n        \"\"\"\n        return lazy_arg(default)\n\n    def map(self, _fct: Callable[[G], K]) -&gt; 'Bad[B, K]':\n        \"\"\"Apply the function to its value if this is a `Good` instance.\n\n        Args:\n            _fct: The function to apply to the \"Good\" value.\n\n        Returns:\n            Itself if its a `Bad` otherwise another instance of `Good`.\n        \"\"\"\n        return cast(Bad[B, K], self)\n\n    def flat_map_bad(self, fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n        \"\"\"Apply the input function if this is a `Bad` value.\n\n        Args:\n            fct: The function to apply to the \"Bad\" value.\n\n        Returns:\n            Itself if its a `Good` otherwise another instance of `Bad`.\n        \"\"\"\n        return fct(self.value)\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.__init__","title":"<code>__init__(value)</code>","text":"<p>Initialize a <code>Bad</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>B</code> <p>The \"bad\" value to store in the instance.</p> required Source code in <code>m/core/fp.py</code> <pre><code>def __init__(self, value: B):\n    \"\"\"Initialize a `Bad` instance.\n\n    Args:\n        value: The \"bad\" value to store in the instance.\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over values of an instance.</p> <p>The intention is to raise a <code>StopBadIteration</code> exception to be able to break out of for loop comprehensions.</p> <p>Raises:</p> Type Description <code>StopBadIteration</code> <p>If the instance has a \"Bad\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def __iter__(self) -&gt; Iterator[G]:\n    \"\"\"Iterate over values of an instance.\n\n    The intention is to raise a `StopBadIteration` exception to\n    be able to break out of for loop comprehensions.\n\n    Raises:\n        StopBadIteration: If the instance has a \"Bad\" value.\n    \"\"\"\n    raise StopBadIteration(self)\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.flat_map_bad","title":"<code>flat_map_bad(fct)</code>","text":"<p>Apply the input function if this is a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>fct</code> <code>Callable[[B], OneOf[B, G]]</code> <p>The function to apply to the \"Bad\" value.</p> required <p>Returns:</p> Type Description <code>OneOf[B, G]</code> <p>Itself if its a <code>Good</code> otherwise another instance of <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def flat_map_bad(self, fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n    \"\"\"Apply the input function if this is a `Bad` value.\n\n    Args:\n        fct: The function to apply to the \"Bad\" value.\n\n    Returns:\n        Itself if its a `Good` otherwise another instance of `Bad`.\n    \"\"\"\n    return fct(self.value)\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.get_or_else","title":"<code>get_or_else(default)</code>","text":"<p>Return the value if its Good or the given argument if its a Bad.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>LazyArg[G]</code> <p>The default value in case the instance is \"Bad\".</p> required <p>Returns:</p> Type Description <code>G</code> <p>Either the value or the default specified by \"default\".</p> Source code in <code>m/core/fp.py</code> <pre><code>def get_or_else(self, default: LazyArg[G]) -&gt; G:\n    \"\"\"Return the value if its Good or the given argument if its a Bad.\n\n    Args:\n        default: The default value in case the instance is \"Bad\".\n\n    Returns:\n        Either the value or the default specified by \"default\".\n    \"\"\"\n    return lazy_arg(default)\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.iter","title":"<code>iter()</code>","text":"<p>Shortcut to transform to a list.</p> <p>Can be used as <code>list(x.iter())</code>. It will either contain a value or be an empty list.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value if the instance is a \"Good\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def iter(self) -&gt; Iterator[G]:\n    \"\"\"Shortcut to transform to a list.\n\n    Can be used as `list(x.iter())`. It will either contain a value or be\n    an empty list.\n\n    Yields:\n        The value if the instance is a \"Good\" value.\n    \"\"\"\n    empty = ()\n    yield from empty\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.map","title":"<code>map(_fct)</code>","text":"<p>Apply the function to its value if this is a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>_fct</code> <code>Callable[[G], K]</code> <p>The function to apply to the \"Good\" value.</p> required <p>Returns:</p> Type Description <code>'Bad[B, K]'</code> <p>Itself if its a <code>Bad</code> otherwise another instance of <code>Good</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def map(self, _fct: Callable[[G], K]) -&gt; 'Bad[B, K]':\n    \"\"\"Apply the function to its value if this is a `Good` instance.\n\n    Args:\n        _fct: The function to apply to the \"Good\" value.\n\n    Returns:\n        Itself if its a `Bad` otherwise another instance of `Good`.\n    \"\"\"\n    return cast(Bad[B, K], self)\n</code></pre>"},{"location":"api/m/core/#m.core.Good","title":"<code>Good</code>","text":"<p>             Bases: <code>Generic[B, G]</code></p> <p>The good side of the disjoint union.</p> Source code in <code>m/core/fp.py</code> <pre><code>class Good(Generic[B, G]):\n    \"\"\"The good side of the disjoint union.\"\"\"\n\n    value: G\n    is_bad = False\n\n    def __init__(self, value: G):\n        \"\"\"Initialize a `Good` instance.\n\n        Args:\n            value: The \"good\" value to store in the instance.\n        \"\"\"\n        self.value = value\n\n    def __iter__(self) -&gt; Iterator[G]:\n        \"\"\"Iterate over the value of the instance.\n\n        Yields:\n            The value of the instance.\n        \"\"\"\n        yield self.value\n\n    def iter(self) -&gt; Iterator[G]:\n        \"\"\"Shortcut to transform to a list.\n\n        Can be used as `list(x.iter())`. It will either contain a value or be\n        an empty list.\n\n        Yields:\n            The value if the instance is a \"Good\" value.\n        \"\"\"\n        if not self.is_bad:\n            yield self.value\n\n    def get_or_else(self, _default: LazyArg[G]) -&gt; G:\n        \"\"\"Return the value.\n\n        Args:\n            _default: The default value in case the instance is \"Bad\".\n\n        Returns:\n            Either the value or the default specified by \"default\".\n        \"\"\"\n        return self.value\n\n    def map(self, fct: Callable[[G], K]) -&gt; 'Good[B, K]':\n        \"\"\"Apply the function to its value if this is a `Good` instance.\n\n        Args:\n            fct: The function to apply to the \"Good\" value.\n\n        Returns:\n            Itself if its a `Bad` otherwise another instance of `Good`.\n        \"\"\"\n        return Good(fct(self.value))\n\n    def flat_map_bad(self, _fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n        \"\"\"Apply the input function if this is a `Bad` value.\n\n        Args:\n            _fct: The function to apply to the \"Bad\" value.\n\n        Returns:\n            Itself if its a `Good` otherwise another instance of `Bad`.\n        \"\"\"\n        return self\n</code></pre>"},{"location":"api/m/core/#m.core.Good.__init__","title":"<code>__init__(value)</code>","text":"<p>Initialize a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>G</code> <p>The \"good\" value to store in the instance.</p> required Source code in <code>m/core/fp.py</code> <pre><code>def __init__(self, value: G):\n    \"\"\"Initialize a `Good` instance.\n\n    Args:\n        value: The \"good\" value to store in the instance.\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"api/m/core/#m.core.Good.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the value of the instance.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value of the instance.</p> Source code in <code>m/core/fp.py</code> <pre><code>def __iter__(self) -&gt; Iterator[G]:\n    \"\"\"Iterate over the value of the instance.\n\n    Yields:\n        The value of the instance.\n    \"\"\"\n    yield self.value\n</code></pre>"},{"location":"api/m/core/#m.core.Good.flat_map_bad","title":"<code>flat_map_bad(_fct)</code>","text":"<p>Apply the input function if this is a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>_fct</code> <code>Callable[[B], OneOf[B, G]]</code> <p>The function to apply to the \"Bad\" value.</p> required <p>Returns:</p> Type Description <code>OneOf[B, G]</code> <p>Itself if its a <code>Good</code> otherwise another instance of <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def flat_map_bad(self, _fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n    \"\"\"Apply the input function if this is a `Bad` value.\n\n    Args:\n        _fct: The function to apply to the \"Bad\" value.\n\n    Returns:\n        Itself if its a `Good` otherwise another instance of `Bad`.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/m/core/#m.core.Good.get_or_else","title":"<code>get_or_else(_default)</code>","text":"<p>Return the value.</p> <p>Parameters:</p> Name Type Description Default <code>_default</code> <code>LazyArg[G]</code> <p>The default value in case the instance is \"Bad\".</p> required <p>Returns:</p> Type Description <code>G</code> <p>Either the value or the default specified by \"default\".</p> Source code in <code>m/core/fp.py</code> <pre><code>def get_or_else(self, _default: LazyArg[G]) -&gt; G:\n    \"\"\"Return the value.\n\n    Args:\n        _default: The default value in case the instance is \"Bad\".\n\n    Returns:\n        Either the value or the default specified by \"default\".\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"api/m/core/#m.core.Good.iter","title":"<code>iter()</code>","text":"<p>Shortcut to transform to a list.</p> <p>Can be used as <code>list(x.iter())</code>. It will either contain a value or be an empty list.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value if the instance is a \"Good\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def iter(self) -&gt; Iterator[G]:\n    \"\"\"Shortcut to transform to a list.\n\n    Can be used as `list(x.iter())`. It will either contain a value or be\n    an empty list.\n\n    Yields:\n        The value if the instance is a \"Good\" value.\n    \"\"\"\n    if not self.is_bad:\n        yield self.value\n</code></pre>"},{"location":"api/m/core/#m.core.Good.map","title":"<code>map(fct)</code>","text":"<p>Apply the function to its value if this is a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>fct</code> <code>Callable[[G], K]</code> <p>The function to apply to the \"Good\" value.</p> required <p>Returns:</p> Type Description <code>'Good[B, K]'</code> <p>Itself if its a <code>Bad</code> otherwise another instance of <code>Good</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def map(self, fct: Callable[[G], K]) -&gt; 'Good[B, K]':\n    \"\"\"Apply the function to its value if this is a `Good` instance.\n\n    Args:\n        fct: The function to apply to the \"Good\" value.\n\n    Returns:\n        Itself if its a `Bad` otherwise another instance of `Good`.\n    \"\"\"\n    return Good(fct(self.value))\n</code></pre>"},{"location":"api/m/core/#m.core.Issue","title":"<code>Issue</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Wrapper to keep track of all exceptions.</p> <p>It provides a 'cause' field so that we may know why an issue was triggered.</p> Source code in <code>m/core/issue.py</code> <pre><code>class Issue(Exception):  # noqa: N818, WPS230 - Intention is not to raise\n    \"\"\"Wrapper to keep track of all exceptions.\n\n    It provides a 'cause' field so that we may know why an issue was\n    triggered.\n    \"\"\"\n\n    show_traceback = True\n    yaml_traceback = True\n\n    message: str\n    description: str | None\n    cause: Exception | None\n    context: object | None\n    include_traceback: bool\n    cause_tb: list[str] | None\n    traceback: list[str] | None\n\n    def __init__(  # noqa: WPS211 - need to initialize the attributes\n        self,\n        message: str,\n        description: str | None = None,\n        cause: Exception | None = None,\n        context: object | None = None,\n        include_traceback: bool = True,\n    ):\n        \"\"\"Create an Issue.\n\n        Args:\n            message: Simple description of the issue.\n            description: More in depth detail on the issue\n            cause: The exception/Issue that is responsible for this instance.\n            context: Dictionary with any useful data related to the issue.\n            include_traceback: If False, it skips computing the traceback.\n        \"\"\"\n        super().__init__()\n        self.message = message\n        self.description = description\n        self.cause = cause\n        if cause and not isinstance(cause, Issue):\n            # https://stackoverflow.com/a/12539332/788553\n            with suppress(BaseException):\n                exc_info = sys.exc_info()\n                fmt_exception = (\n                    traceback.format_exception_only(exc_info[0], exc_info[1])\n                    if exc_info[0] is not None and exc_info[1] is not None\n                    else []\n                )\n                exception_list = [\n                    *traceback.format_tb(exc_info[2]),\n                    *fmt_exception,\n                ]\n                self.cause_tb = [\n                    y\n                    for x in exception_list\n                    for y in x.splitlines()\n                ]\n        self.context = context\n        self.include_traceback = include_traceback\n        self.traceback = None\n        if self.include_traceback:\n            frame = inspect.currentframe()\n            self.traceback = [\n                y\n                for x in traceback.format_stack(frame)[:-1]\n                for y in x.splitlines()\n            ]\n\n    def only_context(self) -&gt; bool:\n        \"\"\"Return true if the issue only offers context.\n\n        In some cases we may create an issue with only a message and a\n        context. This function will let us know of such case so that a\n        log formatter may be able to unwrap the context.\n\n        Returns:\n            True if it is safe to only display the context value on a log.\n        \"\"\"\n        has_context = self.context is not None\n        all_props = (self.description, self.traceback, self.cause)\n        return has_context and not [_ for _ in all_props if _]\n\n    def to_dict(self, show_traceback: bool = True) -&gt; IssueDict:\n        \"\"\"Convert to a ordered dictionary.\n\n        This is done so that each of the properties are written in an expected\n        order.\n\n        Args:\n            show_traceback: If False, it will remove all stacktraces.\n\n        Returns:\n            An `IssueDict` instance.\n        \"\"\"\n        issue_dict = cast(IssueDict, OrderedDict())\n        issue_dict['message'] = self.message\n        if self.description:\n            issue_dict['description'] = self.description\n        if self.context:\n            issue_dict['context'] = self.context\n        if self.include_traceback and self.traceback:\n            issue_dict['traceback'] = self.traceback\n            if Issue.yaml_traceback and isinstance(self.traceback, list):\n                issue_dict['traceback'] = _traceback_to_str(self.traceback)\n        if self.cause:\n            self._handle_cause(issue_dict)\n        if not show_traceback:\n            remove_traceback(issue_dict)\n        return issue_dict\n\n    def to_str(self, show_traceback: bool) -&gt; str:\n        \"\"\"Convert the instance to string.\n\n        Args:\n            show_traceback: If false, it will remove the error traceback.\n\n        Returns:\n            A string representation of the Issue instance.\n        \"\"\"\n        issue_dict = self.to_dict(show_traceback=show_traceback)\n        if Issue.yaml_traceback:\n            return yaml.dumps(issue_dict)\n        return json.dumps(issue_dict, indent=2)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Convert the instance to a string.\n\n        Returns:\n            A string representation of the Issue instance.\n        \"\"\"\n        issue_str = self.to_str(Issue.show_traceback)\n        if Issue.yaml_traceback:\n            return highlight_yaml(issue_str)\n        return highlight_json(issue_str)\n\n    def _handle_cause(self, issue_dict: IssueDict) -&gt; None:\n        if isinstance(self.cause, Issue):\n            issue_dict['cause'] = self.cause.to_dict()\n        else:\n            issue_dict['cause'] = {\n                'message': str(self.cause),\n                'traceback': self.cause_tb,\n            }\n            # I'm clearly assigning to a dict in the above statement...\n            # but it is an object so a dict can be assigned to it but that\n            # does not mean that we can use `pop` on an object. So we have to\n            # help mypy know that know we are dealing with a dict.\n            cause = cast(dict, issue_dict['cause'])\n            if not self.cause_tb:\n                cause.pop('traceback', None)\n            if Issue.yaml_traceback and isinstance(self.cause_tb, list):\n                cause['traceback'] = _traceback_to_str(self.cause_tb)\n</code></pre>"},{"location":"api/m/core/#m.core.Issue.__init__","title":"<code>__init__(message, description=None, cause=None, context=None, include_traceback=True)</code>","text":"<p>Create an Issue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Simple description of the issue.</p> required <code>description</code> <code>str | None</code> <p>More in depth detail on the issue</p> <code>None</code> <code>cause</code> <code>Exception | None</code> <p>The exception/Issue that is responsible for this instance.</p> <code>None</code> <code>context</code> <code>object | None</code> <p>Dictionary with any useful data related to the issue.</p> <code>None</code> <code>include_traceback</code> <code>bool</code> <p>If False, it skips computing the traceback.</p> <code>True</code> Source code in <code>m/core/issue.py</code> <pre><code>def __init__(  # noqa: WPS211 - need to initialize the attributes\n    self,\n    message: str,\n    description: str | None = None,\n    cause: Exception | None = None,\n    context: object | None = None,\n    include_traceback: bool = True,\n):\n    \"\"\"Create an Issue.\n\n    Args:\n        message: Simple description of the issue.\n        description: More in depth detail on the issue\n        cause: The exception/Issue that is responsible for this instance.\n        context: Dictionary with any useful data related to the issue.\n        include_traceback: If False, it skips computing the traceback.\n    \"\"\"\n    super().__init__()\n    self.message = message\n    self.description = description\n    self.cause = cause\n    if cause and not isinstance(cause, Issue):\n        # https://stackoverflow.com/a/12539332/788553\n        with suppress(BaseException):\n            exc_info = sys.exc_info()\n            fmt_exception = (\n                traceback.format_exception_only(exc_info[0], exc_info[1])\n                if exc_info[0] is not None and exc_info[1] is not None\n                else []\n            )\n            exception_list = [\n                *traceback.format_tb(exc_info[2]),\n                *fmt_exception,\n            ]\n            self.cause_tb = [\n                y\n                for x in exception_list\n                for y in x.splitlines()\n            ]\n    self.context = context\n    self.include_traceback = include_traceback\n    self.traceback = None\n    if self.include_traceback:\n        frame = inspect.currentframe()\n        self.traceback = [\n            y\n            for x in traceback.format_stack(frame)[:-1]\n            for y in x.splitlines()\n        ]\n</code></pre>"},{"location":"api/m/core/#m.core.Issue.__str__","title":"<code>__str__()</code>","text":"<p>Convert the instance to a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the Issue instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Convert the instance to a string.\n\n    Returns:\n        A string representation of the Issue instance.\n    \"\"\"\n    issue_str = self.to_str(Issue.show_traceback)\n    if Issue.yaml_traceback:\n        return highlight_yaml(issue_str)\n    return highlight_json(issue_str)\n</code></pre>"},{"location":"api/m/core/#m.core.Issue.only_context","title":"<code>only_context()</code>","text":"<p>Return true if the issue only offers context.</p> <p>In some cases we may create an issue with only a message and a context. This function will let us know of such case so that a log formatter may be able to unwrap the context.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if it is safe to only display the context value on a log.</p> Source code in <code>m/core/issue.py</code> <pre><code>def only_context(self) -&gt; bool:\n    \"\"\"Return true if the issue only offers context.\n\n    In some cases we may create an issue with only a message and a\n    context. This function will let us know of such case so that a\n    log formatter may be able to unwrap the context.\n\n    Returns:\n        True if it is safe to only display the context value on a log.\n    \"\"\"\n    has_context = self.context is not None\n    all_props = (self.description, self.traceback, self.cause)\n    return has_context and not [_ for _ in all_props if _]\n</code></pre>"},{"location":"api/m/core/#m.core.Issue.to_dict","title":"<code>to_dict(show_traceback=True)</code>","text":"<p>Convert to a ordered dictionary.</p> <p>This is done so that each of the properties are written in an expected order.</p> <p>Parameters:</p> Name Type Description Default <code>show_traceback</code> <code>bool</code> <p>If False, it will remove all stacktraces.</p> <code>True</code> <p>Returns:</p> Type Description <code>IssueDict</code> <p>An <code>IssueDict</code> instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def to_dict(self, show_traceback: bool = True) -&gt; IssueDict:\n    \"\"\"Convert to a ordered dictionary.\n\n    This is done so that each of the properties are written in an expected\n    order.\n\n    Args:\n        show_traceback: If False, it will remove all stacktraces.\n\n    Returns:\n        An `IssueDict` instance.\n    \"\"\"\n    issue_dict = cast(IssueDict, OrderedDict())\n    issue_dict['message'] = self.message\n    if self.description:\n        issue_dict['description'] = self.description\n    if self.context:\n        issue_dict['context'] = self.context\n    if self.include_traceback and self.traceback:\n        issue_dict['traceback'] = self.traceback\n        if Issue.yaml_traceback and isinstance(self.traceback, list):\n            issue_dict['traceback'] = _traceback_to_str(self.traceback)\n    if self.cause:\n        self._handle_cause(issue_dict)\n    if not show_traceback:\n        remove_traceback(issue_dict)\n    return issue_dict\n</code></pre>"},{"location":"api/m/core/#m.core.Issue.to_str","title":"<code>to_str(show_traceback)</code>","text":"<p>Convert the instance to string.</p> <p>Parameters:</p> Name Type Description Default <code>show_traceback</code> <code>bool</code> <p>If false, it will remove the error traceback.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the Issue instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def to_str(self, show_traceback: bool) -&gt; str:\n    \"\"\"Convert the instance to string.\n\n    Args:\n        show_traceback: If false, it will remove the error traceback.\n\n    Returns:\n        A string representation of the Issue instance.\n    \"\"\"\n    issue_dict = self.to_dict(show_traceback=show_traceback)\n    if Issue.yaml_traceback:\n        return yaml.dumps(issue_dict)\n    return json.dumps(issue_dict, indent=2)\n</code></pre>"},{"location":"api/m/core/#m.core.hone","title":"<code>hone(msg, context=None, description=None, include_traceback=True)</code>","text":"<p>Create a function to repackage the issue with a new message and context.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The new message.</p> required <code>context</code> <code>object | None</code> <p>The new context.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>The new description.</p> <code>None</code> <code>include_traceback</code> <code>bool</code> <p>Whether to include the traceback.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[[Issue], OneOf[Issue, Any]]</code> <p>A function that takes an issue and returns a new issue.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def hone(\n    msg: str,\n    context: object | None = None,\n    description: str | None = None,\n    include_traceback: bool = True,\n) -&gt; Callable[[Issue], OneOf[Issue, Any]]:\n    \"\"\"Create a function to repackage the issue with a new message and context.\n\n    Args:\n        msg: The new message.\n        context: The new context.\n        description: The new description.\n        include_traceback: Whether to include the traceback.\n\n    Returns:\n        A function that takes an issue and returns a new issue.\n    \"\"\"\n    return partial(_hone, msg, context, description, include_traceback)\n</code></pre>"},{"location":"api/m/core/#m.core.is_bad","title":"<code>is_bad(inst)</code>","text":"<p>Assert that a OneOf instance is a <code>Bad</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>OneOf[B, G]</code> <p>The <code>OneOf</code> instance.</p> required <p>Returns:</p> Type Description <code>TypeGuard[Bad[B, G]]</code> <p>True if the instance is a <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `is_bad` type guard is deprecated; use `isinstance(inst, Bad)` instead.',\n)\ndef is_bad(inst: OneOf[B, G]) -&gt; TypeGuard[Bad[B, G]]:\n    \"\"\"Assert that a OneOf instance is a `Bad`.\n\n    Args:\n        inst: The `OneOf` instance.\n\n    Returns:\n        True if the instance is a `Bad`.\n    \"\"\"\n    # `m` does not reference this function anymore, excluding from coverage\n    return isinstance(inst, Bad)  # pragma: no cover\n</code></pre>"},{"location":"api/m/core/#m.core.non_issue","title":"<code>non_issue(inst)</code>","text":"<p>Obtain the value of the <code>OneOf</code> as if it was a Good value.</p> <p>Warning: This should only be used provided that we know for sure that we are not dealing with a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>OneOf[Issue, G]</code> <p>A OneOf.</p> required <p>Returns:</p> Type Description <code>G</code> <p>The value stored in the OneOf.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def non_issue(inst: OneOf[Issue, G]) -&gt; G:\n    \"\"\"Obtain the value of the `OneOf` as if it was a Good value.\n\n    Warning: This should only be used provided that we know for sure\n    that we are not dealing with a `Bad` value.\n\n    Args:\n        inst: A OneOf.\n\n    Returns:\n        The value stored in the OneOf.\n    \"\"\"\n    # The assert statement can go away with the -O flag.\n    assert not inst.is_bad  # noqa: S101\n    return cast(G, inst.value)\n</code></pre>"},{"location":"api/m/core/fp/","title":"fp","text":""},{"location":"api/m/core/fp/#m.core.fp.Bad","title":"<code>Bad</code>","text":"<p>             Bases: <code>Generic[B, G]</code></p> <p>The bad side of the disjoint union.</p> Source code in <code>m/core/fp.py</code> <pre><code>class Bad(Generic[B, G]):\n    \"\"\"The bad side of the disjoint union.\"\"\"\n\n    value: B\n    is_bad = True\n\n    def __init__(self, value: B):\n        \"\"\"Initialize a `Bad` instance.\n\n        Args:\n            value: The \"bad\" value to store in the instance.\n        \"\"\"\n        self.value = value\n\n    def __iter__(self) -&gt; Iterator[G]:\n        \"\"\"Iterate over values of an instance.\n\n        The intention is to raise a `StopBadIteration` exception to\n        be able to break out of for loop comprehensions.\n\n        Raises:\n            StopBadIteration: If the instance has a \"Bad\" value.\n        \"\"\"\n        raise StopBadIteration(self)\n\n    def iter(self) -&gt; Iterator[G]:\n        \"\"\"Shortcut to transform to a list.\n\n        Can be used as `list(x.iter())`. It will either contain a value or be\n        an empty list.\n\n        Yields:\n            The value if the instance is a \"Good\" value.\n        \"\"\"\n        empty = ()\n        yield from empty\n\n    def get_or_else(self, default: LazyArg[G]) -&gt; G:\n        \"\"\"Return the value if its Good or the given argument if its a Bad.\n\n        Args:\n            default: The default value in case the instance is \"Bad\".\n\n        Returns:\n            Either the value or the default specified by \"default\".\n        \"\"\"\n        return lazy_arg(default)\n\n    def map(self, _fct: Callable[[G], K]) -&gt; 'Bad[B, K]':\n        \"\"\"Apply the function to its value if this is a `Good` instance.\n\n        Args:\n            _fct: The function to apply to the \"Good\" value.\n\n        Returns:\n            Itself if its a `Bad` otherwise another instance of `Good`.\n        \"\"\"\n        return cast(Bad[B, K], self)\n\n    def flat_map_bad(self, fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n        \"\"\"Apply the input function if this is a `Bad` value.\n\n        Args:\n            fct: The function to apply to the \"Bad\" value.\n\n        Returns:\n            Itself if its a `Good` otherwise another instance of `Bad`.\n        \"\"\"\n        return fct(self.value)\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.__init__","title":"<code>__init__(value)</code>","text":"<p>Initialize a <code>Bad</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>B</code> <p>The \"bad\" value to store in the instance.</p> required Source code in <code>m/core/fp.py</code> <pre><code>def __init__(self, value: B):\n    \"\"\"Initialize a `Bad` instance.\n\n    Args:\n        value: The \"bad\" value to store in the instance.\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over values of an instance.</p> <p>The intention is to raise a <code>StopBadIteration</code> exception to be able to break out of for loop comprehensions.</p> <p>Raises:</p> Type Description <code>StopBadIteration</code> <p>If the instance has a \"Bad\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def __iter__(self) -&gt; Iterator[G]:\n    \"\"\"Iterate over values of an instance.\n\n    The intention is to raise a `StopBadIteration` exception to\n    be able to break out of for loop comprehensions.\n\n    Raises:\n        StopBadIteration: If the instance has a \"Bad\" value.\n    \"\"\"\n    raise StopBadIteration(self)\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.flat_map_bad","title":"<code>flat_map_bad(fct)</code>","text":"<p>Apply the input function if this is a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>fct</code> <code>Callable[[B], OneOf[B, G]]</code> <p>The function to apply to the \"Bad\" value.</p> required <p>Returns:</p> Type Description <code>OneOf[B, G]</code> <p>Itself if its a <code>Good</code> otherwise another instance of <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def flat_map_bad(self, fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n    \"\"\"Apply the input function if this is a `Bad` value.\n\n    Args:\n        fct: The function to apply to the \"Bad\" value.\n\n    Returns:\n        Itself if its a `Good` otherwise another instance of `Bad`.\n    \"\"\"\n    return fct(self.value)\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.get_or_else","title":"<code>get_or_else(default)</code>","text":"<p>Return the value if its Good or the given argument if its a Bad.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>LazyArg[G]</code> <p>The default value in case the instance is \"Bad\".</p> required <p>Returns:</p> Type Description <code>G</code> <p>Either the value or the default specified by \"default\".</p> Source code in <code>m/core/fp.py</code> <pre><code>def get_or_else(self, default: LazyArg[G]) -&gt; G:\n    \"\"\"Return the value if its Good or the given argument if its a Bad.\n\n    Args:\n        default: The default value in case the instance is \"Bad\".\n\n    Returns:\n        Either the value or the default specified by \"default\".\n    \"\"\"\n    return lazy_arg(default)\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.iter","title":"<code>iter()</code>","text":"<p>Shortcut to transform to a list.</p> <p>Can be used as <code>list(x.iter())</code>. It will either contain a value or be an empty list.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value if the instance is a \"Good\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def iter(self) -&gt; Iterator[G]:\n    \"\"\"Shortcut to transform to a list.\n\n    Can be used as `list(x.iter())`. It will either contain a value or be\n    an empty list.\n\n    Yields:\n        The value if the instance is a \"Good\" value.\n    \"\"\"\n    empty = ()\n    yield from empty\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.map","title":"<code>map(_fct)</code>","text":"<p>Apply the function to its value if this is a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>_fct</code> <code>Callable[[G], K]</code> <p>The function to apply to the \"Good\" value.</p> required <p>Returns:</p> Type Description <code>'Bad[B, K]'</code> <p>Itself if its a <code>Bad</code> otherwise another instance of <code>Good</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def map(self, _fct: Callable[[G], K]) -&gt; 'Bad[B, K]':\n    \"\"\"Apply the function to its value if this is a `Good` instance.\n\n    Args:\n        _fct: The function to apply to the \"Good\" value.\n\n    Returns:\n        Itself if its a `Bad` otherwise another instance of `Good`.\n    \"\"\"\n    return cast(Bad[B, K], self)\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good","title":"<code>Good</code>","text":"<p>             Bases: <code>Generic[B, G]</code></p> <p>The good side of the disjoint union.</p> Source code in <code>m/core/fp.py</code> <pre><code>class Good(Generic[B, G]):\n    \"\"\"The good side of the disjoint union.\"\"\"\n\n    value: G\n    is_bad = False\n\n    def __init__(self, value: G):\n        \"\"\"Initialize a `Good` instance.\n\n        Args:\n            value: The \"good\" value to store in the instance.\n        \"\"\"\n        self.value = value\n\n    def __iter__(self) -&gt; Iterator[G]:\n        \"\"\"Iterate over the value of the instance.\n\n        Yields:\n            The value of the instance.\n        \"\"\"\n        yield self.value\n\n    def iter(self) -&gt; Iterator[G]:\n        \"\"\"Shortcut to transform to a list.\n\n        Can be used as `list(x.iter())`. It will either contain a value or be\n        an empty list.\n\n        Yields:\n            The value if the instance is a \"Good\" value.\n        \"\"\"\n        if not self.is_bad:\n            yield self.value\n\n    def get_or_else(self, _default: LazyArg[G]) -&gt; G:\n        \"\"\"Return the value.\n\n        Args:\n            _default: The default value in case the instance is \"Bad\".\n\n        Returns:\n            Either the value or the default specified by \"default\".\n        \"\"\"\n        return self.value\n\n    def map(self, fct: Callable[[G], K]) -&gt; 'Good[B, K]':\n        \"\"\"Apply the function to its value if this is a `Good` instance.\n\n        Args:\n            fct: The function to apply to the \"Good\" value.\n\n        Returns:\n            Itself if its a `Bad` otherwise another instance of `Good`.\n        \"\"\"\n        return Good(fct(self.value))\n\n    def flat_map_bad(self, _fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n        \"\"\"Apply the input function if this is a `Bad` value.\n\n        Args:\n            _fct: The function to apply to the \"Bad\" value.\n\n        Returns:\n            Itself if its a `Good` otherwise another instance of `Bad`.\n        \"\"\"\n        return self\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.__init__","title":"<code>__init__(value)</code>","text":"<p>Initialize a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>G</code> <p>The \"good\" value to store in the instance.</p> required Source code in <code>m/core/fp.py</code> <pre><code>def __init__(self, value: G):\n    \"\"\"Initialize a `Good` instance.\n\n    Args:\n        value: The \"good\" value to store in the instance.\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the value of the instance.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value of the instance.</p> Source code in <code>m/core/fp.py</code> <pre><code>def __iter__(self) -&gt; Iterator[G]:\n    \"\"\"Iterate over the value of the instance.\n\n    Yields:\n        The value of the instance.\n    \"\"\"\n    yield self.value\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.flat_map_bad","title":"<code>flat_map_bad(_fct)</code>","text":"<p>Apply the input function if this is a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>_fct</code> <code>Callable[[B], OneOf[B, G]]</code> <p>The function to apply to the \"Bad\" value.</p> required <p>Returns:</p> Type Description <code>OneOf[B, G]</code> <p>Itself if its a <code>Good</code> otherwise another instance of <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def flat_map_bad(self, _fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n    \"\"\"Apply the input function if this is a `Bad` value.\n\n    Args:\n        _fct: The function to apply to the \"Bad\" value.\n\n    Returns:\n        Itself if its a `Good` otherwise another instance of `Bad`.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.get_or_else","title":"<code>get_or_else(_default)</code>","text":"<p>Return the value.</p> <p>Parameters:</p> Name Type Description Default <code>_default</code> <code>LazyArg[G]</code> <p>The default value in case the instance is \"Bad\".</p> required <p>Returns:</p> Type Description <code>G</code> <p>Either the value or the default specified by \"default\".</p> Source code in <code>m/core/fp.py</code> <pre><code>def get_or_else(self, _default: LazyArg[G]) -&gt; G:\n    \"\"\"Return the value.\n\n    Args:\n        _default: The default value in case the instance is \"Bad\".\n\n    Returns:\n        Either the value or the default specified by \"default\".\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.iter","title":"<code>iter()</code>","text":"<p>Shortcut to transform to a list.</p> <p>Can be used as <code>list(x.iter())</code>. It will either contain a value or be an empty list.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value if the instance is a \"Good\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def iter(self) -&gt; Iterator[G]:\n    \"\"\"Shortcut to transform to a list.\n\n    Can be used as `list(x.iter())`. It will either contain a value or be\n    an empty list.\n\n    Yields:\n        The value if the instance is a \"Good\" value.\n    \"\"\"\n    if not self.is_bad:\n        yield self.value\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.map","title":"<code>map(fct)</code>","text":"<p>Apply the function to its value if this is a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>fct</code> <code>Callable[[G], K]</code> <p>The function to apply to the \"Good\" value.</p> required <p>Returns:</p> Type Description <code>'Good[B, K]'</code> <p>Itself if its a <code>Bad</code> otherwise another instance of <code>Good</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def map(self, fct: Callable[[G], K]) -&gt; 'Good[B, K]':\n    \"\"\"Apply the function to its value if this is a `Good` instance.\n\n    Args:\n        fct: The function to apply to the \"Good\" value.\n\n    Returns:\n        Itself if its a `Bad` otherwise another instance of `Good`.\n    \"\"\"\n    return Good(fct(self.value))\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.StopBadIteration","title":"<code>StopBadIteration</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Store a <code>Bad</code> instance.</p> Source code in <code>m/core/fp.py</code> <pre><code>class StopBadIteration(Exception):  # noqa: N818 - This is for internal use\n    \"\"\"Store a `Bad` instance.\"\"\"\n\n    def __init__(self, bad: Any):\n        \"\"\"Initialize the Exception.\n\n        Args:\n            bad: The `Bad` value stored in a `OneOf`.\n        \"\"\"\n        super().__init__()\n        self.bad = bad\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.StopBadIteration.__init__","title":"<code>__init__(bad)</code>","text":"<p>Initialize the Exception.</p> <p>Parameters:</p> Name Type Description Default <code>bad</code> <code>Any</code> <p>The <code>Bad</code> value stored in a <code>OneOf</code>.</p> required Source code in <code>m/core/fp.py</code> <pre><code>def __init__(self, bad: Any):\n    \"\"\"Initialize the Exception.\n\n    Args:\n        bad: The `Bad` value stored in a `OneOf`.\n    \"\"\"\n    super().__init__()\n    self.bad = bad\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.is_bad","title":"<code>is_bad(inst)</code>","text":"<p>Assert that a OneOf instance is a <code>Bad</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>OneOf[B, G]</code> <p>The <code>OneOf</code> instance.</p> required <p>Returns:</p> Type Description <code>TypeGuard[Bad[B, G]]</code> <p>True if the instance is a <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `is_bad` type guard is deprecated; use `isinstance(inst, Bad)` instead.',\n)\ndef is_bad(inst: OneOf[B, G]) -&gt; TypeGuard[Bad[B, G]]:\n    \"\"\"Assert that a OneOf instance is a `Bad`.\n\n    Args:\n        inst: The `OneOf` instance.\n\n    Returns:\n        True if the instance is a `Bad`.\n    \"\"\"\n    # `m` does not reference this function anymore, excluding from coverage\n    return isinstance(inst, Bad)  # pragma: no cover\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.is_good","title":"<code>is_good(inst)</code>","text":"<p>Assert that a OneOf instance is a <code>Good</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>OneOf[B, G]</code> <p>The <code>OneOf</code> instance.</p> required <p>Returns:</p> Type Description <code>TypeGuard[Good[B, G]]</code> <p>True if the instance is a <code>Good</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `is_good` type guard is deprecated; use `isinstance(inst, Good)` instead.',\n)\ndef is_good(inst: OneOf[B, G]) -&gt; TypeGuard[Good[B, G]]:\n    \"\"\"Assert that a OneOf instance is a `Good`.\n\n    Args:\n        inst: The `OneOf` instance.\n\n    Returns:\n        True if the instance is a `Good`.\n    \"\"\"\n    # `m` does not reference this function anymore, excluding from coverage\n    return isinstance(inst, Good)  # pragma: no cover\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.lazy_arg","title":"<code>lazy_arg(z_arg)</code>","text":"<p>Return the output of calling <code>z_arg</code> if it is function.</p> <p>Otherwise param is returned.</p> <p>Parameters:</p> Name Type Description Default <code>z_arg</code> <code>LazyArg[A]</code> <p>A function or a value</p> required <p>Returns:</p> Type Description <code>A</code> <p>The value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def lazy_arg(z_arg: LazyArg[A]) -&gt; A:\n    \"\"\"Return the output of calling `z_arg` if it is function.\n\n    Otherwise param is returned.\n\n    Args:\n        z_arg: A function or a value\n\n    Returns:\n        The value.\n    \"\"\"\n    return z_arg() if callable(z_arg) else z_arg\n</code></pre>"},{"location":"api/m/core/http/","title":"http","text":""},{"location":"api/m/core/http/#m.core.http.FetchedResponse","title":"<code>FetchedResponse</code>  <code>dataclass</code>","text":"<p>Result object for fetch_response.</p> Source code in <code>m/core/http.py</code> <pre><code>@dataclass\nclass FetchedResponse:\n    \"\"\"Result object for fetch_response.\"\"\"\n\n    response: httplib.HTTPResponse\n    body: str\n</code></pre>"},{"location":"api/m/core/http/#m.core.http.HttpMethod","title":"<code>HttpMethod</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Python 3.10 does not have this enum.</p> <p>https://docs.python.org/3/library/http.html#http-methods</p> Source code in <code>m/core/http.py</code> <pre><code>class HttpMethod(str, Enum):  # noqa: WPS600\n    \"\"\"Python 3.10 does not have this enum.\n\n    https://docs.python.org/3/library/http.html#http-methods\n    \"\"\"\n\n    get = 'GET'\n    post = 'POST'\n    put = 'PUT'\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the value of the enum.\n\n        Returns:\n            The value of the enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"api/m/core/http/#m.core.http.HttpMethod.__str__","title":"<code>__str__()</code>","text":"<p>Return the value of the enum.</p> <p>Returns:</p> Type Description <code>str</code> <p>The value of the enum.</p> Source code in <code>m/core/http.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the value of the enum.\n\n    Returns:\n        The value of the enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"api/m/core/http/#m.core.http.fetch","title":"<code>fetch(url, headers, method=HttpMethod.get, body=None)</code>","text":"<p>Send an http(s) request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to request.</p> required <code>headers</code> <code>Mapping[str, str]</code> <p>The headers for the request. By default it sets the <code>user-agent</code> to \"m\".</p> required <code>method</code> <code>HttpMethod</code> <p>The request method type. Defaults to <code>GET</code>.</p> <code>get</code> <code>body</code> <code>Optional[str]</code> <p>The body of the request.</p> <code>None</code> <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>A <code>OneOf</code> containing the raw response from the server or an Issue.</p> Source code in <code>m/core/http.py</code> <pre><code>def fetch(\n    url: str,\n    headers: Mapping[str, str],\n    method: HttpMethod = HttpMethod.get,\n    body: Optional[str] = None,\n) -&gt; OneOf[Issue, str]:\n    \"\"\"Send an http(s) request.\n\n    Args:\n        url:\n            The url to request.\n        headers:\n            The headers for the request. By default it sets the `user-agent`\n            to \"m\".\n        method:\n            The request method type. Defaults to `GET`.\n        body:\n            The body of the request.\n\n    Returns:\n        A `OneOf` containing the raw response from the server or an Issue.\n    \"\"\"\n    return one_of(lambda: [\n        fetch_res.body\n        for fetch_res in fetch_response(url, headers, method, body)\n    ])\n</code></pre>"},{"location":"api/m/core/http/#m.core.http.fetch_json","title":"<code>fetch_json(url, headers, method=HttpMethod.get, body_json=None)</code>","text":"<p>Specialized fetch to deal with json data.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to request.</p> required <code>headers</code> <code>Mapping[str, str]</code> <p>Additional headers for the request. By default it will add proper accept and content-type headers for json requests.</p> required <code>method</code> <code>HttpMethod</code> <p>The request method type. Defaults to <code>GET</code>.</p> <code>get</code> <code>body_json</code> <code>Any</code> <p>The data to send to the server (python object).</p> <code>None</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>OneOf</code> containing a json parsed response from the server or an</p> <code>OneOf[Issue, Any]</code> <p>Issue.</p> Source code in <code>m/core/http.py</code> <pre><code>def fetch_json(\n    url: str,\n    headers: Mapping[str, str],\n    method: HttpMethod = HttpMethod.get,\n    body_json: Any = None,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Specialized fetch to deal with json data.\n\n    Args:\n        url:\n            The url to request.\n        headers:\n            Additional headers for the request. By default it will add\n            proper accept and content-type headers for json requests.\n        method:\n            The request method type. Defaults to `GET`.\n        body_json:\n            The data to send to the server (python object).\n\n    Returns:\n        A `OneOf` containing a json parsed response from the server or an\n        Issue.\n    \"\"\"\n    body = builtin_json.dumps(body_json) if body_json else None\n    fetch_headers = {\n        'accept': 'application/json',\n        'content-type': 'application/json',\n        **headers,\n    }\n    return one_of(lambda: [\n        response\n        for payload in fetch(url, fetch_headers, method, body)\n        for response in parse_json(payload)\n    ])\n</code></pre>"},{"location":"api/m/core/http/#m.core.http.fetch_response","title":"<code>fetch_response(url, headers, method=HttpMethod.get, body=None)</code>","text":"<p>Send an http(s) request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to request.</p> required <code>headers</code> <code>Mapping[str, str]</code> <p>The headers for the request. By default it sets the <code>user-agent</code> to \"m\".</p> required <code>method</code> <code>HttpMethod</code> <p>The request method type. Defaults to <code>GET</code>.</p> <code>get</code> <code>body</code> <code>Optional[str]</code> <p>The body of the request.</p> <code>None</code> <p>Returns:</p> Type Description <code>OneOf[Issue, FetchedResponse]</code> <p>A <code>OneOf</code> containing the response object from the server or an Issue.</p> Source code in <code>m/core/http.py</code> <pre><code>def fetch_response(\n    url: str,\n    headers: Mapping[str, str],\n    method: HttpMethod = HttpMethod.get,\n    body: Optional[str] = None,\n) -&gt; OneOf[Issue, FetchedResponse]:\n    \"\"\"Send an http(s) request.\n\n    Args:\n        url:\n            The url to request.\n        headers:\n            The headers for the request. By default it sets the `user-agent`\n            to \"m\".\n        method:\n            The request method type. Defaults to `GET`.\n        body:\n            The body of the request.\n\n    Returns:\n        A `OneOf` containing the response object from the server or an Issue.\n    \"\"\"\n    parts = urlparse(url)\n    protocol, hostname, path = [parts.scheme, parts.netloc, parts.path]\n    path = f'{path}?{parts.query}' if parts.query else path\n    fetch_headers = {'user-agent': 'm', **headers}\n    ctxt: dict[str, str] = {'url': f'{hostname}{path}', 'method': f'{method}'}\n    if body:\n        fetch_headers['content-length'] = str(len(body))\n        if 'DEBUG_HTTP_INCLUDE_BODY' in os.environ:\n            ctxt['body'] = body\n    connection = _get_connection(protocol, hostname)\n    # See the next link for explanation disabling WPS440:\n    #  https://github.com/wemake-services/wemake-python-styleguide/issues/1416\n    try:\n        connection.request(f'{method}', path, body, fetch_headers)\n    except Exception as ex:\n        return issue(f'{protocol} request failure', cause=ex, context=ctxt)\n    try:\n        res = connection.getresponse()\n    except Exception as ex:  # noqa: WPS440\n        return issue(f'{protocol} response failure', cause=ex, context=ctxt)\n    try:\n        res_body = res.read().decode()\n    except Exception as ex:  # noqa: WPS440\n        return issue(f'{protocol} read failure', cause=ex, context=ctxt)\n    code = res.getcode()\n    if HTTPStatus.OK &lt;= code &lt; HTTPStatus.MULTIPLE_CHOICES:\n        return Good(FetchedResponse(\n            response=res,\n            body=res_body,\n        ))\n    return issue(\n        f'{protocol} request failure ({code})',\n        context={\n            'body': body,\n            'code': code,\n            'res_body': res_body,\n            **ctxt,\n        },\n    )\n</code></pre>"},{"location":"api/m/core/io/","title":"io","text":""},{"location":"api/m/core/io/#m.core.io.env","title":"<code>env(name, def_val='')</code>","text":"<p>Access an environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the environment variable.</p> required <code>def_val</code> <code>str</code> <p>The default value to return if not set. Defaults to empty.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The value of the environment variable if set otherwise the <code>def_val</code>.</p> Source code in <code>m/core/io.py</code> <pre><code>def env(name: str, def_val: str = '') -&gt; str:\n    \"\"\"Access an environment variable.\n\n    Args:\n        name: The name of the environment variable.\n        def_val: The default value to return if not set. Defaults to empty.\n\n    Returns:\n        The value of the environment variable if set otherwise the `def_val`.\n    \"\"\"\n    return os.environ.get(name, def_val)\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.env_model","title":"<code>env_model(model)</code>","text":"<p>Require multiple env vars to be defined.</p> <p>This can be done by defining a model::</p> <pre><code>class GithubEnvVars(BaseModel):\n    repo: str = Field('GITHUB_REPOSITORY')\n    run_id: str = Field('GITHUB_RUN_ID')\n</code></pre> <p>Then we use it::</p> <pre><code>print(env.repo for env in env_model(GithubEnvVars)])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[BaseModelT]</code> <p>A pydantic model specifying the environment variables to fetch.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, BaseModelT]</code> <p>A <code>OneOf</code> with the values of the environment variables or an issue.</p> Source code in <code>m/core/io.py</code> <pre><code>def env_model(model: type[BaseModelT]) -&gt; OneOf[Issue, BaseModelT]:\n    \"\"\"Require multiple env vars to be defined.\n\n    This can be done by defining a model::\n\n        class GithubEnvVars(BaseModel):\n            repo: str = Field('GITHUB_REPOSITORY')\n            run_id: str = Field('GITHUB_RUN_ID')\n\n    Then we use it::\n\n        print(env.repo for env in env_model(GithubEnvVars)])\n\n    Args:\n        model: A pydantic model specifying the environment variables to fetch.\n\n    Returns:\n        A `OneOf` with the values of the environment variables or an issue.\n    \"\"\"\n    schema = model.model_json_schema()\n    missing: list[str] = []\n    env_values: dict[str, str] = {}\n    for name, field in schema['properties'].items():\n        env_name = field.get('default')\n        env_value = os.environ.get(env_name)\n        if env_value is None:\n            missing.append(env_name)\n        else:\n            env_values[name] = env_value\n    if missing:\n        missing_str = ', '.join(missing)\n        return issue(f'missing [{missing_str}] in env')\n    return Good(model(**env_values))\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.format_seconds","title":"<code>format_seconds(number_of_seconds)</code>","text":"<p>Return a string representing the number of seconds.</p> <p>The format is Xd:Xh:Xm:Xs:Xms.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_seconds</code> <code>int | float</code> <p>The number of seconds to format.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A friendly representation of the number of seconds.</p> Source code in <code>m/core/io.py</code> <pre><code>def format_seconds(number_of_seconds: int | float) -&gt; str:\n    \"\"\"Return a string representing the number of seconds.\n\n    The format is Xd:Xh:Xm:Xs:Xms.\n\n    Args:\n        number_of_seconds: The number of seconds to format.\n\n    Returns:\n        A friendly representation of the number of seconds.\n    \"\"\"\n    milliseconds = int(math.floor(number_of_seconds * 1000))\n    milli_sec = milliseconds % 1000\n    seconds = int(math.floor(milliseconds / 1000))\n    sec = seconds % 60\n    minutes = int(math.floor(seconds / 60))\n    mins = minutes % 60\n    hours = int(math.floor(minutes / 60))\n    hrs = hours % 24\n    days = int(math.floor(hours / 24))\n\n    entries = [\n        f'{days}d' if days else '',\n        f'{hrs}h' if hours else '',\n        f'{mins}m' if mins else '',\n        f'{sec}s' if sec else '',\n        f'{milli_sec}ms' if milli_sec else '',\n    ]\n    return ':'.join([x for x in entries if x]) or '0s'\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.is_python_info_enabled","title":"<code>is_python_info_enabled()</code>","text":"<p>Return True if the python file location should be displayed.</p> <p>By default this information is not displayed since the stacktrace already provides most of the info. If we need it we can set one of the env var</p> <ul> <li>DEBUG_M_PYTHON</li> <li>DEBUG</li> </ul> <p><code>DEBUG_M_PYTHON</code> is accepted in case we do not want to enable the traceback.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the python file location should be displayed.</p> Source code in <code>m/core/io.py</code> <pre><code>def is_python_info_enabled() -&gt; bool:\n    \"\"\"Return True if the python file location should be displayed.\n\n    By default this information is not displayed since the stacktrace already\n    provides most of the info. If we need it we can set one of the env var\n\n    - DEBUG_M_PYTHON\n    - DEBUG\n\n    `DEBUG_M_PYTHON` is accepted in case we do not want to enable the\n    traceback.\n\n    Returns:\n        True if the python file location should be displayed.\n    \"\"\"\n    debug_python = _is_true('DEBUG_M_PYTHON')\n    debug_mode = _is_true('DEBUG')\n    return debug_python or debug_mode\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.is_traceback_enabled","title":"<code>is_traceback_enabled()</code>","text":"<p>Return True if the stacktrace should be displayed.</p> <p>This is true by default on a CI environment where the env var CI is set to <code>true</code>.</p> <p>We can enable this locally by settings the env vars</p> <ul> <li>DEBUG_M_STACKTRACE</li> <li>DEBUG</li> </ul> <p>The <code>DEBUG_M_STACKTRACE</code> is provided so to only target this particular piece of info and avoid other pieces of code that may be looking at the <code>DEBUG</code> env var from activating.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the stacktrace should be displayed.</p> Source code in <code>m/core/io.py</code> <pre><code>def is_traceback_enabled() -&gt; bool:\n    \"\"\"Return True if the stacktrace should be displayed.\n\n    This is true by default on a CI environment where the env var CI is set\n    to `true`.\n\n    We can enable this locally by settings the env vars\n\n    - DEBUG_M_STACKTRACE\n    - DEBUG\n\n    The `DEBUG_M_STACKTRACE` is provided so to only target this particular\n    piece of info and avoid other pieces of code that may be looking at\n    the `DEBUG` env var from activating.\n\n    Returns:\n        True if the stacktrace should be displayed.\n    \"\"\"\n    debug_stacktrace = _is_true('DEBUG_M_STACKTRACE')\n    debug_mode = _is_true('DEBUG')\n    ci_env = _is_true('CI')\n    return debug_stacktrace or debug_mode or ci_env\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.prompt_choices","title":"<code>prompt_choices(description, choices, as_list=True)</code>","text":"<p>Prompt the user with a description until we get one of the choices.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The prompt to display.</p> required <code>choices</code> <code>Sequence[str]</code> <p>List of accepted choices.</p> required <code>as_list</code> <code>bool</code> <p>If false, it will concat the choices with <code>/</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The string chosen by the user.</p> Source code in <code>m/core/io.py</code> <pre><code>def prompt_choices(\n    description: str,\n    choices: Sequence[str],\n    as_list: bool = True,\n) -&gt; str:\n    \"\"\"Prompt the user with a description until we get one of the choices.\n\n    Args:\n        description: The prompt to display.\n        choices: List of accepted choices.\n        as_list: If false, it will concat the choices with `/`.\n\n    Returns:\n        The string chosen by the user.\n    \"\"\"\n    valid = False\n    dev_input = ''\n    choices_display = choices if as_list else '/'.join(choices)\n    while not valid:\n        logger.prompt(description, {'choices': choices_display})\n        sys.stderr.write('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ')\n        dev_input = input()\n        if dev_input in choices:\n            valid = True\n    return dev_input\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.prompt_next_version","title":"<code>prompt_next_version(version, release_type)</code>","text":"<p>Prompt the developer to select the next version.</p> <p>It displays the possible major, minor and patch versions and prompts the developer to enter one of them. See https://semver.org/.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>The current version.</p> required <code>release_type</code> <code>str</code> <p>If <code>hotfix</code> then it bumps the patch value.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>One of the versions wrapped in a OneOf.</p> Source code in <code>m/core/io.py</code> <pre><code>def prompt_next_version(version: str, release_type: str) -&gt; OneOf[Issue, str]:\n    \"\"\"Prompt the developer to select the next version.\n\n    It displays the possible major, minor and patch versions and prompts the\n    developer to enter one of them. See https://semver.org/.\n\n    Args:\n        version: The current version.\n        release_type: If `hotfix` then it bumps the patch value.\n\n    Returns:\n        One of the versions wrapped in a OneOf.\n    \"\"\"\n    ver = version.split('-')[0]\n    parts = [int(x) for x in ver.split('.')]\n    patch = _ver_str(parts[0], parts[1], parts[2] + 1)\n    if release_type == 'hotfix':\n        return Good(patch)\n\n    minor = _ver_str(parts[0], parts[1] + 1, 0)\n    major = _ver_str(parts[0] + 1, 0, 0)\n    ver = f'{{bold_green}}{version}{{end}}'\n    msg = color(f'Current version is {ver}. Enter one of the following:')\n    return Good(prompt_choices(msg, [minor, major]))\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.renv","title":"<code>renv(key)</code>","text":"<p>Require an environment variable to be defined.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The environment variable required to be defined.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>A <code>OneOf</code> with the value of the environment variable or an issue.</p> Source code in <code>m/core/io.py</code> <pre><code>def renv(key: str) -&gt; OneOf[Issue, str]:\n    \"\"\"Require an environment variable to be defined.\n\n    Args:\n        key: The environment variable required to be defined.\n\n    Returns:\n        A `OneOf` with the value of the environment variable or an issue.\n    \"\"\"\n    env_value = os.environ.get(key)\n    # Value may still be an empty string, checking against None\n    if env_value is not None:\n        return Good(env_value)\n    return issue(f'missing {key} in env')\n</code></pre>"},{"location":"api/m/core/issue/","title":"issue","text":""},{"location":"api/m/core/issue/#m.core.issue.Issue","title":"<code>Issue</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Wrapper to keep track of all exceptions.</p> <p>It provides a 'cause' field so that we may know why an issue was triggered.</p> Source code in <code>m/core/issue.py</code> <pre><code>class Issue(Exception):  # noqa: N818, WPS230 - Intention is not to raise\n    \"\"\"Wrapper to keep track of all exceptions.\n\n    It provides a 'cause' field so that we may know why an issue was\n    triggered.\n    \"\"\"\n\n    show_traceback = True\n    yaml_traceback = True\n\n    message: str\n    description: str | None\n    cause: Exception | None\n    context: object | None\n    include_traceback: bool\n    cause_tb: list[str] | None\n    traceback: list[str] | None\n\n    def __init__(  # noqa: WPS211 - need to initialize the attributes\n        self,\n        message: str,\n        description: str | None = None,\n        cause: Exception | None = None,\n        context: object | None = None,\n        include_traceback: bool = True,\n    ):\n        \"\"\"Create an Issue.\n\n        Args:\n            message: Simple description of the issue.\n            description: More in depth detail on the issue\n            cause: The exception/Issue that is responsible for this instance.\n            context: Dictionary with any useful data related to the issue.\n            include_traceback: If False, it skips computing the traceback.\n        \"\"\"\n        super().__init__()\n        self.message = message\n        self.description = description\n        self.cause = cause\n        if cause and not isinstance(cause, Issue):\n            # https://stackoverflow.com/a/12539332/788553\n            with suppress(BaseException):\n                exc_info = sys.exc_info()\n                fmt_exception = (\n                    traceback.format_exception_only(exc_info[0], exc_info[1])\n                    if exc_info[0] is not None and exc_info[1] is not None\n                    else []\n                )\n                exception_list = [\n                    *traceback.format_tb(exc_info[2]),\n                    *fmt_exception,\n                ]\n                self.cause_tb = [\n                    y\n                    for x in exception_list\n                    for y in x.splitlines()\n                ]\n        self.context = context\n        self.include_traceback = include_traceback\n        self.traceback = None\n        if self.include_traceback:\n            frame = inspect.currentframe()\n            self.traceback = [\n                y\n                for x in traceback.format_stack(frame)[:-1]\n                for y in x.splitlines()\n            ]\n\n    def only_context(self) -&gt; bool:\n        \"\"\"Return true if the issue only offers context.\n\n        In some cases we may create an issue with only a message and a\n        context. This function will let us know of such case so that a\n        log formatter may be able to unwrap the context.\n\n        Returns:\n            True if it is safe to only display the context value on a log.\n        \"\"\"\n        has_context = self.context is not None\n        all_props = (self.description, self.traceback, self.cause)\n        return has_context and not [_ for _ in all_props if _]\n\n    def to_dict(self, show_traceback: bool = True) -&gt; IssueDict:\n        \"\"\"Convert to a ordered dictionary.\n\n        This is done so that each of the properties are written in an expected\n        order.\n\n        Args:\n            show_traceback: If False, it will remove all stacktraces.\n\n        Returns:\n            An `IssueDict` instance.\n        \"\"\"\n        issue_dict = cast(IssueDict, OrderedDict())\n        issue_dict['message'] = self.message\n        if self.description:\n            issue_dict['description'] = self.description\n        if self.context:\n            issue_dict['context'] = self.context\n        if self.include_traceback and self.traceback:\n            issue_dict['traceback'] = self.traceback\n            if Issue.yaml_traceback and isinstance(self.traceback, list):\n                issue_dict['traceback'] = _traceback_to_str(self.traceback)\n        if self.cause:\n            self._handle_cause(issue_dict)\n        if not show_traceback:\n            remove_traceback(issue_dict)\n        return issue_dict\n\n    def to_str(self, show_traceback: bool) -&gt; str:\n        \"\"\"Convert the instance to string.\n\n        Args:\n            show_traceback: If false, it will remove the error traceback.\n\n        Returns:\n            A string representation of the Issue instance.\n        \"\"\"\n        issue_dict = self.to_dict(show_traceback=show_traceback)\n        if Issue.yaml_traceback:\n            return yaml.dumps(issue_dict)\n        return json.dumps(issue_dict, indent=2)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Convert the instance to a string.\n\n        Returns:\n            A string representation of the Issue instance.\n        \"\"\"\n        issue_str = self.to_str(Issue.show_traceback)\n        if Issue.yaml_traceback:\n            return highlight_yaml(issue_str)\n        return highlight_json(issue_str)\n\n    def _handle_cause(self, issue_dict: IssueDict) -&gt; None:\n        if isinstance(self.cause, Issue):\n            issue_dict['cause'] = self.cause.to_dict()\n        else:\n            issue_dict['cause'] = {\n                'message': str(self.cause),\n                'traceback': self.cause_tb,\n            }\n            # I'm clearly assigning to a dict in the above statement...\n            # but it is an object so a dict can be assigned to it but that\n            # does not mean that we can use `pop` on an object. So we have to\n            # help mypy know that know we are dealing with a dict.\n            cause = cast(dict, issue_dict['cause'])\n            if not self.cause_tb:\n                cause.pop('traceback', None)\n            if Issue.yaml_traceback and isinstance(self.cause_tb, list):\n                cause['traceback'] = _traceback_to_str(self.cause_tb)\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.Issue.__init__","title":"<code>__init__(message, description=None, cause=None, context=None, include_traceback=True)</code>","text":"<p>Create an Issue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Simple description of the issue.</p> required <code>description</code> <code>str | None</code> <p>More in depth detail on the issue</p> <code>None</code> <code>cause</code> <code>Exception | None</code> <p>The exception/Issue that is responsible for this instance.</p> <code>None</code> <code>context</code> <code>object | None</code> <p>Dictionary with any useful data related to the issue.</p> <code>None</code> <code>include_traceback</code> <code>bool</code> <p>If False, it skips computing the traceback.</p> <code>True</code> Source code in <code>m/core/issue.py</code> <pre><code>def __init__(  # noqa: WPS211 - need to initialize the attributes\n    self,\n    message: str,\n    description: str | None = None,\n    cause: Exception | None = None,\n    context: object | None = None,\n    include_traceback: bool = True,\n):\n    \"\"\"Create an Issue.\n\n    Args:\n        message: Simple description of the issue.\n        description: More in depth detail on the issue\n        cause: The exception/Issue that is responsible for this instance.\n        context: Dictionary with any useful data related to the issue.\n        include_traceback: If False, it skips computing the traceback.\n    \"\"\"\n    super().__init__()\n    self.message = message\n    self.description = description\n    self.cause = cause\n    if cause and not isinstance(cause, Issue):\n        # https://stackoverflow.com/a/12539332/788553\n        with suppress(BaseException):\n            exc_info = sys.exc_info()\n            fmt_exception = (\n                traceback.format_exception_only(exc_info[0], exc_info[1])\n                if exc_info[0] is not None and exc_info[1] is not None\n                else []\n            )\n            exception_list = [\n                *traceback.format_tb(exc_info[2]),\n                *fmt_exception,\n            ]\n            self.cause_tb = [\n                y\n                for x in exception_list\n                for y in x.splitlines()\n            ]\n    self.context = context\n    self.include_traceback = include_traceback\n    self.traceback = None\n    if self.include_traceback:\n        frame = inspect.currentframe()\n        self.traceback = [\n            y\n            for x in traceback.format_stack(frame)[:-1]\n            for y in x.splitlines()\n        ]\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.Issue.__str__","title":"<code>__str__()</code>","text":"<p>Convert the instance to a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the Issue instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Convert the instance to a string.\n\n    Returns:\n        A string representation of the Issue instance.\n    \"\"\"\n    issue_str = self.to_str(Issue.show_traceback)\n    if Issue.yaml_traceback:\n        return highlight_yaml(issue_str)\n    return highlight_json(issue_str)\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.Issue.only_context","title":"<code>only_context()</code>","text":"<p>Return true if the issue only offers context.</p> <p>In some cases we may create an issue with only a message and a context. This function will let us know of such case so that a log formatter may be able to unwrap the context.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if it is safe to only display the context value on a log.</p> Source code in <code>m/core/issue.py</code> <pre><code>def only_context(self) -&gt; bool:\n    \"\"\"Return true if the issue only offers context.\n\n    In some cases we may create an issue with only a message and a\n    context. This function will let us know of such case so that a\n    log formatter may be able to unwrap the context.\n\n    Returns:\n        True if it is safe to only display the context value on a log.\n    \"\"\"\n    has_context = self.context is not None\n    all_props = (self.description, self.traceback, self.cause)\n    return has_context and not [_ for _ in all_props if _]\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.Issue.to_dict","title":"<code>to_dict(show_traceback=True)</code>","text":"<p>Convert to a ordered dictionary.</p> <p>This is done so that each of the properties are written in an expected order.</p> <p>Parameters:</p> Name Type Description Default <code>show_traceback</code> <code>bool</code> <p>If False, it will remove all stacktraces.</p> <code>True</code> <p>Returns:</p> Type Description <code>IssueDict</code> <p>An <code>IssueDict</code> instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def to_dict(self, show_traceback: bool = True) -&gt; IssueDict:\n    \"\"\"Convert to a ordered dictionary.\n\n    This is done so that each of the properties are written in an expected\n    order.\n\n    Args:\n        show_traceback: If False, it will remove all stacktraces.\n\n    Returns:\n        An `IssueDict` instance.\n    \"\"\"\n    issue_dict = cast(IssueDict, OrderedDict())\n    issue_dict['message'] = self.message\n    if self.description:\n        issue_dict['description'] = self.description\n    if self.context:\n        issue_dict['context'] = self.context\n    if self.include_traceback and self.traceback:\n        issue_dict['traceback'] = self.traceback\n        if Issue.yaml_traceback and isinstance(self.traceback, list):\n            issue_dict['traceback'] = _traceback_to_str(self.traceback)\n    if self.cause:\n        self._handle_cause(issue_dict)\n    if not show_traceback:\n        remove_traceback(issue_dict)\n    return issue_dict\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.Issue.to_str","title":"<code>to_str(show_traceback)</code>","text":"<p>Convert the instance to string.</p> <p>Parameters:</p> Name Type Description Default <code>show_traceback</code> <code>bool</code> <p>If false, it will remove the error traceback.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the Issue instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def to_str(self, show_traceback: bool) -&gt; str:\n    \"\"\"Convert the instance to string.\n\n    Args:\n        show_traceback: If false, it will remove the error traceback.\n\n    Returns:\n        A string representation of the Issue instance.\n    \"\"\"\n    issue_dict = self.to_dict(show_traceback=show_traceback)\n    if Issue.yaml_traceback:\n        return yaml.dumps(issue_dict)\n    return json.dumps(issue_dict, indent=2)\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.remove_traceback","title":"<code>remove_traceback(issue_dict)</code>","text":"<p>Remove the <code>traceback</code> key from a dictionary if it exists.</p> <p>It will recursively remove the <code>traceback</code> from its cause or context.</p> <p>Parameters:</p> Name Type Description Default <code>issue_dict</code> <code>object</code> <p>A dictionary representation of an <code>Issue</code>.</p> required Source code in <code>m/core/issue.py</code> <pre><code>def remove_traceback(issue_dict: object) -&gt; None:\n    \"\"\"Remove the `traceback` key from a dictionary if it exists.\n\n    It will recursively remove the `traceback` from its cause or context.\n\n    Args:\n        issue_dict: A dictionary representation of an `Issue`.\n    \"\"\"\n    if isinstance(issue_dict, dict):\n        if 'traceback' in issue_dict:\n            issue_dict.pop('traceback')\n        cause = issue_dict.get('cause')\n        if cause:\n            remove_traceback(cause)\n        context = issue_dict.get('context')\n        remove_traceback(context)\n        if isinstance(context, list):\n            for context_item in context:\n                remove_traceback(context_item)\n</code></pre>"},{"location":"api/m/core/json/","title":"json","text":""},{"location":"api/m/core/json/#m.core.json.get","title":"<code>get(dict_inst, key_str)</code>","text":"<p>Return the value based on the <code>key_str</code> specified.</p> <p>The following are equivalent::</p> <pre><code>obj['a']['b']['c'] &lt;=&gt; get(obj, 'a.b.c').value\n</code></pre> <p>provided that the keys <code>a</code>, <code>b</code> and <code>c</code> are valid.</p> <p>Parameters:</p> Name Type Description Default <code>dict_inst</code> <code>Any</code> <p>The dictionary instance to query.</p> required <code>key_str</code> <code>str</code> <p>A simple query to fetch from the dict_inst.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>Good</code> if the value we want is available, otherwise it returns a</p> <code>OneOf[Issue, Any]</code> <p><code>Bad</code> with the path that returned <code>None</code>.</p> Source code in <code>m/core/json.py</code> <pre><code>def get(dict_inst: Any, key_str: str) -&gt; OneOf[Issue, Any]:\n    \"\"\"Return the value based on the `key_str` specified.\n\n    The following are equivalent::\n\n        obj['a']['b']['c'] &lt;=&gt; get(obj, 'a.b.c').value\n\n    provided that the keys `a`, `b` and `c` are valid.\n\n    Args:\n        dict_inst: The dictionary instance to query.\n        key_str: A simple query to fetch from the dict_inst.\n\n    Returns:\n        A `Good` if the value we want is available, otherwise it returns a\n        `Bad` with the path that returned `None`.\n    \"\"\"\n    keys = key_str.split('.')\n    current = dict_inst\n    for num, key in enumerate(keys):\n        new_key: Union[str, int] = key\n        with suppress(ValueError):\n            new_key = int(key)\n        try:\n            current = current[new_key]\n        except KeyError:\n            pth = '.'.join(keys[:num + 1])\n            return issue(f'`{pth}` path was not found')\n        except Exception as ex:\n            pth = '.'.join(keys[:num])\n            if not isinstance(current, Mapping):\n                context = pth or current\n                return issue(f'`{context}` is not a dict')\n            # catch unknown issue\n            return issue(  # pragma: no cover\n                f'{pth} resulted in an error',\n                cause=ex,\n            )\n    return Good(current)\n</code></pre>"},{"location":"api/m/core/json/#m.core.json.jsonq","title":"<code>jsonq(dict_inst, separator, *key_str)</code>","text":"<p>Stringify the values obtained from <code>multi_get</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dict_inst</code> <code>Mapping[str, Any]</code> <p>The dictionary instance to query.</p> required <code>separator</code> <code>str</code> <p>A string to use to separate the results.</p> required <code>key_str</code> <code>str</code> <p>The queries to apply.</p> <code>()</code> <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>A string separated by <code>separator</code> if successful or an Issue with</p> <code>OneOf[Issue, str]</code> <p>a description of the problems.</p> Source code in <code>m/core/json.py</code> <pre><code>def jsonq(\n    dict_inst: Map[str, Any],\n    separator: str,\n    *key_str: str,\n) -&gt; OneOf[Issue, str]:\n    \"\"\"Stringify the values obtained from `multi_get`.\n\n    Args:\n        dict_inst: The dictionary instance to query.\n        separator: A string to use to separate the results.\n        key_str: The queries to apply.\n\n    Returns:\n        A string separated by `separator` if successful or an Issue with\n        a description of the problems.\n    \"\"\"\n    return one_of(lambda: [\n        separator.join(map(_to_str, key_values))\n        for key_values in multi_get(dict_inst, *key_str)\n    ])\n</code></pre>"},{"location":"api/m/core/json/#m.core.json.multi_get","title":"<code>multi_get(dict_inst, *keys)</code>","text":"<p>Call <code>get</code> for every input specified by <code>keys</code>.</p> <p>It collects the invalid keys and returns an <code>Issue</code>::</p> <pre><code>multi_get(obj, 'a', 'a.b', 'a.b.c')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dict_inst</code> <code>object</code> <p>The dictionary instance to query.</p> required <code>keys</code> <code>str</code> <p>The queries to apply.</p> <code>()</code> <p>Returns:</p> Type Description <code>OneOf[Issue, list[Any]]</code> <p>A <code>Good</code> with a list of the results if successful, otherwise a <code>Bad</code></p> <code>OneOf[Issue, list[Any]]</code> <p>with the list of failures.</p> Source code in <code>m/core/json.py</code> <pre><code>def multi_get(\n    dict_inst: object,\n    *keys: str,\n) -&gt; OneOf[Issue, list[Any]]:\n    \"\"\"Call `get` for every input specified by `keys`.\n\n    It collects the invalid keys and returns an `Issue`::\n\n        multi_get(obj, 'a', 'a.b', 'a.b.c')\n\n    Args:\n        dict_inst: The dictionary instance to query.\n        keys: The queries to apply.\n\n    Returns:\n        A `Good` with a list of the results if successful, otherwise a `Bad`\n        with the list of failures.\n    \"\"\"\n    result_items = []\n    failures = []\n    for key in keys:\n        res = get(dict_inst, key)\n        if res.is_bad:\n            failures.append(\n                Issue(\n                    message=f'key lookup failure: `{key}`',\n                    cause=res.value,\n                    include_traceback=False,\n                ),\n            )\n        else:\n            result_items.append(res.value)\n    if failures:\n        return issue(\n            'multi_get key retrieval failure',\n            context=[x.to_dict() for x in failures],\n            include_traceback=False,\n        )\n    return Good(result_items)\n</code></pre>"},{"location":"api/m/core/json/#m.core.json.parse_json","title":"<code>parse_json(json_str, error_if_empty=False)</code>","text":"<p>Parse a string as json.</p> <p>Parameters:</p> Name Type Description Default <code>json_str</code> <code>str</code> <p>The string to parse.</p> required <code>error_if_empty</code> <code>bool</code> <p>The json parser may throw an error if <code>True</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>Good</code> containing the parsed contents of the json string.</p> Source code in <code>m/core/json.py</code> <pre><code>def parse_json(\n    json_str: str,\n    error_if_empty: bool = False,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Parse a string as json.\n\n    Args:\n        json_str: The string to parse.\n        error_if_empty: The json parser may throw an error if `True`.\n\n    Returns:\n        A `Good` containing the parsed contents of the json string.\n    \"\"\"\n    empty = '' if error_if_empty else 'null'\n    try:\n        return Good(json.loads(json_str or empty))\n    except Exception as ex:\n        return issue('failed to parse the json data', cause=ex)\n</code></pre>"},{"location":"api/m/core/json/#m.core.json.read_json","title":"<code>read_json(filename, error_if_empty=False)</code>","text":"<p>Read a json object from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | None</code> <p>The filename to read from, if <code>None</code> it reads from stdin.</p> required <code>error_if_empty</code> <code>bool</code> <p>The json parser may throw an error if <code>True</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>Good</code> containing the parsed contents of the json file.</p> Source code in <code>m/core/json.py</code> <pre><code>def read_json(\n    filename: str | None,\n    error_if_empty: bool = False,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Read a json object from a json file.\n\n    Args:\n        filename: The filename to read from, if `None` it reads from stdin.\n        error_if_empty: The json parser may throw an error if `True`.\n\n    Returns:\n        A `Good` containing the parsed contents of the json file.\n    \"\"\"\n    empty: str = '' if error_if_empty else 'null'\n    context = {'filename': filename or 'SYS.STDIN'}\n    return one_of(lambda: [\n        json_data\n        for json_str in rw.read_file(filename)\n        for json_data in parse_json(json_str or empty, error_if_empty)\n    ]).flat_map_bad(hone('failed to read json file', context=context))\n</code></pre>"},{"location":"api/m/core/maybe/","title":"maybe","text":""},{"location":"api/m/core/maybe/#m.core.maybe.maybe","title":"<code>maybe(callback)</code>","text":"<p>Evaluate the callback to return a value.</p> <p>Unlike Typescript, Python does not have optional chaining::</p> <pre><code>https://en.wikipedia.org/wiki/Safe_navigation_operator#Python\n</code></pre> <p>To simulate this we can use this function as follows::</p> <pre><code>ans = maybe(lambda: path.to.prop)  # type: ignore[union-attr]\n</code></pre> <p>It is ok to disable the <code>union-attr</code> mypy check as long as mypy is checking for <code>no-any-return</code>.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[], T]</code> <p>A function return a value.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>The value returned by the function or <code>None</code>.</p> Source code in <code>m/core/maybe.py</code> <pre><code>def maybe(callback: Callable[[], T]) -&gt; T | None:\n    \"\"\"Evaluate the callback to return a value.\n\n    Unlike Typescript, Python does not have optional chaining::\n\n        https://en.wikipedia.org/wiki/Safe_navigation_operator#Python\n\n    To simulate this we can use this function as follows::\n\n        ans = maybe(lambda: path.to.prop)  # type: ignore[union-attr]\n\n    It is ok to disable the `union-attr` mypy check as long as mypy is checking\n    for `no-any-return`.\n\n    Args:\n        callback: A function return a value.\n\n    Returns:\n        The value returned by the function or `None`.\n    \"\"\"\n    try:\n        return callback()\n    except AttributeError:\n        return None\n</code></pre>"},{"location":"api/m/core/maybe/#m.core.maybe.non_null","title":"<code>non_null(inst)</code>","text":"<p>Assert that <code>inst</code> is not <code>None</code>.</p> <p>Implementation taken from::</p> <pre><code>https://github.com/python/typing/issues/645#issuecomment-501057220\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>T | None</code> <p>A possibly null instance.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The same argument with the <code>None</code> type removed.</p> Source code in <code>m/core/maybe.py</code> <pre><code>def non_null(inst: T | None) -&gt; T:\n    \"\"\"Assert that `inst` is not `None`.\n\n    Implementation taken from::\n\n        https://github.com/python/typing/issues/645#issuecomment-501057220\n\n    Args:\n        inst: A possibly null instance.\n\n    Returns:\n        The same argument with the `None` type removed.\n    \"\"\"\n    # The assert statement can go away with the -O flag.\n    assert inst is not None  # noqa: S101\n    return inst\n</code></pre>"},{"location":"api/m/core/one_of/","title":"one_of","text":""},{"location":"api/m/core/one_of/#m.core.one_of.hone","title":"<code>hone(msg, context=None, description=None, include_traceback=True)</code>","text":"<p>Create a function to repackage the issue with a new message and context.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The new message.</p> required <code>context</code> <code>object | None</code> <p>The new context.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>The new description.</p> <code>None</code> <code>include_traceback</code> <code>bool</code> <p>Whether to include the traceback.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[[Issue], OneOf[Issue, Any]]</code> <p>A function that takes an issue and returns a new issue.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def hone(\n    msg: str,\n    context: object | None = None,\n    description: str | None = None,\n    include_traceback: bool = True,\n) -&gt; Callable[[Issue], OneOf[Issue, Any]]:\n    \"\"\"Create a function to repackage the issue with a new message and context.\n\n    Args:\n        msg: The new message.\n        context: The new context.\n        description: The new description.\n        include_traceback: Whether to include the traceback.\n\n    Returns:\n        A function that takes an issue and returns a new issue.\n    \"\"\"\n    return partial(_hone, msg, context, description, include_traceback)\n</code></pre>"},{"location":"api/m/core/one_of/#m.core.one_of.issue","title":"<code>issue(message, description=None, cause=None, context=None, include_traceback=True)</code>","text":"<p>Shortcut to create a Bad OneOf containing an Issue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The issue message.</p> required <code>description</code> <code>str | None</code> <p>Optional description.</p> <code>None</code> <code>cause</code> <code>Exception | None</code> <p>Optional exception that caused the issue.</p> <code>None</code> <code>context</code> <code>object | None</code> <p>Optional dictionary to provide extra information.</p> <code>None</code> <code>include_traceback</code> <code>bool</code> <p>Defaults to true to provide the stack trace.</p> <code>True</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>An instance of an <code>Issue</code>.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def issue(  # noqa: WPS211\n    message: str,\n    description: str | None = None,\n    cause: Exception | None = None,\n    context: object | None = None,\n    include_traceback: bool = True,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Shortcut to create a Bad OneOf containing an Issue.\n\n    Args:\n        message: The issue message.\n        description: Optional description.\n        cause: Optional exception that caused the issue.\n        context: Optional dictionary to provide extra information.\n        include_traceback: Defaults to true to provide the stack trace.\n\n    Returns:\n        An instance of an `Issue`.\n    \"\"\"\n    inst = Issue(message, description, cause, context, include_traceback)\n    return Bad(inst)\n</code></pre>"},{"location":"api/m/core/one_of/#m.core.one_of.non_issue","title":"<code>non_issue(inst)</code>","text":"<p>Obtain the value of the <code>OneOf</code> as if it was a Good value.</p> <p>Warning: This should only be used provided that we know for sure that we are not dealing with a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>OneOf[Issue, G]</code> <p>A OneOf.</p> required <p>Returns:</p> Type Description <code>G</code> <p>The value stored in the OneOf.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def non_issue(inst: OneOf[Issue, G]) -&gt; G:\n    \"\"\"Obtain the value of the `OneOf` as if it was a Good value.\n\n    Warning: This should only be used provided that we know for sure\n    that we are not dealing with a `Bad` value.\n\n    Args:\n        inst: A OneOf.\n\n    Returns:\n        The value stored in the OneOf.\n    \"\"\"\n    # The assert statement can go away with the -O flag.\n    assert not inst.is_bad  # noqa: S101\n    return cast(G, inst.value)\n</code></pre>"},{"location":"api/m/core/one_of/#m.core.one_of.one_of","title":"<code>one_of(comp)</code>","text":"<p>Handle the \"Good\" value of a <code>OneOf</code>.</p> <p>To be used so that we may iterate over OneOf objects that may raise the <code>StopBadIteration</code> exception.</p> <p>Parameters:</p> Name Type Description Default <code>comp</code> <code>Callable[[], list[G]]</code> <p>A lambda function returning an array with a single value.</p> required <p>Returns:</p> Type Description <code>OneOf[Any, G]</code> <p>A <code>OneOf</code> with the value returned from <code>comp</code>.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def one_of(comp: Callable[[], list[G]]) -&gt; OneOf[Any, G]:\n    \"\"\"Handle the \"Good\" value of a `OneOf`.\n\n    To be used so that we may iterate over OneOf objects that may raise\n    the `StopBadIteration` exception.\n\n    Args:\n        comp: A lambda function returning an array with a single value.\n\n    Returns:\n        A `OneOf` with the value returned from `comp`.\n    \"\"\"\n    res = None\n    try:\n        res = comp()\n    except StopBadIteration as ex:\n        return cast(Bad, ex.bad)\n    except ValidationError as ex:\n        return issue('pydantic validation error', cause=ex)\n    except Exception as ex:\n        return issue('one_of caught exception', cause=ex)\n    if res:\n        return Good(res[0])\n    # LOOK AT ME - you may be here because a mock is not returning a OneOf.\n    return issue('one_of empty response - iteration missing a OneOf')\n</code></pre>"},{"location":"api/m/core/one_of/#m.core.one_of.to_one_of","title":"<code>to_one_of(callback, message, context=None)</code>","text":"<p>Wrap a python call in a <code>OneOf</code>.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[], Any]</code> <p>A lambda function with a simple python statement.</p> required <code>message</code> <code>str</code> <p>An error message in case the statement raises an exception.</p> required <code>context</code> <code>object | None</code> <p>Additional error context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OneOf[Issue, int]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> if the callback raises an error.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def to_one_of(\n    callback: Callable[[], Any],\n    message: str,\n    context: object | None = None,\n) -&gt; OneOf[Issue, int]:\n    \"\"\"Wrap a python call in a `OneOf`.\n\n    Args:\n        callback: A lambda function with a simple python statement.\n        message: An error message in case the statement raises an exception.\n        context: Additional error context.\n\n    Returns:\n        A `OneOf` containing an `Issue` if the callback raises an error.\n    \"\"\"\n    try:\n        callback()\n    except Exception as ex:\n        return issue(message, cause=ex, context=context)\n    return Good(0)\n</code></pre>"},{"location":"api/m/core/rw/","title":"rw","text":""},{"location":"api/m/core/rw/#m.core.rw.assert_file_exists","title":"<code>assert_file_exists(path)</code>","text":"<p>Assert that a file exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, Path]</code> <p>A <code>Good</code> containing the <code>Path</code> if the file exists.</p> Source code in <code>m/core/rw.py</code> <pre><code>def assert_file_exists(path: str) -&gt; OneOf[Issue, Path]:\n    \"\"\"Assert that a file exists.\n\n    Args:\n        path: The path to the file.\n\n    Returns:\n        A `Good` containing the `Path` if the file exists.\n    \"\"\"\n    path_inst = Path(path)\n    if path_inst.exists():\n        return Good(path_inst)\n    return issue('file does not exist', context={'path': path})\n</code></pre>"},{"location":"api/m/core/rw/#m.core.rw.insert_to_file","title":"<code>insert_to_file(filename, start, text, end)</code>","text":"<p>Insert content to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file to insert to.</p> required <code>start</code> <code>str</code> <p>The start delimiter where the insertion will take place.</p> required <code>text</code> <code>str</code> <p>The main content to insert.</p> required <code>end</code> <code>str</code> <p>The end delimiter.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, int]</code> <p>None if successful, else an issue.</p> Source code in <code>m/core/rw.py</code> <pre><code>def insert_to_file(\n    filename: str,\n    start: str,\n    text: str,\n    end: str,\n) -&gt; OneOf[Issue, int]:\n    \"\"\"Insert content to a file.\n\n    Args:\n        filename: The file to insert to.\n        start: The start delimiter where the insertion will take place.\n        text: The main content to insert.\n        end: The end delimiter.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    return one_of(lambda: [\n        0\n        for file_content in read_file(filename)\n        for new_content in _insert_to_file(file_content, start, text, end)\n        for _ in write_file(filename, new_content)\n    ])\n</code></pre>"},{"location":"api/m/core/rw/#m.core.rw.read_file","title":"<code>read_file(filename)</code>","text":"<p>FP version of open to read the contents of a file.</p> <p>If <code>None</code> is provided it will attempt to read from <code>sys.stdin</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | None</code> <p>The file path to read.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>A <code>Good</code> containing the contents of the file.</p> Source code in <code>m/core/rw.py</code> <pre><code>def read_file(filename: str | None) -&gt; OneOf[Issue, str]:\n    \"\"\"FP version of open to read the contents of a file.\n\n    If `None` is provided it will attempt to read from `sys.stdin`.\n\n    Args:\n        filename: The file path to read.\n\n    Returns:\n        A `Good` containing the contents of the file.\n    \"\"\"\n    if filename is None:\n        return Good(sys.stdin.read())\n    try:\n        with Path.open(Path(filename), encoding='UTF-8') as fp:\n            return Good(fp.read())\n    except Exception as ex:\n        return issue(\n            'failed to read file',\n            context={'filename': filename},\n            cause=ex,\n        )\n</code></pre>"},{"location":"api/m/core/rw/#m.core.rw.write_file","title":"<code>write_file(filename, text, mode='w')</code>","text":"<p>Write contents to a file in a functional programming style.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file path where contents will be written.</p> required <code>text</code> <code>str</code> <p>The contents of the file.</p> required <code>mode</code> <code>str</code> <p>The mode to open the file in.</p> <code>'w'</code> <p>Returns:</p> Type Description <code>OneOf[Issue, int]</code> <p>A <code>Good</code> containing 0 if the file was written.</p> Source code in <code>m/core/rw.py</code> <pre><code>def write_file(filename: str, text: str, mode: str = 'w') -&gt; OneOf[Issue, int]:\n    \"\"\"Write contents to a file in a functional programming style.\n\n    Args:\n        filename: The file path where contents will be written.\n        text: The contents of the file.\n        mode: The mode to open the file in.\n\n    Returns:\n        A `Good` containing 0 if the file was written.\n    \"\"\"\n    try:\n        with Path.open(Path(filename), mode, encoding='UTF-8') as fp:\n            fp.write(text)\n    except Exception as ex:\n        return issue(\n            'failed to write file',\n            context={'filename': filename},\n            cause=ex,\n        )\n    return Good(0)\n</code></pre>"},{"location":"api/m/core/subprocess/","title":"subprocess","text":""},{"location":"api/m/core/subprocess/#m.core.subprocess.eval_cmd","title":"<code>eval_cmd(cmd)</code>","text":"<p>Evaluate a bash command and return its output.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>The shell command to evaluate.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>The output of the command (or an Issue if the command failed).</p> Source code in <code>m/core/subprocess.py</code> <pre><code>def eval_cmd(cmd: str) -&gt; OneOf[Issue, str]:\n    \"\"\"Evaluate a bash command and return its output.\n\n    Args:\n        cmd: The shell command to evaluate.\n\n    Returns:\n        The output of the command (or an Issue if the command failed).\n    \"\"\"\n    command = shlex.split(cmd)\n    try:\n        out = sub.check_output(command, stderr=STDOUT, shell=False).decode()  # noqa: S603,E501\n    except CalledProcessError as ex:\n        out = ex.output.decode()\n        return issue(\n            'command returned a non zero exit code',\n            context={'cmd': cmd, 'output': out},\n        )\n    return Good(out.strip())\n</code></pre>"},{"location":"api/m/core/subprocess/#m.core.subprocess.exec_pnpm","title":"<code>exec_pnpm(pnpm_args)</code>","text":"<p>Execute pnpm with the given arguments.</p> <p>This command will execute the pnpm command in the current working directory.</p> <p>Parameters:</p> Name Type Description Default <code>pnpm_args</code> <code>list[str]</code> <p>The arguments to pass to pnpm.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, None]</code> <p>None if successful.</p> Source code in <code>m/core/subprocess.py</code> <pre><code>def exec_pnpm(pnpm_args: list[str]) -&gt; OneOf[Issue, None]:\n    \"\"\"Execute pnpm with the given arguments.\n\n    This command will execute the pnpm command in the current working directory.\n\n    Args:\n        pnpm_args: The arguments to pass to pnpm.\n\n    Returns:\n        None if successful.\n    \"\"\"\n    # delegating the rest of the work to pnpm\n    exit_code = sub.call(['pnpm', *pnpm_args], shell=False)  # noqa: S603, S607\n    if exit_code:\n        return issue('non_zero_pnpm_exit_code', context={\n            'pnpm_args': pnpm_args,\n            'exit_code': exit_code,\n        })\n    return Good(None)\n</code></pre>"},{"location":"api/m/core/types/","title":"types","text":""},{"location":"api/m/core/yaml/","title":"yaml","text":""},{"location":"api/m/core/yaml/#m.core.yaml.dumps","title":"<code>dumps(py_data, *, sort_keys=True, default_flow_style=False)</code>","text":"<p>Dump data as yaml using the safe_dump method.</p> <p>Parameters:</p> Name Type Description Default <code>py_data</code> <code>Any</code> <p>Any object that may be serialized.</p> required <code>sort_keys</code> <code>bool</code> <p>Whether to sort the keys.</p> <code>True</code> <code>default_flow_style</code> <code>bool | None</code> <p>Whether to use the default flow style.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A yaml serialized string.</p> Source code in <code>m/core/yaml.py</code> <pre><code>def dumps(\n    py_data: Any,\n    *,\n    sort_keys: bool = True,\n    default_flow_style: bool | None = False,\n) -&gt; str:\n    \"\"\"Dump data as yaml using the safe_dump method.\n\n    Args:\n        py_data: Any object that may be serialized.\n        sort_keys: Whether to sort the keys.\n        default_flow_style: Whether to use the default flow style.\n\n    Returns:\n        A yaml serialized string.\n    \"\"\"\n    return yaml.dump(\n        py_data,\n        Dumper=_SafeDumper,\n        sort_keys=sort_keys,\n        default_flow_style=default_flow_style,\n    )\n</code></pre>"},{"location":"api/m/core/yaml_fp/","title":"yaml_fp","text":""},{"location":"api/m/core/yaml_fp/#m.core.yaml_fp.parse_yaml","title":"<code>parse_yaml(yaml_str, error_if_empty=False)</code>","text":"<p>Parse a string as yaml.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_str</code> <code>str</code> <p>The string to parse.</p> required <code>error_if_empty</code> <code>bool</code> <p>The parser may throw an error if <code>True</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>Good</code> containing the parsed contents of the yaml string.</p> Source code in <code>m/core/yaml_fp.py</code> <pre><code>def parse_yaml(\n    yaml_str: str,\n    error_if_empty: bool = False,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Parse a string as yaml.\n\n    Args:\n        yaml_str: The string to parse.\n        error_if_empty: The parser may throw an error if `True`.\n\n    Returns:\n        A `Good` containing the parsed contents of the yaml string.\n    \"\"\"\n    empty = '' if error_if_empty else 'null'\n    try:\n        return Good(yaml.safe_load(yaml_str or empty))\n    except Exception as ex:\n        return issue('failed to parse the yaml data', cause=ex)\n</code></pre>"},{"location":"api/m/core/yaml_fp/#m.core.yaml_fp.read_yson","title":"<code>read_yson(filename, error_if_empty=False)</code>","text":"<p>Read a json object from a json or yaml file.</p> <p>It will choose the parser based on the filename extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to read from, if <code>None</code> it reads from stdin.</p> required <code>error_if_empty</code> <code>bool</code> <p>The json parser may throw an error if <code>True</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>Good</code> containing the parsed contents of the json file.</p> Source code in <code>m/core/yaml_fp.py</code> <pre><code>def read_yson(\n    filename: str,\n    error_if_empty: bool = False,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Read a json object from a json or yaml file.\n\n    It will choose the parser based on the filename extension.\n\n    Args:\n        filename: The filename to read from, if `None` it reads from stdin.\n        error_if_empty: The json parser may throw an error if `True`.\n\n    Returns:\n        A `Good` containing the parsed contents of the json file.\n    \"\"\"\n    empty: str = '' if error_if_empty else 'null'\n    file_map: dict[str, ParserFunction] = {\n        '.yaml': parse_yaml,\n        '.yml': parse_yaml,\n        '.json': parse_json,\n    }\n    ext = Path(filename).suffix\n    parser = file_map.get(ext, parse_json)\n    context = {'filename': filename or 'SYS.STDIN'}\n    return one_of(lambda: [\n        json_data\n        for json_str in rw.read_file(filename)\n        for json_data in parser(json_str or empty, error_if_empty)\n    ]).flat_map_bad(hone(f'failed to read \"{ext}\" file', context=context))\n</code></pre>"},{"location":"api/m/devcontainer/","title":"devcontainer","text":""},{"location":"api/m/devcontainer/bashrc/","title":"bashrc","text":""},{"location":"api/m/devcontainer/env/","title":"env","text":""},{"location":"api/m/devcontainer/env/#m.devcontainer.env.DevcontainerEnvVars","title":"<code>DevcontainerEnvVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Collection of variables required for devcontainer operations.</p> <p>All properties are prefixed with <code>MDC</code> to denote that those are variables generated by <code>M Dev Container</code>.</p> <p>Attributes:</p> Name Type Description <code>mdc_repo</code> <code>str</code> <p>...</p> <code>mdc_workspace</code> <code>str</code> <p>...</p> <code>mdc_pnpm_workspace</code> <code>str</code> <p>...</p> <code>mdc_venv_workspace</code> <code>str</code> <p>...</p> Source code in <code>m/devcontainer/env.py</code> <pre><code>class DevcontainerEnvVars(BaseModel):\n    \"\"\"Collection of variables required for devcontainer operations.\n\n    All properties are prefixed with `MDC` to denote that those are variables\n    generated by `M Dev Container`.\n    \"\"\"\n\n    mdc_repo: str\n    mdc_workspace: str\n    mdc_pnpm_workspace: str\n    mdc_venv_workspace: str\n\n    def to_bash(self: 'DevcontainerEnvVars') -&gt; str:\n        \"\"\"Create a bash code snippet that can be used in a bashrc file.\n\n        Returns:\n            A `.bashrc` code snippet.\n        \"\"\"\n        dict_data = self.model_dump()\n        return '\\n'.join([\n            f\"export {var_name.upper()}='{var_value}'\"\n            for var_name, var_value in dict_data.items()\n        ])\n</code></pre>"},{"location":"api/m/devcontainer/env/#m.devcontainer.env.DevcontainerEnvVars.to_bash","title":"<code>to_bash()</code>","text":"<p>Create a bash code snippet that can be used in a bashrc file.</p> <p>Returns:</p> Type Description <code>str</code> <p>A <code>.bashrc</code> code snippet.</p> Source code in <code>m/devcontainer/env.py</code> <pre><code>def to_bash(self: 'DevcontainerEnvVars') -&gt; str:\n    \"\"\"Create a bash code snippet that can be used in a bashrc file.\n\n    Returns:\n        A `.bashrc` code snippet.\n    \"\"\"\n    dict_data = self.model_dump()\n    return '\\n'.join([\n        f\"export {var_name.upper()}='{var_value}'\"\n        for var_name, var_value in dict_data.items()\n    ])\n</code></pre>"},{"location":"api/m/devcontainer/env/#m.devcontainer.env.MissingEnvVars","title":"<code>MissingEnvVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Container for missing environment variables.</p> <p>Attributes:</p> Name Type Description <code>missing</code> <code>list[str]</code> <p>...</p> <code>defined</code> <code>dict[str, str]</code> <p>...</p> Source code in <code>m/devcontainer/env.py</code> <pre><code>class MissingEnvVars(BaseModel):\n    \"\"\"Container for missing environment variables.\"\"\"\n\n    # list of environment variables that are required but do not exist\n    missing: list[str]\n\n    # environment variables that are defined\n    defined: dict[str, str]\n</code></pre>"},{"location":"api/m/devcontainer/env/#m.devcontainer.env.devcontainer_env_vars","title":"<code>devcontainer_env_vars()</code>","text":"<p>Get the environment variables for a devcontainer.</p> <p>This function is intended to be used in a devcontainer or in a Github runner. It will return the following values::</p> <pre><code>- repo: The repository name.\n- workspace: The path to directory containing the repo files.\n- pnpmWorkspace: The path where pnpm operations should take place.\n- venvWorkspace: The path where venv operations should take place.\n</code></pre> <p>Returns:</p> Type Description <code>DevcontainerEnvVars</code> <p>A dictionary with the values described above.</p> Source code in <code>m/devcontainer/env.py</code> <pre><code>def devcontainer_env_vars() -&gt; DevcontainerEnvVars:\n    \"\"\"Get the environment variables for a devcontainer.\n\n    This function is intended to be used in a devcontainer or in a Github\n    runner. It will return the following values::\n\n        - repo: The repository name.\n        - workspace: The path to directory containing the repo files.\n        - pnpmWorkspace: The path where pnpm operations should take place.\n        - venvWorkspace: The path where venv operations should take place.\n\n    Returns:\n        A dictionary with the values described above.\n    \"\"\"\n    github = os.environ.get('GITHUB_WORKSPACE')\n    container = os.environ.get('CONTAINER_WORKSPACE')\n    workspace = github or container or 'ERROR_UNKNOWN_WORKSPACE'\n    # big assumption here that the name of the repo is reflected in the name\n    # of the containing directory. Trying to avoid having to call `git`.\n    repo_name = workspace.split('/')[-1]\n    pnpm_workspace = f'/opt/pnpm/{repo_name}'\n    venv_workspace = f'/opt/venv/{repo_name}'\n    return DevcontainerEnvVars(\n        mdc_repo=repo_name,\n        mdc_workspace=workspace,\n        mdc_pnpm_workspace=pnpm_workspace,\n        mdc_venv_workspace=venv_workspace,\n    )\n</code></pre>"},{"location":"api/m/devcontainer/env/#m.devcontainer.env.require_env_vars","title":"<code>require_env_vars(env_vars)</code>","text":"<p>Require that the given environment variables are defined.</p> <p>Parameters:</p> Name Type Description Default <code>env_vars</code> <code>list[str]</code> <p>list of environment variables to check.</p> required <p>Returns:</p> Type Description <code>OneOf[MissingEnvVars, None]</code> <p>None if all environment variables are defined, otherwise a</p> <code>OneOf[MissingEnvVars, None]</code> <p>MissingEnvVars instance.</p> Source code in <code>m/devcontainer/env.py</code> <pre><code>def require_env_vars(env_vars: list[str]) -&gt; OneOf[MissingEnvVars, None]:\n    \"\"\"Require that the given environment variables are defined.\n\n    Args:\n        env_vars: list of environment variables to check.\n\n    Returns:\n        None if all environment variables are defined, otherwise a\n        MissingEnvVars instance.\n    \"\"\"\n    missing: list[str] = []\n    defined: dict[str, str] = {}\n    for env_var in env_vars:\n        env_var_value = os.environ.get(env_var)\n        if env_var_value is None:\n            missing.append(env_var)\n        else:\n            defined[env_var] = env_var_value\n    if missing:\n        return Bad(MissingEnvVars(missing=missing, defined=defined))\n    return Good(None)\n</code></pre>"},{"location":"api/m/devcontainer/greet/","title":"greet","text":""},{"location":"api/m/devcontainer/greet/#m.devcontainer.greet.greet","title":"<code>greet(img_name, img_version, changelog_url)</code>","text":"<p>Log an \"info\" message to the console stating that the container is ready.</p> <p>Parameters:</p> Name Type Description Default <code>img_name</code> <code>str</code> <p>The name of the image.</p> required <code>img_version</code> <code>str</code> <p>The version of the image.</p> required <code>changelog_url</code> <code>str | None</code> <p>The URL to the changelog.</p> required Source code in <code>m/devcontainer/greet.py</code> <pre><code>def greet(img_name: str, img_version: str, changelog_url: str | None) -&gt; None:\n    \"\"\"Log an \"info\" message to the console stating that the container is ready.\n\n    Args:\n        img_name: The name of the image.\n        img_version: The version of the image.\n        changelog_url: The URL to the changelog.\n    \"\"\"\n    logger = Logger(__name__)\n    context = {\n        'name': img_name,\n        'version': img_version,\n        'TIP': 'set `DEBUG`/`DEBUG_M_LOGS` to true to display debugging info',\n    }\n    if not img_version.startswith('0.0.0') and changelog_url:\n        context['changelog'] = f'{changelog_url}#{img_version}'\n    logger.info('container_ready', context=context)\n</code></pre>"},{"location":"api/m/devcontainer/pnpm/","title":"pnpm","text":""},{"location":"api/m/devcontainer/pnpm/#m.devcontainer.pnpm.PnpmSetupSummary","title":"<code>PnpmSetupSummary</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Summary of the pnpm setup operation.</p> <p>Attributes:</p> Name Type Description <code>node_modules</code> <code>str</code> <p>...</p> <code>package</code> <code>str</code> <p>...</p> <code>npmrc</code> <code>str</code> <p>...</p> <code>pnpm_lock</code> <code>str | None</code> <p>...</p> Source code in <code>m/devcontainer/pnpm.py</code> <pre><code>class PnpmSetupSummary(BaseModel):\n    \"\"\"Summary of the pnpm setup operation.\"\"\"\n\n    node_modules: str\n    package: str\n    npmrc: str\n    pnpm_lock: str | None\n</code></pre>"},{"location":"api/m/devcontainer/pnpm/#m.devcontainer.pnpm.create_symlink","title":"<code>create_symlink(link, source)</code>","text":"<p>Create a symlink that is linked to a source.</p> <p>This is a destructive operation - if the link exists it will be removed.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>Path</code> <p>The path to the link.</p> required <code>source</code> <code>Path</code> <p>The path to the source.</p> required Source code in <code>m/devcontainer/pnpm.py</code> <pre><code>def create_symlink(link: Path, source: Path) -&gt; None:\n    \"\"\"Create a symlink that is linked to a source.\n\n    This is a destructive operation - if the link exists it will be removed.\n\n    Args:\n        link: The path to the link.\n        source: The path to the source.\n    \"\"\"\n    if link.exists() or link.is_symlink():\n        link.unlink()\n    link.symlink_to(source)\n</code></pre>"},{"location":"api/m/devcontainer/pnpm/#m.devcontainer.pnpm.pnpm_setup","title":"<code>pnpm_setup(work_dir, pnpm_dir)</code>","text":"<p>Create symbolic links to a mounted volume.</p> <p>This is done so that pnpm may take advantage of the cache associated with a single pnpm store. When we execute <code>pnpm install</code> in the devcontainer we want to make sure that other containers may be able to share the pnpm cache. To do this we need all containers to use the same pnpm store.</p> <p>Parameters:</p> Name Type Description Default <code>work_dir</code> <code>str</code> <p>The directory where the project is mounted.</p> required <code>pnpm_dir</code> <code>str</code> <p>The directory where the project will execute pnpm commands.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>A <code>PnpmSetupSummary</code> instance.</p> Source code in <code>m/devcontainer/pnpm.py</code> <pre><code>def pnpm_setup(work_dir: str, pnpm_dir: str) -&gt; Res[None]:\n    \"\"\"Create symbolic links to a mounted volume.\n\n    This is done so that pnpm may take advantage of the cache associated with\n    a single pnpm store. When we execute `pnpm install` in the devcontainer\n    we want to make sure that other containers may be able to share the pnpm\n    cache. To do this we need all containers to use the same pnpm store.\n\n    Args:\n        work_dir: The directory where the project is mounted.\n        pnpm_dir: The directory where the project will execute pnpm commands.\n\n    Returns:\n        A `PnpmSetupSummary` instance.\n    \"\"\"\n    package_res = _setup_package(work_dir, pnpm_dir)\n    if isinstance(package_res, Bad):\n        return Bad(package_res.value)\n    package_summary = package_res.value\n\n    node_modules_res = _setup_node_modules(work_dir, pnpm_dir)\n    if isinstance(node_modules_res, Bad):\n        return Bad(node_modules_res.value)\n    node_modules_summary = node_modules_res.value\n\n    npmrc_res = _setup_npmrc(work_dir, pnpm_dir)\n    if isinstance(npmrc_res, Bad):\n        return Bad(npmrc_res.value)\n    npmrc_summary = npmrc_res.value\n\n    # perform a few checks with the lock file\n    work_lock = Path(work_dir) / 'pnpm-lock.yaml'\n    pnpm_lock_summary = None\n    if not work_lock.exists():\n        pnpm_lock_summary = f'MISSING {work_lock}'\n        logger.warning('pnpm_lock_missing', context={\n            'work_lock': pnpm_lock_summary,\n            SUGGESTION: 'run `pnpm install` to generate the lock file',\n        })\n    if work_lock.is_symlink():\n        pnpm_lock_summary = f'unlinked symlink {work_lock}'\n        work_lock.unlink()\n\n    summary = PnpmSetupSummary(\n        node_modules=node_modules_summary,\n        package=package_summary,\n        npmrc=npmrc_summary,\n        pnpm_lock=pnpm_lock_summary,\n    )\n    logger.debug('pnpm_setup_summary', context=summary.model_dump())\n    return Good(None)\n</code></pre>"},{"location":"api/m/devcontainer/pnpm/#m.devcontainer.pnpm.run_pnpm","title":"<code>run_pnpm(pnpm_args, *, force_cd)</code>","text":"<p>Execute the pnpm command with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>pnpm_args</code> <code>list[str]</code> <p>The arguments to pass to pnpm.</p> required <code>force_cd</code> <code>bool</code> <p>If True, change the working directory to the mounted volume.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>The exit code of the pnpm command.</p> Source code in <code>m/devcontainer/pnpm.py</code> <pre><code>def run_pnpm(pnpm_args: list[str], *, force_cd: bool) -&gt; Res[None]:\n    \"\"\"Execute the pnpm command with the given arguments.\n\n    Args:\n        pnpm_args: The arguments to pass to pnpm.\n        force_cd: If True, change the working directory to the mounted volume.\n\n    Returns:\n        The exit code of the pnpm command.\n    \"\"\"\n    workdir = str(Path.cwd())\n    workspace_res = _get_workspaces(workdir)\n    if isinstance(workspace_res, Bad):\n        return Bad(workspace_res.value)\n\n    workspace, pnpm_workspace = workspace_res.value\n    pnpm_command = pnpm_args[0] if pnpm_args else None\n    is_cd_command = pnpm_command in PNPM_MOUNTED_COMMANDS\n    if not force_cd and (not pnpm_command or not is_cd_command):\n        pnpm_res = sub.exec_pnpm(pnpm_args)\n        if isinstance(pnpm_res, Bad):\n            return pnpm_res\n        return Good(None)\n\n    if not Path(f'{workdir}/package.json').exists():\n        return issue('missing_package_json', context={\n            'workdir': workdir,\n            'warning': 'run pnpm commands in directories with package.json',\n        })\n    pnpm_dir = workdir.replace(workspace, pnpm_workspace, 1)\n    return _pnpm(workdir, pnpm_dir, pnpm_args)\n</code></pre>"},{"location":"api/m/devcontainer/prompter/","title":"prompter","text":""},{"location":"api/m/devcontainer/prompter/#m.devcontainer.prompter.prompter","title":"<code>prompter()</code>","text":"<p>Command line prompter.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string to be displayed in the prompt.</p> Source code in <code>m/devcontainer/prompter.py</code> <pre><code>def prompter() -&gt; str:\n    \"\"\"Command line prompter.\n\n    Returns:\n        The string to be displayed in the prompt.\n    \"\"\"\n    branch_res = git.get_branch()\n    if isinstance(branch_res, Bad):\n        return COL(r'\\[{orange}\\]\\w\\[{end}\\]$ ')\n    return _git_prompter(branch_res.value)\n</code></pre>"},{"location":"api/m/github/","title":"github","text":""},{"location":"api/m/github/api/","title":"api","text":""},{"location":"api/m/github/api/#m.github.api.GithubPullRequest","title":"<code>GithubPullRequest</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Data needed to create a pull request.</p> <p>Attributes:</p> Name Type Description <code>title</code> <code>str</code> <p>...</p> <code>body</code> <code>str</code> <p>...</p> <code>head</code> <code>str</code> <p>...</p> <code>base</code> <code>str</code> <p>...</p> Source code in <code>m/github/api.py</code> <pre><code>class GithubPullRequest(BaseModel):\n    \"\"\"Data needed to create a pull request.\"\"\"\n\n    title: str\n    body: str\n    head: str\n    base: str\n</code></pre>"},{"location":"api/m/github/api/#m.github.api.GithubShaStatus","title":"<code>GithubShaStatus</code>  <code>dataclass</code>","text":"<p>Data needed to create a pull request.</p> Source code in <code>m/github/api.py</code> <pre><code>@dataclass\nclass GithubShaStatus:\n    \"\"\"Data needed to create a pull request.\"\"\"\n\n    sha: str\n    context: str\n    state: str\n    description: str\n    url: Optional[str] = None\n</code></pre>"},{"location":"api/m/github/api/#m.github.api.commit_status","title":"<code>commit_status(token, owner, repo, sha_info)</code>","text":"<p>Set a status for a sha.</p> <p>The valid states are::</p> <ul> <li>pending</li> <li>success</li> <li>failure</li> <li>error</li> </ul> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>sha_info</code> <code>GithubShaStatus</code> <p>An instance of a <code>GithubShaStatus</code>.</p> required <p>Returns:</p> Type Description <code>Res[Any]</code> <p>The response from Github after setting a commit status.</p> Source code in <code>m/github/api.py</code> <pre><code>def commit_status(\n    token: str,\n    owner: str,\n    repo: str,\n    sha_info: GithubShaStatus,\n) -&gt; Res[Any]:\n    \"\"\"Set a status for a sha.\n\n    The valid states are::\n\n    - pending\n    - success\n    - failure\n    - error\n\n    Args:\n        token: A github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        sha_info: An instance of a `GithubShaStatus`.\n\n    Returns:\n        The response from Github after setting a commit status.\n    \"\"\"\n    endpoint = _repos(owner, repo, 'statuses', sha_info.sha)\n    payload = {\n        'context': sha_info.context,\n        'state': sha_info.state,\n        'description': sha_info.description,\n    }\n    if sha_info.url:\n        payload['target_url'] = sha_info.url\n    return request(token, endpoint, HttpMethod.post, payload)\n</code></pre>"},{"location":"api/m/github/api/#m.github.api.create_pr","title":"<code>create_pr(token, owner, repo, pr_info)</code>","text":"<p>Send a payload to create a pull request in github.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>pr_info</code> <code>GithubPullRequest</code> <p>The pull request information.</p> required <p>Returns:</p> Type Description <code>Res[Any]</code> <p>The Github response if successful.</p> Source code in <code>m/github/api.py</code> <pre><code>def create_pr(\n    token: str,\n    owner: str,\n    repo: str,\n    pr_info: GithubPullRequest,\n) -&gt; Res[Any]:\n    \"\"\"Send a payload to create a pull request in github.\n\n    Args:\n        token: A github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        pr_info: The pull request information.\n\n    Returns:\n        The Github response if successful.\n    \"\"\"\n    endpoint = _repos(owner, repo, 'pulls')\n    return request(token, endpoint, HttpMethod.post, pr_info.model_dump())\n</code></pre>"},{"location":"api/m/github/api/#m.github.api.create_release","title":"<code>create_release(token, owner, repo, version, branch=None)</code>","text":"<p>Send a payload to create a release in github.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>version</code> <code>str</code> <p>The version that marks the release.</p> required <code>branch</code> <code>str | None</code> <p>Optional branch to tag, defaults to the default branch.</p> <code>None</code> <p>Returns:</p> Type Description <code>Res[Any]</code> <p>The Github response after a release is created.</p> Source code in <code>m/github/api.py</code> <pre><code>def create_release(\n    token: str,\n    owner: str,\n    repo: str,\n    version: str,\n    branch: str | None = None,\n) -&gt; Res[Any]:\n    \"\"\"Send a payload to create a release in github.\n\n    Args:\n        token: A github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        version: The version that marks the release.\n        branch: Optional branch to tag, defaults to the default branch.\n\n    Returns:\n        The Github response after a release is created.\n    \"\"\"\n    endpoint = _repos(owner, repo, 'releases')\n    base = 'https://github.com'\n    link = f'{base}/{owner}/{repo}/blob/master/CHANGELOG.md#{version}'\n    payload = {\n        'tag_name': version,\n        'name': f'{version}',\n        'body': f'**See [CHANGELOG]({link}).**',\n        'draft': False,\n        'prerelease': False,\n    }\n    if branch:\n        payload['target_commitish'] = branch\n    return request(token, endpoint, HttpMethod.post, payload)\n</code></pre>"},{"location":"api/m/github/api/#m.github.api.merge_pr","title":"<code>merge_pr(token, owner, repo, pr_number, commit_title)</code>","text":"<p>Send a payload to merge a pull request in github.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>pr_number</code> <code>int</code> <p>The number of the pull request.</p> required <code>commit_title</code> <code>str | None</code> <p>An optional commit title to use when merging.</p> required <p>Returns:</p> Type Description <code>Res[Any]</code> <p>The payload provided by Github if successful.</p> Source code in <code>m/github/api.py</code> <pre><code>def merge_pr(\n    token: str,\n    owner: str,\n    repo: str,\n    pr_number: int,\n    commit_title: str | None,\n) -&gt; Res[Any]:\n    \"\"\"Send a payload to merge a pull request in github.\n\n    Args:\n        token: A github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        pr_number: The number of the pull request.\n        commit_title: An optional commit title to use when merging.\n\n    Returns:\n        The payload provided by Github if successful.\n    \"\"\"\n    endpoint = _repos(owner, repo, 'pulls', str(pr_number), 'merge')\n    payload = {'commit_title': commit_title} if commit_title else {}\n    return request(token, endpoint, HttpMethod.put, payload)\n</code></pre>"},{"location":"api/m/github/ci/","title":"ci","text":""},{"location":"api/m/github/ci/#m.github.ci.compare_sha_url","title":"<code>compare_sha_url(owner, repo, prev, nxt)</code>","text":"<p>Generate a url to compare two sha/tags in a github repo.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The repo owner.</p> required <code>repo</code> <code>str</code> <p>The repo name.</p> required <code>prev</code> <code>str</code> <p>The previous sha.</p> required <code>nxt</code> <code>str</code> <p>The next sha.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A url comparing two shas.</p> Source code in <code>m/github/ci.py</code> <pre><code>def compare_sha_url(owner: str, repo: str, prev: str, nxt: str) -&gt; str:\n    \"\"\"Generate a url to compare two sha/tags in a github repo.\n\n    Args:\n        owner: The repo owner.\n        repo: The repo name.\n        prev: The previous sha.\n        nxt: The next sha.\n\n    Returns:\n        A url comparing two shas.\n    \"\"\"\n    return f'https://github.com/{owner}/{repo}/compare/{prev}...{nxt}'\n</code></pre>"},{"location":"api/m/github/ci/#m.github.ci.create_ci_query","title":"<code>create_ci_query(pr_number=None, include_commit=False, include_release=False)</code>","text":"<p>Create github graphql query.</p> <p>The information provided is done via presets.</p> <p>Parameters:</p> Name Type Description Default <code>pr_number</code> <code>int | None</code> <p>If included, it will add pull request information.</p> <code>None</code> <code>include_commit</code> <code>bool</code> <p>If true, include commit information.</p> <code>False</code> <code>include_release</code> <code>bool</code> <p>If true, include release information.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string with the graphql query.</p> Source code in <code>m/github/ci.py</code> <pre><code>def create_ci_query(\n    pr_number: int | None = None,\n    include_commit: bool = False,\n    include_release: bool = False,\n) -&gt; str:\n    \"\"\"Create github graphql query.\n\n    The information provided is done via presets.\n\n    Args:\n        pr_number: If included, it will add pull request information.\n        include_commit: If true, include commit information.\n        include_release: If true, include release information.\n\n    Returns:\n        A string with the graphql query.\n    \"\"\"\n    query_items: list[str] = []\n    query_params: list[str] = ['$owner: String!', '$repo: String!']\n    if include_commit:\n        include_pr = pr_number is None\n        query_items.append(commit_query(include_pr, include_author=True))\n        query_params.append('$sha: String')\n    if pr_number:\n        query_items.append(PULL_REQUEST)\n        query_params.append('$pr: Int!')\n        query_params.append('$fc: Int!')\n    if include_release:\n        query_items.append(LATEST_RELEASE)\n    items_str = '\\n'.join(query_items)\n    params_str = ', '.join(query_params)\n    return f\"\"\"query ({params_str}) {{\n      repository(owner:$owner, name:$repo) {{\n        {items_str}\n      }}\n    }}\"\"\"\n</code></pre>"},{"location":"api/m/github/ci/#m.github.ci.get_build_sha","title":"<code>get_build_sha(token, owner, repo, sha)</code>","text":"<p>Obtain the commit sha in a pull request.</p> <p>When building prs, we are not given the actual sha of the commit.</p> <p>Instead, we get the sha of the merge commit. This will give us the sha that we are looking for.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>sha</code> <code>str</code> <p>The merge sha provided by github.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>The actual sha of the commit.</p> Source code in <code>m/github/ci.py</code> <pre><code>def get_build_sha(\n    token: str,\n    owner: str,\n    repo: str,\n    sha: str,\n) -&gt; OneOf[Issue, str]:\n    \"\"\"Obtain the commit sha in a pull request.\n\n    When building prs, we are not given the actual sha of the commit.\n\n    Instead, we get the sha of the merge commit. This will give us the\n    sha that we are looking for.\n\n    Args:\n        token: A Github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        sha: The merge sha provided by github.\n\n    Returns:\n        The actual sha of the commit.\n    \"\"\"\n    query_params = ['$owner: String!', '$repo: String!', '$sha: String!']\n    params_str = ', '.join(query_params)\n    commit_query_str = commit_query(include_pr=False, include_author=False)\n    query = f\"\"\"query ({params_str}) {{\n      repository(owner:$owner, name:$repo) {{\n        {commit_query_str}\n      }}\n    }}\"\"\"\n    variables = {\n        'owner': owner,\n        'repo': repo,\n        'sha': sha,\n    }\n    return one_of(\n        lambda: [\n            _parse_commit_message(commit_msg, sha)\n            for res in api.graphql(token, query, variables)\n            for commit_msg in get(res, 'repository.commit.message')\n        ],\n    )\n</code></pre>"},{"location":"api/m/github/ci/#m.github.ci.get_ci_run_info","title":"<code>get_ci_run_info(token, commit_info, pr_number, file_count, include_release)</code>","text":"<p>Transform the result from get_raw_ci_run_info to a GithubCiRunInfo.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>commit_info</code> <code>CommitInfo</code> <p>An instance of a commit info.</p> required <code>pr_number</code> <code>int | None</code> <p>An optional pull request number.</p> required <code>file_count</code> <code>int</code> <p>The maximum number of files to report.</p> required <code>include_release</code> <code>bool</code> <p>If true it will provide release information.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, GithubCiRunInfo]</code> <p>If successful, a <code>GithubCiRunInfo</code> instance.</p> Source code in <code>m/github/ci.py</code> <pre><code>def get_ci_run_info(\n    token: str,\n    commit_info: CommitInfo,\n    pr_number: int | None,\n    file_count: int,\n    include_release: bool,\n) -&gt; OneOf[Issue, GithubCiRunInfo]:\n    \"\"\"Transform the result from get_raw_ci_run_info to a GithubCiRunInfo.\n\n    Args:\n        token: A Github PAT.\n        commit_info: An instance of a commit info.\n        pr_number: An optional pull request number.\n        file_count: The maximum number of files to report.\n        include_release: If true it will provide release information.\n\n    Returns:\n        If successful, a `GithubCiRunInfo` instance.\n    \"\"\"\n    raw_res = get_raw_ci_run_info(\n        token,\n        commit_info,\n        pr_number,\n        file_count,\n        include_release,\n    )\n    return one_of(\n        lambda: [\n            GithubCiRunInfo(commit=commit, pull_request=pr, release=release)\n            for raw in raw_res\n            for release in _get_release(raw)\n            for commit in _get_commit(commit_info.owner, commit_info.repo, raw)\n            for pr in _get_pull_request(raw, pr_number)\n        ],\n    )\n</code></pre>"},{"location":"api/m/github/ci/#m.github.ci.get_raw_ci_run_info","title":"<code>get_raw_ci_run_info(token, commit_info, pr_number, file_count, include_release, get_sha=True)</code>","text":"<p>Retrieve the information of the given Github PR.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>commit_info</code> <code>CommitInfo</code> <p>The owner, repo and sha.</p> required <code>pr_number</code> <code>int | None</code> <p>The pull request number.</p> required <code>file_count</code> <code>int</code> <p>The maximum number of files in the pr to retrieve.</p> required <code>include_release</code> <code>bool</code> <p>If true it will provide release information.</p> required <code>get_sha</code> <code>bool</code> <p>If true, it will obtain the actual sha of the commit.</p> <code>True</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>The Github payload with the raw information.</p> Source code in <code>m/github/ci.py</code> <pre><code>def get_raw_ci_run_info(\n    token: str,\n    commit_info: CommitInfo,\n    pr_number: int | None,\n    file_count: int,\n    include_release: bool,\n    get_sha: bool = True,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Retrieve the information of the given Github PR.\n\n    Args:\n        token: A Github PAT.\n        commit_info: The owner, repo and sha.\n        pr_number: The pull request number.\n        file_count:  The maximum number of files in the pr to retrieve.\n        include_release: If true it will provide release information.\n        get_sha: If true, it will obtain the actual sha of the commit.\n\n    Returns:\n        The Github payload with the raw information.\n    \"\"\"\n    query = create_ci_query(\n        pr_number,\n        include_commit=True,\n        include_release=include_release,\n    )\n    owner, repo, sha = [commit_info.owner, commit_info.repo, commit_info.sha]\n    variables = {'owner': owner, 'repo': repo, 'sha': sha, 'fc': file_count}\n    if pr_number:\n        variables['pr'] = pr_number\n    if get_sha:\n        build_sha = get_build_sha(token, owner, repo, sha)\n        if build_sha.is_bad:\n            return build_sha\n        variables['sha'] = non_issue(build_sha)\n    return one_of(lambda: [\n        repo_data\n        for res in api.graphql(token, query, variables)\n        for repo_data in get(res, 'repository')\n    ])\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/","title":"ci_dataclasses","text":""},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.AssociatedPullRequest","title":"<code>AssociatedPullRequest</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Information for commits that are associated with a pull request.</p> <p>Attributes:</p> Name Type Description <code>author</code> <code>Author</code> <p>...</p> <code>merged</code> <code>bool</code> <p>...</p> <code>pr_number</code> <code>int</code> <p>...</p> <code>target_branch</code> <code>str</code> <p>...</p> <code>target_sha</code> <code>str</code> <p>...</p> <code>pr_branch</code> <code>str</code> <p>...</p> <code>pr_sha</code> <code>str</code> <p>...</p> <code>title</code> <code>str</code> <p>...</p> <code>body</code> <code>str</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class AssociatedPullRequest(BaseModel):\n    \"\"\"Information for commits that are associated with a pull request.\"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    author: Author\n    merged: bool\n    pr_number: int\n    target_branch: str\n    target_sha: str\n    pr_branch: str\n    pr_sha: str\n    title: str\n    body: str\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.Author","title":"<code>Author</code>","text":"<p>             Bases: <code>CamelModel</code></p> <p>An object representing a committer.</p> <p>Attributes:</p> Name Type Description <code>login</code> <code>str</code> <p>...</p> <code>avatar_url</code> <code>str | None</code> <p>...</p> <code>email</code> <code>str | None</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class Author(CamelModel):\n    \"\"\"An object representing a committer.\"\"\"\n\n    login: str\n    avatar_url: str | None = None\n    email: str | None = None\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.Commit","title":"<code>Commit</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The git commit info.</p> <p>Attributes:</p> Name Type Description <code>author_login</code> <code>str</code> <p>...</p> <code>short_sha</code> <code>str</code> <p>...</p> <code>sha</code> <code>str</code> <p>...</p> <code>message</code> <code>str</code> <p>...</p> <code>url</code> <code>str</code> <p>...</p> <code>associated_pull_request</code> <code>Optional[AssociatedPullRequest]</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class Commit(BaseModel):\n    \"\"\"The git commit info.\"\"\"\n\n    author_login: str\n    short_sha: str\n    sha: str\n    message: str\n    url: str\n    associated_pull_request: Optional[AssociatedPullRequest] = None\n\n    def get_pr_branch(self) -&gt; str:\n        \"\"\"Find the git branch if commit has an associated pr.\n\n        Returns:\n            The pr branch if the commit has an associated pr or empty\n            string.\n        \"\"\"\n        if not self.associated_pull_request:\n            return ''\n        return self.associated_pull_request.pr_branch\n\n    def is_release(self, release_prefix: str | None) -&gt; bool:\n        \"\"\"Determine if the current commit should create a release.\n\n        Args:\n            release_prefix: The prefix used to flag a release.\n\n        Returns:\n            True if we are dealing with a release branch.\n        \"\"\"\n        if not release_prefix:\n            return False\n        return self.get_pr_branch().startswith(f'{release_prefix}/')\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.Commit.get_pr_branch","title":"<code>get_pr_branch()</code>","text":"<p>Find the git branch if commit has an associated pr.</p> <p>Returns:</p> Type Description <code>str</code> <p>The pr branch if the commit has an associated pr or empty</p> <code>str</code> <p>string.</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>def get_pr_branch(self) -&gt; str:\n    \"\"\"Find the git branch if commit has an associated pr.\n\n    Returns:\n        The pr branch if the commit has an associated pr or empty\n        string.\n    \"\"\"\n    if not self.associated_pull_request:\n        return ''\n    return self.associated_pull_request.pr_branch\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.Commit.is_release","title":"<code>is_release(release_prefix)</code>","text":"<p>Determine if the current commit should create a release.</p> <p>Parameters:</p> Name Type Description Default <code>release_prefix</code> <code>str | None</code> <p>The prefix used to flag a release.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if we are dealing with a release branch.</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>def is_release(self, release_prefix: str | None) -&gt; bool:\n    \"\"\"Determine if the current commit should create a release.\n\n    Args:\n        release_prefix: The prefix used to flag a release.\n\n    Returns:\n        True if we are dealing with a release branch.\n    \"\"\"\n    if not release_prefix:\n        return False\n    return self.get_pr_branch().startswith(f'{release_prefix}/')\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.CommitInfo","title":"<code>CommitInfo</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A commit can be tracked with the following properties.</p> <p>Attributes:</p> Name Type Description <code>owner</code> <code>str</code> <p>...</p> <code>repo</code> <code>str</code> <p>...</p> <code>sha</code> <code>str</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class CommitInfo(BaseModel):\n    \"\"\"A commit can be tracked with the following properties.\"\"\"\n\n    owner: str\n    repo: str\n    sha: str\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.GithubCiRunInfo","title":"<code>GithubCiRunInfo</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The main information we need for a ci run.</p> <p>Attributes:</p> Name Type Description <code>commit</code> <code>Commit</code> <p>...</p> <code>pull_request</code> <code>Optional[PullRequest]</code> <p>...</p> <code>release</code> <code>Optional[Release]</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class GithubCiRunInfo(BaseModel):\n    \"\"\"The main information we need for a ci run.\"\"\"\n\n    commit: Commit\n    pull_request: Optional[PullRequest] = None\n    release: Optional[Release] = None\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.PullRequest","title":"<code>PullRequest</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Pull request information.</p> <p>Attributes:</p> Name Type Description <code>author</code> <code>Author</code> <p>...</p> <code>pr_number</code> <code>int</code> <p>...</p> <code>pr_branch</code> <code>str</code> <p>...</p> <code>target_branch</code> <code>str</code> <p>...</p> <code>target_sha</code> <code>str</code> <p>...</p> <code>url</code> <code>str</code> <p>...</p> <code>title</code> <code>str</code> <p>...</p> <code>body</code> <code>str</code> <p>...</p> <code>file_count</code> <code>int</code> <p>...</p> <code>files</code> <code>List[str]</code> <p>...</p> <code>is_draft</code> <code>bool</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class PullRequest(BaseModel):\n    \"\"\"Pull request information.\"\"\"\n\n    author: Author\n    pr_number: int\n    pr_branch: str\n    target_branch: str\n    target_sha: str\n    url: str\n    title: str\n    body: str\n    file_count: int\n    files: List[str]\n    is_draft: bool\n\n    def changelog_updated(self) -&gt; bool:\n        \"\"\"Determine if the changelog was updated in the pull request.\n\n        Returns:\n            True if the changelog was updated.\n        \"\"\"\n        return 'CHANGELOG.md' in self.files\n\n    def is_release_pr(self, release_prefix: str | None) -&gt; bool:\n        \"\"\"Determine if the pull request is a release pull request.\n\n        Args:\n            release_prefix: The prefix used to flag a release.\n\n        Returns:\n            True if we are dealing with a release branch.\n        \"\"\"\n        if not release_prefix:\n            return False\n        return self.pr_branch.startswith(f'{release_prefix}/')\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.PullRequest.changelog_updated","title":"<code>changelog_updated()</code>","text":"<p>Determine if the changelog was updated in the pull request.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the changelog was updated.</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>def changelog_updated(self) -&gt; bool:\n    \"\"\"Determine if the changelog was updated in the pull request.\n\n    Returns:\n        True if the changelog was updated.\n    \"\"\"\n    return 'CHANGELOG.md' in self.files\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.PullRequest.is_release_pr","title":"<code>is_release_pr(release_prefix)</code>","text":"<p>Determine if the pull request is a release pull request.</p> <p>Parameters:</p> Name Type Description Default <code>release_prefix</code> <code>str | None</code> <p>The prefix used to flag a release.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if we are dealing with a release branch.</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>def is_release_pr(self, release_prefix: str | None) -&gt; bool:\n    \"\"\"Determine if the pull request is a release pull request.\n\n    Args:\n        release_prefix: The prefix used to flag a release.\n\n    Returns:\n        True if we are dealing with a release branch.\n    \"\"\"\n    if not release_prefix:\n        return False\n    return self.pr_branch.startswith(f'{release_prefix}/')\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.Release","title":"<code>Release</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Github release &lt;==&gt; Git tag.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>...</p> <code>tag_name</code> <code>str</code> <p>...</p> <code>published_at</code> <code>str</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class Release(BaseModel):\n    \"\"\"Github release &lt;==&gt; Git tag.\"\"\"\n\n    name: str\n    tag_name: str\n    published_at: str\n</code></pre>"},{"location":"api/m/github/ci_graph_queries/","title":"ci_graph_queries","text":""},{"location":"api/m/github/ci_graph_queries/#m.github.ci_graph_queries.commit_query","title":"<code>commit_query(include_pr, include_author)</code>","text":"<p>Build a graphql query for github.</p> <p>The output of this function is meant to go inside the repository field.</p> <p>Parameters:</p> Name Type Description Default <code>include_pr</code> <code>bool</code> <p>If true, it will include pull request information.</p> required <code>include_author</code> <code>bool</code> <p>If true, it will include user information.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A valid graphql query.</p> Source code in <code>m/github/ci_graph_queries.py</code> <pre><code>def commit_query(include_pr: bool, include_author: bool) -&gt; str:\n    \"\"\"Build a graphql query for github.\n\n    The output of this function is meant to go inside the repository\n    field.\n\n    Args:\n        include_pr: If true, it will include pull request information.\n        include_author: If true, it will include user information.\n\n    Returns:\n        A valid graphql query.\n    \"\"\"\n    author = \"\"\"\n      author {\n        name\n        email\n        user {\n          login\n        }\n      }\n      oid\n    \"\"\" if include_author else ''\n    pr = \"\"\"\n      associatedPullRequests(first: 1) {\n        nodes {\n          author {\n            login\n            avatarUrl(size: 50)\n            ... on User {\n              email\n            }\n          }\n          number\n          title\n          body\n          baseRefName\n          baseRefOid\n          headRefName\n          headRefOid\n          merged\n        }\n      }\n    \"\"\" if include_pr else ''\n    return f\"\"\"\n      commit: object(expression: $sha) {{\n        ... on Commit {{\n          message\n          {author}\n          {pr}\n        }}\n      }}\n    \"\"\"\n</code></pre>"},{"location":"api/m/github/cli/","title":"cli","text":""},{"location":"api/m/github/cli/#m.github.cli.get_latest_release","title":"<code>get_latest_release(token, owner, repo)</code>","text":"<p>Retrieve the latest release for a repo.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>The latest release.</p> Source code in <code>m/github/cli.py</code> <pre><code>def get_latest_release(\n    token: str,\n    owner: str,\n    repo: str,\n) -&gt; OneOf[Issue, str]:\n    \"\"\"Retrieve the latest release for a repo.\n\n    Args:\n        token: A Github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n\n    Returns:\n        The latest release.\n    \"\"\"\n    query = \"\"\"query ($owner: String!, $repo: String!) {\n      repository(owner:$owner, name:$repo) {\n         releases(last: 1, orderBy: {field: CREATED_AT, direction: ASC}) {\n            nodes {\n                name\n                tagName\n                publishedAt\n            }\n        }\n      }\n    }\"\"\"\n    variables = {'owner': owner, 'repo': repo}\n    return one_of(\n        lambda: [\n            tag_name\n            for res in graphql(token, query, variables)\n            for releases in get(res, 'repository.releases.nodes')\n            for tag_name in _get_latest_release(releases)\n        ],\n    )\n</code></pre>"},{"location":"api/m/github/cli/#m.github.cli.get_pr_info","title":"<code>get_pr_info(token, owner, repo, pr_number, file_count)</code>","text":"<p>Retrieve the information of the given Github PR.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>pr_number</code> <code>int</code> <p>The pull request number in question.</p> required <code>file_count</code> <code>int</code> <p>The maximum number of files in the pr to retrieve.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>The pull request information.</p> Source code in <code>m/github/cli.py</code> <pre><code>def get_pr_info(\n    token: str,\n    owner: str,\n    repo: str,\n    pr_number: int,\n    file_count: int,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Retrieve the information of the given Github PR.\n\n    Args:\n        token: A Github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        pr_number: The pull request number in question.\n        file_count: The maximum number of files in the pr to retrieve.\n\n    Returns:\n        The pull request information.\n    \"\"\"\n    query = create_ci_query(\n        pr_number,\n        include_commit=False,\n        include_release=False,\n    )\n    variables = {\n        'owner': owner,\n        'repo': repo,\n        'pr': pr_number,\n        'fc': file_count,\n    }\n    return one_of(\n        lambda: [\n            pr_info\n            for res in graphql(token, query, variables)\n            for pr_info in get(res, 'repository.pullRequest')\n        ],\n    )\n</code></pre>"},{"location":"api/m/github/request/","title":"request","text":""},{"location":"api/m/github/request/#m.github.request.request","title":"<code>request(token, endpoint, method=http.HttpMethod.get, dict_data=None)</code>","text":"<p>Make an api request to github.</p> <p>See::</p> <pre><code>- https://docs.github.com/en/rest/overview/resources-in-the-rest-api\n- https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github personal access token.</p> required <code>endpoint</code> <code>str</code> <p>A github api endpoint.</p> required <code>method</code> <code>HttpMethod</code> <p>The http method to use. (default 'GET')</p> <code>get</code> <code>dict_data</code> <code>object | None</code> <p>A payload if the method if <code>POST</code> or <code>GET</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A response from Github.</p> Source code in <code>m/github/request.py</code> <pre><code>def request(\n    token: str,\n    endpoint: str,\n    method: http.HttpMethod = http.HttpMethod.get,\n    dict_data: object | None = None,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Make an api request to github.\n\n    See::\n\n        - https://docs.github.com/en/rest/overview/resources-in-the-rest-api\n        - https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps\n\n    Args:\n        token: A github personal access token.\n        endpoint: A github api endpoint.\n        method: The http method to use. (default 'GET')\n        dict_data: A payload if the method if `POST` or `GET`.\n\n    Returns:\n        A response from Github.\n    \"\"\"\n    url = f'https://api.github.com{endpoint}'\n    headers = {'authorization': f'Bearer {token}'}\n    return http.fetch_json(url, headers, method, dict_data)\n</code></pre>"},{"location":"api/m/github/actions/","title":"actions","text":""},{"location":"api/m/github/actions/#m.github.actions.Action","title":"<code>Action</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A Github action.</p> <p>The main object to help us define the <code>actions.yaml</code> file. Each repository can declare several actions. For this reason we can declare the <code>actions</code> object as a single <code>Action</code> or a list of them.</p> <p>We could technically do everything in one single step but when we use external actions then we are forced to split the step. Note that we have no way of having the <code>if</code> fields in each step. This is because we are encouraged to handle that logic in each of the steps we declare. We have full control of the output to <code>stdout</code> and <code>stderr</code> here.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>str</code> <p>The full path to the <code>action.yaml</code> file.</p> <code>name</code> <code>str</code> <p>The name of the action.</p> <code>description</code> <code>str</code> <p>Short description for the action.</p> <code>inputs</code> <code>type[KebabModel] | None</code> <p>A model describing the inputs for the action. If the action does not need inputs then provide <code>None</code>. It is important to be explicit in this step so that we do not wonder why we cannot use <code>inputs.[argname]</code> when we declare a step.</p> <code>steps</code> <code>list[RunStep | UsesStep]</code> <p>The steps for the action</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>class Action(BaseModel):\n    \"\"\"A Github action.\n\n    The main object to help us define the `actions.yaml` file. Each repository can\n    declare several actions. For this reason we can declare the `actions` object as\n    a single `Action` or a list of them.\n\n    We could technically do everything in one single step but when we use external\n    actions then we are forced to split the step. Note that we have no way of\n    having the `if` fields in each step. This is because we are encouraged to handle\n    that logic in each of the steps we declare. We have full control of the output to\n    `stdout` and `stderr` here.\n    \"\"\"\n\n    file_path: str = Field(description='The full path to the `action.yaml` file.')\n\n    name: str = Field(description='The name of the action.')\n\n    description: str = Field(description='Short description for the action.')\n\n    inputs: type[KebabModel] | None = Field(description=\"\"\"\n        A model describing the inputs for the action. If the action does not\n        need inputs then provide `None`. It is important to be explicit in this step\n        so that we do not wonder why we cannot use `inputs.[argname]` when we declare a\n        step.\n    \"\"\")\n\n    steps: list[RunStep | UsesStep] = Field(\n        description='The steps for the action',\n    )\n\n    def gather_outputs(self: 'Action') -&gt; Res[ActionOutputs]:\n        \"\"\"Obtain a tuple with the action outputs and all steps outputs.\n\n        The steps outputs is a dictionary that maps keys of the form\n        [step_id].[step_output_arg] to the output of another step, action\n        input or some other value that should be used as input.\n\n        This function validates that all the keys are valid.\n\n        Returns:\n            A tuple with the outputs if successful, otherwise an issue.\n        \"\"\"\n        action_inputs = self.inputs or KebabModel\n        available_outputs: dict[str, str] = {\n            f'inputs.{name}': f'inputs.{arg_info.alias}'\n            for name, arg_info in action_inputs.model_fields.items()\n        }\n\n        outputs: dict[str, MetadataOutput] = {}\n        all_issues: dict[str, list[dict]] = {}\n        for step in self.steps:\n            input_model, output_model = step.get_inputs_outputs()\n            output_fields = OutputField.create(step.id, output_model)\n            # mypy has trouble seeing that its bound to KebabModel\n            self_args = cast(KebabModel, step.args)\n            all_args = self_args.model_dump() if self_args else {}\n            issues = verify_inputs(input_model, all_args, available_outputs)\n            if issues:\n                all_issues[step.id] = [\n                    iss.model_dump(exclude_none=True)\n                    for iss in issues\n                ]\n            for name, field in output_fields.items():\n                short_name = field.short_ref_name\n                available_outputs[short_name] = field.full_ref_name\n                if field.is_export:\n                    outputs[name] = field.get_metadata_output()\n        if all_issues:\n            return issue('step_inputs_failure', context=all_issues)\n        return Good((outputs, available_outputs))\n</code></pre>"},{"location":"api/m/github/actions/#m.github.actions.Action.gather_outputs","title":"<code>gather_outputs()</code>","text":"<p>Obtain a tuple with the action outputs and all steps outputs.</p> <p>The steps outputs is a dictionary that maps keys of the form [step_id].[step_output_arg] to the output of another step, action input or some other value that should be used as input.</p> <p>This function validates that all the keys are valid.</p> <p>Returns:</p> Type Description <code>Res[ActionOutputs]</code> <p>A tuple with the outputs if successful, otherwise an issue.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def gather_outputs(self: 'Action') -&gt; Res[ActionOutputs]:\n    \"\"\"Obtain a tuple with the action outputs and all steps outputs.\n\n    The steps outputs is a dictionary that maps keys of the form\n    [step_id].[step_output_arg] to the output of another step, action\n    input or some other value that should be used as input.\n\n    This function validates that all the keys are valid.\n\n    Returns:\n        A tuple with the outputs if successful, otherwise an issue.\n    \"\"\"\n    action_inputs = self.inputs or KebabModel\n    available_outputs: dict[str, str] = {\n        f'inputs.{name}': f'inputs.{arg_info.alias}'\n        for name, arg_info in action_inputs.model_fields.items()\n    }\n\n    outputs: dict[str, MetadataOutput] = {}\n    all_issues: dict[str, list[dict]] = {}\n    for step in self.steps:\n        input_model, output_model = step.get_inputs_outputs()\n        output_fields = OutputField.create(step.id, output_model)\n        # mypy has trouble seeing that its bound to KebabModel\n        self_args = cast(KebabModel, step.args)\n        all_args = self_args.model_dump() if self_args else {}\n        issues = verify_inputs(input_model, all_args, available_outputs)\n        if issues:\n            all_issues[step.id] = [\n                iss.model_dump(exclude_none=True)\n                for iss in issues\n            ]\n        for name, field in output_fields.items():\n            short_name = field.short_ref_name\n            available_outputs[short_name] = field.full_ref_name\n            if field.is_export:\n                outputs[name] = field.get_metadata_output()\n    if all_issues:\n        return issue('step_inputs_failure', context=all_issues)\n    return Good((outputs, available_outputs))\n</code></pre>"},{"location":"api/m/github/actions/#m.github.actions.KebabModel","title":"<code>KebabModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Allows models to be defined with kebab case properties.</p> <p>Inputs and outputs need to be written using a <code>KebabModel</code> as a base class. This is so that their definitions may be written using kebab casing in the final <code>action.yaml</code>.</p> <pre><code>from m.github.actions import KebabModel, InArg\n\nclass MyInput(KebabModel):\n    my_input: str = InArg(help='description')\n</code></pre> Source code in <code>m/pydantic.py</code> <pre><code>class KebabModel(BaseModel):\n    \"\"\"Allows models to be defined with kebab case properties.\n\n    Inputs and outputs need to be written using a `KebabModel` as a base class.\n    This is so that their definitions may be written using kebab casing in the\n    final `action.yaml`.\n\n    ```python\n    from m.github.actions import KebabModel, InArg\n\n    class MyInput(KebabModel):\n        my_input: str = InArg(help='description')\n    ```\n    \"\"\"\n\n    model_config = ConfigDict(\n        alias_generator=to_kebab,\n        populate_by_name=True,\n    )\n</code></pre>"},{"location":"api/m/github/actions/#m.github.actions.RunStep","title":"<code>RunStep</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[InputModel, OutputModel]</code></p> <p>Model used to define a \"run\" step in a Github action.</p> <p>The <code>id</code> is important because this is how we will be able to refer to the outputs generated by the step. Say our action called other external actions such as the cache action. Then if we wanted to pass one of the outputs to the cache action we would have to get a handle on the step.</p> <pre><code>args=SomeInput(some_arg='my_run_step_id.some_output')\n</code></pre> <p>The <code>args</code> should leverage the help of their own input models. All they require is that we provide the handle to other outputs from other steps or some other values we wish to pass.</p> <p>Experiment with different values to see what <code>action.yaml</code> generates.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The id of the step.</p> <code>run_if</code> <code>str | None</code> <p>The condition to run the step.</p> <code>run</code> <code>Callable[[InputModel], Res[OutputModel]]</code> <p>The function passed to <code>run_action</code>.</p> <code>args</code> <code>InputModel | None</code> <p>The arguments to pass to the run function.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>class RunStep(BaseModel, Generic[InputModel, OutputModel]):\n    \"\"\"Model used to define a \"run\" step in a Github action.\n\n    The `id` is important because this is how we will be able to refer to the\n    outputs generated by the step. Say our action called other external actions\n    such as the cache action. Then if we wanted to pass one of the outputs to\n    the cache action we would have to get a handle on the step.\n\n    ```python\n    args=SomeInput(some_arg='my_run_step_id.some_output')\n    ```\n\n    The `args` should leverage the help of their own input models. All they\n    require is that we provide the handle to other outputs from other steps or\n    some other values we wish to pass.\n\n    Experiment with different values to see what `action.yaml` generates.\n    \"\"\"\n\n    id: str = Field(description='The id of the step.')\n\n    run_if: str | None = Field(\n        default=None,\n        description='The condition to run the step.',\n    )\n\n    run: Callable[[InputModel], Res[OutputModel]] = Field(\n        description='The function passed to [`run_action`][m.github.actions.api.run_action].',\n    )\n\n    args: InputModel | None = Field(\n        description='The arguments to pass to the run function.',\n    )\n\n    def get_inputs_outputs(self: 'RunStep') -&gt; InputOutputs:\n        \"\"\"Get the inputs and outputs for the step.\n\n        Returns:\n            A tuple of the inputs and outputs.\n        \"\"\"\n        return get_inputs_outputs(self.run)\n\n    def to_str(\n        self: 'RunStep',\n        python_path: str,\n        available_values: dict[str, str],\n    ) -&gt; str:\n        \"\"\"Generate a string to use in the Github Action.\n\n        Args:\n            python_path: The path to the python module.\n            available_values: The values that are available to the step.\n\n        Returns:\n            A string to add to the Github action.\n        \"\"\"\n        template = \"\"\"\\\n            - id: {id}{run_if}\n              shell: bash{env}\n              run: PYTHONPATH=\"$GITHUB_ACTION_PATH{py_path}\" python -m {mod}\n        \"\"\"\n        run_if = _run_if(self.run_if, available_values)\n        # mypy has trouble seeing that its bound to KebabModel\n        self_args = cast(KebabModel, self.args)\n        all_args = self_args.model_dump() if self_args else {}\n        mapped_args = map_args(all_args, available_values, input_env)\n        env = ''\n        if mapped_args:\n            arg_lines = '\\n'.join([\n                f'    {key}: {env_val}'\n                for key, env_val in mapped_args.items()\n            ])\n            env = f'\\n  env:\\n{arg_lines}'\n        py_path = f'/{python_path}' if python_path else ''\n        return dedent(template).format(\n            id=self.id,\n            env=env,\n            run_if=run_if,\n            py_path=py_path,\n            mod=self.run.__module__,\n        ).rstrip()\n</code></pre>"},{"location":"api/m/github/actions/#m.github.actions.RunStep.get_inputs_outputs","title":"<code>get_inputs_outputs()</code>","text":"<p>Get the inputs and outputs for the step.</p> <p>Returns:</p> Type Description <code>InputOutputs</code> <p>A tuple of the inputs and outputs.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def get_inputs_outputs(self: 'RunStep') -&gt; InputOutputs:\n    \"\"\"Get the inputs and outputs for the step.\n\n    Returns:\n        A tuple of the inputs and outputs.\n    \"\"\"\n    return get_inputs_outputs(self.run)\n</code></pre>"},{"location":"api/m/github/actions/#m.github.actions.RunStep.to_str","title":"<code>to_str(python_path, available_values)</code>","text":"<p>Generate a string to use in the Github Action.</p> <p>Parameters:</p> Name Type Description Default <code>python_path</code> <code>str</code> <p>The path to the python module.</p> required <code>available_values</code> <code>dict[str, str]</code> <p>The values that are available to the step.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github action.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def to_str(\n    self: 'RunStep',\n    python_path: str,\n    available_values: dict[str, str],\n) -&gt; str:\n    \"\"\"Generate a string to use in the Github Action.\n\n    Args:\n        python_path: The path to the python module.\n        available_values: The values that are available to the step.\n\n    Returns:\n        A string to add to the Github action.\n    \"\"\"\n    template = \"\"\"\\\n        - id: {id}{run_if}\n          shell: bash{env}\n          run: PYTHONPATH=\"$GITHUB_ACTION_PATH{py_path}\" python -m {mod}\n    \"\"\"\n    run_if = _run_if(self.run_if, available_values)\n    # mypy has trouble seeing that its bound to KebabModel\n    self_args = cast(KebabModel, self.args)\n    all_args = self_args.model_dump() if self_args else {}\n    mapped_args = map_args(all_args, available_values, input_env)\n    env = ''\n    if mapped_args:\n        arg_lines = '\\n'.join([\n            f'    {key}: {env_val}'\n            for key, env_val in mapped_args.items()\n        ])\n        env = f'\\n  env:\\n{arg_lines}'\n    py_path = f'/{python_path}' if python_path else ''\n    return dedent(template).format(\n        id=self.id,\n        env=env,\n        run_if=run_if,\n        py_path=py_path,\n        mod=self.run.__module__,\n    ).rstrip()\n</code></pre>"},{"location":"api/m/github/actions/#m.github.actions.UsesStep","title":"<code>UsesStep</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[InputModel, OutputModel]</code></p> <p>A \"uses\" step in a Github action.</p> <p>Model similar to <code>RunStep</code> but since we do not have access to the code that gets executed all we can do is provide the <code>uses</code> field and our models to describe what the action expects.</p> <p>For instance, say we wanted to use the <code>actions/cache@v4</code> action. To avoid having issues in the future we should create the input and output models manually by looking at the documentation https://github.com/actions/cache#inputs.</p> <pre><code>class CacheInputs(KebabModel):\n    key: str = InArg(help='An explicit key for a cache entry')\n    path: str = InArg(help=\"\"\"\n        A list of files, directories, and wildcard patterns to cache and\n        restore.\n    \"\"\")\n</code></pre> <p>Similarly for the outputs we can define a model. This in the long run should help us maintain the composite action better. It is recommended to check the inputs and outputs as we update action versions to ensure compatibility.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The step id.</p> <code>run_if</code> <code>str | None</code> <p>The condition to run the step.</p> <code>uses</code> <code>str</code> <p>A string referencing an action.</p> <code>inputs</code> <code>type[InputModel]</code> <p>A reference to a KebabModel type.</p> <code>outputs</code> <code>type[OutputModel]</code> <p>A reference to a KebabModel type.</p> <code>args</code> <code>InputModel | None</code> <p>The arguments to pass to the action</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>class UsesStep(BaseModel, Generic[InputModel, OutputModel]):\n    \"\"\"A \"uses\" step in a Github action.\n\n    Model similar to [`RunStep`][m.github.actions.RunStep] but since we do\n    not have access to the code that gets executed all we can do is provide the\n    `uses` field and our models to describe what the action expects.\n\n    For instance, say we wanted to use the `actions/cache@v4` action. To avoid\n    having issues in the future we should create the input and output models\n    manually by looking at the documentation\n    &lt;https://github.com/actions/cache#inputs&gt;.\n\n    ```python\n    class CacheInputs(KebabModel):\n        key: str = InArg(help='An explicit key for a cache entry')\n        path: str = InArg(help=\\\"\\\"\\\"\n            A list of files, directories, and wildcard patterns to cache and\n            restore.\n        \\\"\\\"\\\")\n    ```\n\n    Similarly for the outputs we can define a model. This in the long run should\n    help us maintain the composite action better. It is recommended to check the\n    inputs and outputs as we update action versions to ensure compatibility.\n    \"\"\"  # noqa: D301, D300 - Angry with slash but we need to escape them\n\n    id: str = Field(description='The step id.')\n\n    run_if: str | None = Field(\n        default=None,\n        description='The condition to run the step.',\n    )\n\n    uses: str = Field(description='A string referencing an action.')\n\n    inputs: type[InputModel] = Field(\n        description='A reference to a [KebabModel][m.pydantic.KebabModel] type.',\n    )\n\n    outputs: type[OutputModel] = Field(\n        description='A reference to a [KebabModel][m.pydantic.KebabModel] type.',\n    )\n\n    args: InputModel | None = Field(\n        description='The arguments to pass to the action',\n    )\n\n    def get_inputs_outputs(self: 'UsesStep') -&gt; InputOutputs:\n        \"\"\"Get the inputs and outputs for the step.\n\n        Returns:\n            A tuple of the inputs and outputs.\n        \"\"\"\n        return self.inputs, self.outputs\n\n    def to_str(\n        self: 'UsesStep',\n        _python_path: str,\n        available_values: dict[str, str],\n    ) -&gt; str:\n        \"\"\"Generate a string to use in the Github Action.\n\n        Args:\n            _python_path: The path to the python module.\n            available_values: The values that are available to the step.\n\n        Returns:\n            A string to add to the Github action.\n        \"\"\"\n        template = \"\"\"\\\n            - id: {id}{run_if}\n              uses: {uses}{env}\n        \"\"\"\n        run_if = _run_if(self.run_if, available_values)\n        # mypy has trouble seeing that its bound to KebabModel\n        self_args = cast(KebabModel, self.args)\n        all_args = self_args.model_dump() if self_args else {}\n        mapped_args = map_args(\n            all_args,\n            available_values,\n            lambda x: x.replace('_', '-', -1),\n        )\n        env = ''\n        if mapped_args:\n            arg_lines = '\\n'.join([\n                f'    {key}: {env_val}'\n                for key, env_val in mapped_args.items()\n            ])\n            env = f'\\n  with:\\n{arg_lines}'\n        return dedent(template).format(\n            id=self.id,\n            run_if=run_if,\n            uses=self.uses,\n            env=env,\n        ).rstrip()\n</code></pre>"},{"location":"api/m/github/actions/#m.github.actions.UsesStep.get_inputs_outputs","title":"<code>get_inputs_outputs()</code>","text":"<p>Get the inputs and outputs for the step.</p> <p>Returns:</p> Type Description <code>InputOutputs</code> <p>A tuple of the inputs and outputs.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def get_inputs_outputs(self: 'UsesStep') -&gt; InputOutputs:\n    \"\"\"Get the inputs and outputs for the step.\n\n    Returns:\n        A tuple of the inputs and outputs.\n    \"\"\"\n    return self.inputs, self.outputs\n</code></pre>"},{"location":"api/m/github/actions/#m.github.actions.UsesStep.to_str","title":"<code>to_str(_python_path, available_values)</code>","text":"<p>Generate a string to use in the Github Action.</p> <p>Parameters:</p> Name Type Description Default <code>_python_path</code> <code>str</code> <p>The path to the python module.</p> required <code>available_values</code> <code>dict[str, str]</code> <p>The values that are available to the step.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github action.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def to_str(\n    self: 'UsesStep',\n    _python_path: str,\n    available_values: dict[str, str],\n) -&gt; str:\n    \"\"\"Generate a string to use in the Github Action.\n\n    Args:\n        _python_path: The path to the python module.\n        available_values: The values that are available to the step.\n\n    Returns:\n        A string to add to the Github action.\n    \"\"\"\n    template = \"\"\"\\\n        - id: {id}{run_if}\n          uses: {uses}{env}\n    \"\"\"\n    run_if = _run_if(self.run_if, available_values)\n    # mypy has trouble seeing that its bound to KebabModel\n    self_args = cast(KebabModel, self.args)\n    all_args = self_args.model_dump() if self_args else {}\n    mapped_args = map_args(\n        all_args,\n        available_values,\n        lambda x: x.replace('_', '-', -1),\n    )\n    env = ''\n    if mapped_args:\n        arg_lines = '\\n'.join([\n            f'    {key}: {env_val}'\n            for key, env_val in mapped_args.items()\n        ])\n        env = f'\\n  with:\\n{arg_lines}'\n    return dedent(template).format(\n        id=self.id,\n        run_if=run_if,\n        uses=self.uses,\n        env=env,\n    ).rstrip()\n</code></pre>"},{"location":"api/m/github/actions/#m.github.actions.InArg","title":"<code>InArg(*, help, default=None)</code>","text":"<p>Force proper annotation of the input of a GitHub Action.</p> <p>Should be used to declare the input arguments of an action. It returns <code>Any</code> to bypass <code>mypy</code>'s type checking. Similar to pydantic.fields.Field but it is tailored to help us write the inputs for an action and its steps.</p> <p>Note</p> <p>By default all input arguments are required. If you want to make an input not required then provide a default value.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>Human-readable description.</p> required <code>default</code> <code>str | None</code> <p>The default value for the argument.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>, the return annotation is <code>Any</code> so <code>InArg</code> can be used on type annotated fields without causing typing errors.</p> Source code in <code>m/github/actions/api.py</code> <pre><code>def InArg(  # noqa: N802\n    *,\n    help: str,  # noqa: WPS125\n    default: str | None = None,\n) -&gt; Any:\n    \"\"\"Force proper annotation of the input of a GitHub Action.\n\n    Should be used to declare the input arguments of an action. It returns\n    [`Any`][typing.Any] to bypass `mypy`'s type checking. Similar to\n    [pydantic.fields.Field][] but it is tailored to help us write the inputs for\n    an action and its steps.\n\n    !!! note\n\n        By default all input arguments are required. If you want to make an\n        input not required then provide a default value.\n\n    Args:\n        help: Human-readable description.\n        default: The default value for the argument.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo], the return annotation is\n            `Any` so `InArg` can be used on type annotated fields without\n            causing typing errors.\n    \"\"\"\n    args = {\n        'description': help,\n    }\n    if default is not None:\n        args['default'] = default\n    return FieldInfo.from_field(**args)\n</code></pre>"},{"location":"api/m/github/actions/#m.github.actions.OutArg","title":"<code>OutArg(*, help, export=False)</code>","text":"<p>Force proper annotation of the output of a GitHub Action.</p> <p>Note</p> <p>All steps have access to the steps output, if we want to make the output available to the action we need to <code>export</code> it.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>Human-readable description.</p> required <code>export</code> <code>bool</code> <p>Whether the argument is to be exported to the action.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>, the return annotation is <code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/github/actions/api.py</code> <pre><code>def OutArg(  # noqa: N802\n    *,\n    help: str,  # noqa: WPS125\n    export: bool = False,\n) -&gt; Any:\n    \"\"\"Force proper annotation of the output of a GitHub Action.\n\n    !!! note\n        All steps have access to the steps output, if we want to make the output\n        available to the action we need to `export` it.\n\n    Args:\n        help: Human-readable description.\n        export: Whether the argument is to be exported to the action.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo], the return annotation is\n            `Any` so `Arg` can be used on type annotated fields without causing\n            a typing error.\n    \"\"\"\n    return FieldInfo.from_field(\n        description=help,\n        json_schema_extra={'export': export},\n    )\n</code></pre>"},{"location":"api/m/github/actions/#m.github.actions.run_action","title":"<code>run_action(main)</code>","text":"<p>Entry point for a GitHub Action.</p> <p>This is the main function that should be used to run an action. It takes in a function that takes in a m.pydantic.KebabModel and returns a <code>Res[KebabModel]</code>.</p> <p>The only place where this function is needed is in the the if block</p> <pre><code>if __name__ == '__main__':\n    run_action(my_action)\n</code></pre> <p><code>mypy</code> will make sure that the you are providing the correct type of function to <code>run_action</code>. Keep in mind, the function is generic and we should be writing models for the inputs and outputs for all of our functions.</p> <p>Parameters:</p> Name Type Description Default <code>main</code> <code>Callable[[InputModel], Res[OutputModel]]</code> <p>The main function of the GitHub Action.</p> required Source code in <code>m/github/actions/api.py</code> <pre><code>def run_action(main: Callable[[InputModel], Res[OutputModel]]) -&gt; None:\n    \"\"\"Entry point for a GitHub Action.\n\n    This is the main function that should be used to run an action. It takes in\n    a function that takes in a [m.pydantic.KebabModel][] and returns a\n    `Res[KebabModel]`.\n\n    The only place where this function is needed is in the the if block\n\n    ```python\n    if __name__ == '__main__':\n        run_action(my_action)\n    ```\n\n    `mypy` will make sure that the you are providing the correct type of function\n    to `run_action`. Keep in mind, the function is generic and we should be writing\n    models for the inputs and outputs for all of our functions.\n\n    Args:\n        main: The main function of the GitHub Action.\n    \"\"\"\n    logging_config()\n    main_params = signature(main).parameters\n    arg_name = next(iter(main_params))\n    input_model = main_params[arg_name].annotation\n    args = load_step_inputs(input_model)\n    if isinstance(args, Bad):\n        default_issue_handler(args.value)\n        sys.exit(4)\n    inputs = args.value\n    exit_code = run_main(lambda: main(inputs), result_handler=_result_handler)\n    sys.exit(exit_code)\n</code></pre>"},{"location":"api/m/github/actions/action_file/","title":"action_file","text":""},{"location":"api/m/github/actions/action_file/#m.github.actions.action_file.ActionFile","title":"<code>ActionFile</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Helper class to write the action file.</p> <p>Attributes:</p> Name Type Description <code>py_path</code> <code>str</code> <p>...</p> <code>module_name</code> <code>str</code> <p>...</p> <code>name</code> <code>str</code> <p>...</p> <code>description</code> <code>str</code> <p>...</p> <code>action</code> <code>Action</code> <p>...</p> <code>inputs</code> <code>type[KebabModel]</code> <p>...</p> <code>outputs</code> <code>dict[str, MetadataOutput]</code> <p>...</p> <code>python_path</code> <code>str</code> <p>...</p> <code>available_outputs</code> <code>dict[str, str]</code> <p>...</p> Source code in <code>m/github/actions/action_file.py</code> <pre><code>class ActionFile(BaseModel):\n    \"\"\"Helper class to write the action file.\"\"\"\n\n    py_path: str\n\n    module_name: str\n\n    name: str\n\n    description: str\n\n    action: Action\n\n    inputs: type[KebabModel]\n\n    outputs: dict[str, MetadataOutput]\n\n    python_path: str\n\n    available_outputs: dict[str, str]\n\n    def build_inputs(self: 'ActionFile') -&gt; str:\n        \"\"\"Generate the inputs for the action.\n\n        Returns:\n            A string to add to the Github action.\n        \"\"\"\n        all_inputs: dict[str, InputInfo] = {}\n        for prop_name, prop_info in self.inputs.model_fields.items():\n            input_info: InputInfo = {\n                'description': prop_info.description or '',\n                'required': prop_info.is_required(),\n            }\n            default_val = prop_info.get_default()\n            if default_val is not PydanticUndefined:\n                input_info['default'] = default_val\n            all_inputs[prop_info.alias or prop_name] = input_info\n        if not all_inputs:\n            return f' {EMPTY_DICT}'\n        str_inputs = _indent(yaml.dumps(all_inputs), 1)\n        return f'\\n  {str_inputs}'\n\n    def build_outputs(\n        self: 'ActionFile',\n        outputs: dict[str, MetadataOutput],\n    ) -&gt; str:\n        \"\"\"Generate the outputs for the action.\n\n        Args:\n            outputs: The outputs to add to the action.\n\n        Returns:\n            A string to add to the Github action.\n        \"\"\"\n        if not outputs:\n            return f' {EMPTY_DICT}'\n        raw_data = {\n            output_name.replace('_', '-', -1): output_val.model_dump()\n            for output_name, output_val in outputs.items()\n        }\n        str_outputs = _indent(yaml.dumps(raw_data), 1)\n        return f'\\n  {str_outputs}'\n\n    def build_steps_str(self: 'ActionFile') -&gt; str:\n        \"\"\"Generate a github action str for the build steps.\n\n        Returns:\n            A string to add to the Github action.\n        \"\"\"\n        lines: list[str] = [\n            step.to_str(self.python_path, self.available_outputs)\n            for step in self.action.steps\n        ]\n        return _indent('\\n'.join(lines), 2)\n\n    def __str__(self: 'ActionFile') -&gt; str:\n        \"\"\"Stringify the action file.\n\n        Returns:\n            The github action.\n        \"\"\"\n        template_vars = TemplateVars(\n            py_path=self.py_path,\n            module_name=self.module_name.replace('.', '/', -1),\n            name=self.name,\n            description=self.description,\n            inputs=self.build_inputs(),\n            outputs=self.build_outputs(self.outputs),\n            steps=self.build_steps_str(),\n        )\n        file_content = TEMPLATE.format(**template_vars.model_dump())\n        return '\\n'.join([\n            line.rstrip()\n            for line in file_content.split('\\n')\n        ])\n</code></pre>"},{"location":"api/m/github/actions/action_file/#m.github.actions.action_file.ActionFile.__str__","title":"<code>__str__()</code>","text":"<p>Stringify the action file.</p> <p>Returns:</p> Type Description <code>str</code> <p>The github action.</p> Source code in <code>m/github/actions/action_file.py</code> <pre><code>def __str__(self: 'ActionFile') -&gt; str:\n    \"\"\"Stringify the action file.\n\n    Returns:\n        The github action.\n    \"\"\"\n    template_vars = TemplateVars(\n        py_path=self.py_path,\n        module_name=self.module_name.replace('.', '/', -1),\n        name=self.name,\n        description=self.description,\n        inputs=self.build_inputs(),\n        outputs=self.build_outputs(self.outputs),\n        steps=self.build_steps_str(),\n    )\n    file_content = TEMPLATE.format(**template_vars.model_dump())\n    return '\\n'.join([\n        line.rstrip()\n        for line in file_content.split('\\n')\n    ])\n</code></pre>"},{"location":"api/m/github/actions/action_file/#m.github.actions.action_file.ActionFile.build_inputs","title":"<code>build_inputs()</code>","text":"<p>Generate the inputs for the action.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github action.</p> Source code in <code>m/github/actions/action_file.py</code> <pre><code>def build_inputs(self: 'ActionFile') -&gt; str:\n    \"\"\"Generate the inputs for the action.\n\n    Returns:\n        A string to add to the Github action.\n    \"\"\"\n    all_inputs: dict[str, InputInfo] = {}\n    for prop_name, prop_info in self.inputs.model_fields.items():\n        input_info: InputInfo = {\n            'description': prop_info.description or '',\n            'required': prop_info.is_required(),\n        }\n        default_val = prop_info.get_default()\n        if default_val is not PydanticUndefined:\n            input_info['default'] = default_val\n        all_inputs[prop_info.alias or prop_name] = input_info\n    if not all_inputs:\n        return f' {EMPTY_DICT}'\n    str_inputs = _indent(yaml.dumps(all_inputs), 1)\n    return f'\\n  {str_inputs}'\n</code></pre>"},{"location":"api/m/github/actions/action_file/#m.github.actions.action_file.ActionFile.build_outputs","title":"<code>build_outputs(outputs)</code>","text":"<p>Generate the outputs for the action.</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>dict[str, MetadataOutput]</code> <p>The outputs to add to the action.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github action.</p> Source code in <code>m/github/actions/action_file.py</code> <pre><code>def build_outputs(\n    self: 'ActionFile',\n    outputs: dict[str, MetadataOutput],\n) -&gt; str:\n    \"\"\"Generate the outputs for the action.\n\n    Args:\n        outputs: The outputs to add to the action.\n\n    Returns:\n        A string to add to the Github action.\n    \"\"\"\n    if not outputs:\n        return f' {EMPTY_DICT}'\n    raw_data = {\n        output_name.replace('_', '-', -1): output_val.model_dump()\n        for output_name, output_val in outputs.items()\n    }\n    str_outputs = _indent(yaml.dumps(raw_data), 1)\n    return f'\\n  {str_outputs}'\n</code></pre>"},{"location":"api/m/github/actions/action_file/#m.github.actions.action_file.ActionFile.build_steps_str","title":"<code>build_steps_str()</code>","text":"<p>Generate a github action str for the build steps.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github action.</p> Source code in <code>m/github/actions/action_file.py</code> <pre><code>def build_steps_str(self: 'ActionFile') -&gt; str:\n    \"\"\"Generate a github action str for the build steps.\n\n    Returns:\n        A string to add to the Github action.\n    \"\"\"\n    lines: list[str] = [\n        step.to_str(self.python_path, self.available_outputs)\n        for step in self.action.steps\n    ]\n    return _indent('\\n'.join(lines), 2)\n</code></pre>"},{"location":"api/m/github/actions/action_file/#m.github.actions.action_file.TemplateVars","title":"<code>TemplateVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Template variables.</p> <p>Attributes:</p> Name Type Description <code>py_path</code> <code>str</code> <p>...</p> <code>module_name</code> <code>str</code> <p>...</p> <code>name</code> <code>str</code> <p>...</p> <code>description</code> <code>str</code> <p>...</p> <code>inputs</code> <code>str</code> <p>...</p> <code>outputs</code> <code>str</code> <p>...</p> <code>steps</code> <code>str</code> <p>...</p> Source code in <code>m/github/actions/action_file.py</code> <pre><code>class TemplateVars(BaseModel):\n    \"\"\"Template variables.\"\"\"\n\n    py_path: str\n\n    module_name: str\n\n    name: str\n\n    description: str\n\n    inputs: str\n\n    outputs: str\n\n    steps: str\n</code></pre>"},{"location":"api/m/github/actions/actions/","title":"actions","text":""},{"location":"api/m/github/actions/actions/#m.github.actions.actions.Action","title":"<code>Action</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A Github action.</p> <p>The main object to help us define the <code>actions.yaml</code> file. Each repository can declare several actions. For this reason we can declare the <code>actions</code> object as a single <code>Action</code> or a list of them.</p> <p>We could technically do everything in one single step but when we use external actions then we are forced to split the step. Note that we have no way of having the <code>if</code> fields in each step. This is because we are encouraged to handle that logic in each of the steps we declare. We have full control of the output to <code>stdout</code> and <code>stderr</code> here.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>str</code> <p>The full path to the <code>action.yaml</code> file.</p> <code>name</code> <code>str</code> <p>The name of the action.</p> <code>description</code> <code>str</code> <p>Short description for the action.</p> <code>inputs</code> <code>type[KebabModel] | None</code> <p>A model describing the inputs for the action. If the action does not need inputs then provide <code>None</code>. It is important to be explicit in this step so that we do not wonder why we cannot use <code>inputs.[argname]</code> when we declare a step.</p> <code>steps</code> <code>list[RunStep | UsesStep]</code> <p>The steps for the action</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>class Action(BaseModel):\n    \"\"\"A Github action.\n\n    The main object to help us define the `actions.yaml` file. Each repository can\n    declare several actions. For this reason we can declare the `actions` object as\n    a single `Action` or a list of them.\n\n    We could technically do everything in one single step but when we use external\n    actions then we are forced to split the step. Note that we have no way of\n    having the `if` fields in each step. This is because we are encouraged to handle\n    that logic in each of the steps we declare. We have full control of the output to\n    `stdout` and `stderr` here.\n    \"\"\"\n\n    file_path: str = Field(description='The full path to the `action.yaml` file.')\n\n    name: str = Field(description='The name of the action.')\n\n    description: str = Field(description='Short description for the action.')\n\n    inputs: type[KebabModel] | None = Field(description=\"\"\"\n        A model describing the inputs for the action. If the action does not\n        need inputs then provide `None`. It is important to be explicit in this step\n        so that we do not wonder why we cannot use `inputs.[argname]` when we declare a\n        step.\n    \"\"\")\n\n    steps: list[RunStep | UsesStep] = Field(\n        description='The steps for the action',\n    )\n\n    def gather_outputs(self: 'Action') -&gt; Res[ActionOutputs]:\n        \"\"\"Obtain a tuple with the action outputs and all steps outputs.\n\n        The steps outputs is a dictionary that maps keys of the form\n        [step_id].[step_output_arg] to the output of another step, action\n        input or some other value that should be used as input.\n\n        This function validates that all the keys are valid.\n\n        Returns:\n            A tuple with the outputs if successful, otherwise an issue.\n        \"\"\"\n        action_inputs = self.inputs or KebabModel\n        available_outputs: dict[str, str] = {\n            f'inputs.{name}': f'inputs.{arg_info.alias}'\n            for name, arg_info in action_inputs.model_fields.items()\n        }\n\n        outputs: dict[str, MetadataOutput] = {}\n        all_issues: dict[str, list[dict]] = {}\n        for step in self.steps:\n            input_model, output_model = step.get_inputs_outputs()\n            output_fields = OutputField.create(step.id, output_model)\n            # mypy has trouble seeing that its bound to KebabModel\n            self_args = cast(KebabModel, step.args)\n            all_args = self_args.model_dump() if self_args else {}\n            issues = verify_inputs(input_model, all_args, available_outputs)\n            if issues:\n                all_issues[step.id] = [\n                    iss.model_dump(exclude_none=True)\n                    for iss in issues\n                ]\n            for name, field in output_fields.items():\n                short_name = field.short_ref_name\n                available_outputs[short_name] = field.full_ref_name\n                if field.is_export:\n                    outputs[name] = field.get_metadata_output()\n        if all_issues:\n            return issue('step_inputs_failure', context=all_issues)\n        return Good((outputs, available_outputs))\n</code></pre>"},{"location":"api/m/github/actions/actions/#m.github.actions.actions.Action.gather_outputs","title":"<code>gather_outputs()</code>","text":"<p>Obtain a tuple with the action outputs and all steps outputs.</p> <p>The steps outputs is a dictionary that maps keys of the form [step_id].[step_output_arg] to the output of another step, action input or some other value that should be used as input.</p> <p>This function validates that all the keys are valid.</p> <p>Returns:</p> Type Description <code>Res[ActionOutputs]</code> <p>A tuple with the outputs if successful, otherwise an issue.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def gather_outputs(self: 'Action') -&gt; Res[ActionOutputs]:\n    \"\"\"Obtain a tuple with the action outputs and all steps outputs.\n\n    The steps outputs is a dictionary that maps keys of the form\n    [step_id].[step_output_arg] to the output of another step, action\n    input or some other value that should be used as input.\n\n    This function validates that all the keys are valid.\n\n    Returns:\n        A tuple with the outputs if successful, otherwise an issue.\n    \"\"\"\n    action_inputs = self.inputs or KebabModel\n    available_outputs: dict[str, str] = {\n        f'inputs.{name}': f'inputs.{arg_info.alias}'\n        for name, arg_info in action_inputs.model_fields.items()\n    }\n\n    outputs: dict[str, MetadataOutput] = {}\n    all_issues: dict[str, list[dict]] = {}\n    for step in self.steps:\n        input_model, output_model = step.get_inputs_outputs()\n        output_fields = OutputField.create(step.id, output_model)\n        # mypy has trouble seeing that its bound to KebabModel\n        self_args = cast(KebabModel, step.args)\n        all_args = self_args.model_dump() if self_args else {}\n        issues = verify_inputs(input_model, all_args, available_outputs)\n        if issues:\n            all_issues[step.id] = [\n                iss.model_dump(exclude_none=True)\n                for iss in issues\n            ]\n        for name, field in output_fields.items():\n            short_name = field.short_ref_name\n            available_outputs[short_name] = field.full_ref_name\n            if field.is_export:\n                outputs[name] = field.get_metadata_output()\n    if all_issues:\n        return issue('step_inputs_failure', context=all_issues)\n    return Good((outputs, available_outputs))\n</code></pre>"},{"location":"api/m/github/actions/actions/#m.github.actions.actions.RunStep","title":"<code>RunStep</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[InputModel, OutputModel]</code></p> <p>Model used to define a \"run\" step in a Github action.</p> <p>The <code>id</code> is important because this is how we will be able to refer to the outputs generated by the step. Say our action called other external actions such as the cache action. Then if we wanted to pass one of the outputs to the cache action we would have to get a handle on the step.</p> <pre><code>args=SomeInput(some_arg='my_run_step_id.some_output')\n</code></pre> <p>The <code>args</code> should leverage the help of their own input models. All they require is that we provide the handle to other outputs from other steps or some other values we wish to pass.</p> <p>Experiment with different values to see what <code>action.yaml</code> generates.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The id of the step.</p> <code>run_if</code> <code>str | None</code> <p>The condition to run the step.</p> <code>run</code> <code>Callable[[InputModel], Res[OutputModel]]</code> <p>The function passed to <code>run_action</code>.</p> <code>args</code> <code>InputModel | None</code> <p>The arguments to pass to the run function.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>class RunStep(BaseModel, Generic[InputModel, OutputModel]):\n    \"\"\"Model used to define a \"run\" step in a Github action.\n\n    The `id` is important because this is how we will be able to refer to the\n    outputs generated by the step. Say our action called other external actions\n    such as the cache action. Then if we wanted to pass one of the outputs to\n    the cache action we would have to get a handle on the step.\n\n    ```python\n    args=SomeInput(some_arg='my_run_step_id.some_output')\n    ```\n\n    The `args` should leverage the help of their own input models. All they\n    require is that we provide the handle to other outputs from other steps or\n    some other values we wish to pass.\n\n    Experiment with different values to see what `action.yaml` generates.\n    \"\"\"\n\n    id: str = Field(description='The id of the step.')\n\n    run_if: str | None = Field(\n        default=None,\n        description='The condition to run the step.',\n    )\n\n    run: Callable[[InputModel], Res[OutputModel]] = Field(\n        description='The function passed to [`run_action`][m.github.actions.api.run_action].',\n    )\n\n    args: InputModel | None = Field(\n        description='The arguments to pass to the run function.',\n    )\n\n    def get_inputs_outputs(self: 'RunStep') -&gt; InputOutputs:\n        \"\"\"Get the inputs and outputs for the step.\n\n        Returns:\n            A tuple of the inputs and outputs.\n        \"\"\"\n        return get_inputs_outputs(self.run)\n\n    def to_str(\n        self: 'RunStep',\n        python_path: str,\n        available_values: dict[str, str],\n    ) -&gt; str:\n        \"\"\"Generate a string to use in the Github Action.\n\n        Args:\n            python_path: The path to the python module.\n            available_values: The values that are available to the step.\n\n        Returns:\n            A string to add to the Github action.\n        \"\"\"\n        template = \"\"\"\\\n            - id: {id}{run_if}\n              shell: bash{env}\n              run: PYTHONPATH=\"$GITHUB_ACTION_PATH{py_path}\" python -m {mod}\n        \"\"\"\n        run_if = _run_if(self.run_if, available_values)\n        # mypy has trouble seeing that its bound to KebabModel\n        self_args = cast(KebabModel, self.args)\n        all_args = self_args.model_dump() if self_args else {}\n        mapped_args = map_args(all_args, available_values, input_env)\n        env = ''\n        if mapped_args:\n            arg_lines = '\\n'.join([\n                f'    {key}: {env_val}'\n                for key, env_val in mapped_args.items()\n            ])\n            env = f'\\n  env:\\n{arg_lines}'\n        py_path = f'/{python_path}' if python_path else ''\n        return dedent(template).format(\n            id=self.id,\n            env=env,\n            run_if=run_if,\n            py_path=py_path,\n            mod=self.run.__module__,\n        ).rstrip()\n</code></pre>"},{"location":"api/m/github/actions/actions/#m.github.actions.actions.RunStep.get_inputs_outputs","title":"<code>get_inputs_outputs()</code>","text":"<p>Get the inputs and outputs for the step.</p> <p>Returns:</p> Type Description <code>InputOutputs</code> <p>A tuple of the inputs and outputs.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def get_inputs_outputs(self: 'RunStep') -&gt; InputOutputs:\n    \"\"\"Get the inputs and outputs for the step.\n\n    Returns:\n        A tuple of the inputs and outputs.\n    \"\"\"\n    return get_inputs_outputs(self.run)\n</code></pre>"},{"location":"api/m/github/actions/actions/#m.github.actions.actions.RunStep.to_str","title":"<code>to_str(python_path, available_values)</code>","text":"<p>Generate a string to use in the Github Action.</p> <p>Parameters:</p> Name Type Description Default <code>python_path</code> <code>str</code> <p>The path to the python module.</p> required <code>available_values</code> <code>dict[str, str]</code> <p>The values that are available to the step.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github action.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def to_str(\n    self: 'RunStep',\n    python_path: str,\n    available_values: dict[str, str],\n) -&gt; str:\n    \"\"\"Generate a string to use in the Github Action.\n\n    Args:\n        python_path: The path to the python module.\n        available_values: The values that are available to the step.\n\n    Returns:\n        A string to add to the Github action.\n    \"\"\"\n    template = \"\"\"\\\n        - id: {id}{run_if}\n          shell: bash{env}\n          run: PYTHONPATH=\"$GITHUB_ACTION_PATH{py_path}\" python -m {mod}\n    \"\"\"\n    run_if = _run_if(self.run_if, available_values)\n    # mypy has trouble seeing that its bound to KebabModel\n    self_args = cast(KebabModel, self.args)\n    all_args = self_args.model_dump() if self_args else {}\n    mapped_args = map_args(all_args, available_values, input_env)\n    env = ''\n    if mapped_args:\n        arg_lines = '\\n'.join([\n            f'    {key}: {env_val}'\n            for key, env_val in mapped_args.items()\n        ])\n        env = f'\\n  env:\\n{arg_lines}'\n    py_path = f'/{python_path}' if python_path else ''\n    return dedent(template).format(\n        id=self.id,\n        env=env,\n        run_if=run_if,\n        py_path=py_path,\n        mod=self.run.__module__,\n    ).rstrip()\n</code></pre>"},{"location":"api/m/github/actions/actions/#m.github.actions.actions.UsesStep","title":"<code>UsesStep</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[InputModel, OutputModel]</code></p> <p>A \"uses\" step in a Github action.</p> <p>Model similar to <code>RunStep</code> but since we do not have access to the code that gets executed all we can do is provide the <code>uses</code> field and our models to describe what the action expects.</p> <p>For instance, say we wanted to use the <code>actions/cache@v4</code> action. To avoid having issues in the future we should create the input and output models manually by looking at the documentation https://github.com/actions/cache#inputs.</p> <pre><code>class CacheInputs(KebabModel):\n    key: str = InArg(help='An explicit key for a cache entry')\n    path: str = InArg(help=\"\"\"\n        A list of files, directories, and wildcard patterns to cache and\n        restore.\n    \"\"\")\n</code></pre> <p>Similarly for the outputs we can define a model. This in the long run should help us maintain the composite action better. It is recommended to check the inputs and outputs as we update action versions to ensure compatibility.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The step id.</p> <code>run_if</code> <code>str | None</code> <p>The condition to run the step.</p> <code>uses</code> <code>str</code> <p>A string referencing an action.</p> <code>inputs</code> <code>type[InputModel]</code> <p>A reference to a KebabModel type.</p> <code>outputs</code> <code>type[OutputModel]</code> <p>A reference to a KebabModel type.</p> <code>args</code> <code>InputModel | None</code> <p>The arguments to pass to the action</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>class UsesStep(BaseModel, Generic[InputModel, OutputModel]):\n    \"\"\"A \"uses\" step in a Github action.\n\n    Model similar to [`RunStep`][m.github.actions.RunStep] but since we do\n    not have access to the code that gets executed all we can do is provide the\n    `uses` field and our models to describe what the action expects.\n\n    For instance, say we wanted to use the `actions/cache@v4` action. To avoid\n    having issues in the future we should create the input and output models\n    manually by looking at the documentation\n    &lt;https://github.com/actions/cache#inputs&gt;.\n\n    ```python\n    class CacheInputs(KebabModel):\n        key: str = InArg(help='An explicit key for a cache entry')\n        path: str = InArg(help=\\\"\\\"\\\"\n            A list of files, directories, and wildcard patterns to cache and\n            restore.\n        \\\"\\\"\\\")\n    ```\n\n    Similarly for the outputs we can define a model. This in the long run should\n    help us maintain the composite action better. It is recommended to check the\n    inputs and outputs as we update action versions to ensure compatibility.\n    \"\"\"  # noqa: D301, D300 - Angry with slash but we need to escape them\n\n    id: str = Field(description='The step id.')\n\n    run_if: str | None = Field(\n        default=None,\n        description='The condition to run the step.',\n    )\n\n    uses: str = Field(description='A string referencing an action.')\n\n    inputs: type[InputModel] = Field(\n        description='A reference to a [KebabModel][m.pydantic.KebabModel] type.',\n    )\n\n    outputs: type[OutputModel] = Field(\n        description='A reference to a [KebabModel][m.pydantic.KebabModel] type.',\n    )\n\n    args: InputModel | None = Field(\n        description='The arguments to pass to the action',\n    )\n\n    def get_inputs_outputs(self: 'UsesStep') -&gt; InputOutputs:\n        \"\"\"Get the inputs and outputs for the step.\n\n        Returns:\n            A tuple of the inputs and outputs.\n        \"\"\"\n        return self.inputs, self.outputs\n\n    def to_str(\n        self: 'UsesStep',\n        _python_path: str,\n        available_values: dict[str, str],\n    ) -&gt; str:\n        \"\"\"Generate a string to use in the Github Action.\n\n        Args:\n            _python_path: The path to the python module.\n            available_values: The values that are available to the step.\n\n        Returns:\n            A string to add to the Github action.\n        \"\"\"\n        template = \"\"\"\\\n            - id: {id}{run_if}\n              uses: {uses}{env}\n        \"\"\"\n        run_if = _run_if(self.run_if, available_values)\n        # mypy has trouble seeing that its bound to KebabModel\n        self_args = cast(KebabModel, self.args)\n        all_args = self_args.model_dump() if self_args else {}\n        mapped_args = map_args(\n            all_args,\n            available_values,\n            lambda x: x.replace('_', '-', -1),\n        )\n        env = ''\n        if mapped_args:\n            arg_lines = '\\n'.join([\n                f'    {key}: {env_val}'\n                for key, env_val in mapped_args.items()\n            ])\n            env = f'\\n  with:\\n{arg_lines}'\n        return dedent(template).format(\n            id=self.id,\n            run_if=run_if,\n            uses=self.uses,\n            env=env,\n        ).rstrip()\n</code></pre>"},{"location":"api/m/github/actions/actions/#m.github.actions.actions.UsesStep.get_inputs_outputs","title":"<code>get_inputs_outputs()</code>","text":"<p>Get the inputs and outputs for the step.</p> <p>Returns:</p> Type Description <code>InputOutputs</code> <p>A tuple of the inputs and outputs.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def get_inputs_outputs(self: 'UsesStep') -&gt; InputOutputs:\n    \"\"\"Get the inputs and outputs for the step.\n\n    Returns:\n        A tuple of the inputs and outputs.\n    \"\"\"\n    return self.inputs, self.outputs\n</code></pre>"},{"location":"api/m/github/actions/actions/#m.github.actions.actions.UsesStep.to_str","title":"<code>to_str(_python_path, available_values)</code>","text":"<p>Generate a string to use in the Github Action.</p> <p>Parameters:</p> Name Type Description Default <code>_python_path</code> <code>str</code> <p>The path to the python module.</p> required <code>available_values</code> <code>dict[str, str]</code> <p>The values that are available to the step.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github action.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def to_str(\n    self: 'UsesStep',\n    _python_path: str,\n    available_values: dict[str, str],\n) -&gt; str:\n    \"\"\"Generate a string to use in the Github Action.\n\n    Args:\n        _python_path: The path to the python module.\n        available_values: The values that are available to the step.\n\n    Returns:\n        A string to add to the Github action.\n    \"\"\"\n    template = \"\"\"\\\n        - id: {id}{run_if}\n          uses: {uses}{env}\n    \"\"\"\n    run_if = _run_if(self.run_if, available_values)\n    # mypy has trouble seeing that its bound to KebabModel\n    self_args = cast(KebabModel, self.args)\n    all_args = self_args.model_dump() if self_args else {}\n    mapped_args = map_args(\n        all_args,\n        available_values,\n        lambda x: x.replace('_', '-', -1),\n    )\n    env = ''\n    if mapped_args:\n        arg_lines = '\\n'.join([\n            f'    {key}: {env_val}'\n            for key, env_val in mapped_args.items()\n        ])\n        env = f'\\n  with:\\n{arg_lines}'\n    return dedent(template).format(\n        id=self.id,\n        run_if=run_if,\n        uses=self.uses,\n        env=env,\n    ).rstrip()\n</code></pre>"},{"location":"api/m/github/actions/api/","title":"api","text":""},{"location":"api/m/github/actions/api/#m.github.actions.api.InArg","title":"<code>InArg(*, help, default=None)</code>","text":"<p>Force proper annotation of the input of a GitHub Action.</p> <p>Should be used to declare the input arguments of an action. It returns <code>Any</code> to bypass <code>mypy</code>'s type checking. Similar to pydantic.fields.Field but it is tailored to help us write the inputs for an action and its steps.</p> <p>Note</p> <p>By default all input arguments are required. If you want to make an input not required then provide a default value.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>Human-readable description.</p> required <code>default</code> <code>str | None</code> <p>The default value for the argument.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>, the return annotation is <code>Any</code> so <code>InArg</code> can be used on type annotated fields without causing typing errors.</p> Source code in <code>m/github/actions/api.py</code> <pre><code>def InArg(  # noqa: N802\n    *,\n    help: str,  # noqa: WPS125\n    default: str | None = None,\n) -&gt; Any:\n    \"\"\"Force proper annotation of the input of a GitHub Action.\n\n    Should be used to declare the input arguments of an action. It returns\n    [`Any`][typing.Any] to bypass `mypy`'s type checking. Similar to\n    [pydantic.fields.Field][] but it is tailored to help us write the inputs for\n    an action and its steps.\n\n    !!! note\n\n        By default all input arguments are required. If you want to make an\n        input not required then provide a default value.\n\n    Args:\n        help: Human-readable description.\n        default: The default value for the argument.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo], the return annotation is\n            `Any` so `InArg` can be used on type annotated fields without\n            causing typing errors.\n    \"\"\"\n    args = {\n        'description': help,\n    }\n    if default is not None:\n        args['default'] = default\n    return FieldInfo.from_field(**args)\n</code></pre>"},{"location":"api/m/github/actions/api/#m.github.actions.api.OutArg","title":"<code>OutArg(*, help, export=False)</code>","text":"<p>Force proper annotation of the output of a GitHub Action.</p> <p>Note</p> <p>All steps have access to the steps output, if we want to make the output available to the action we need to <code>export</code> it.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>Human-readable description.</p> required <code>export</code> <code>bool</code> <p>Whether the argument is to be exported to the action.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>, the return annotation is <code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/github/actions/api.py</code> <pre><code>def OutArg(  # noqa: N802\n    *,\n    help: str,  # noqa: WPS125\n    export: bool = False,\n) -&gt; Any:\n    \"\"\"Force proper annotation of the output of a GitHub Action.\n\n    !!! note\n        All steps have access to the steps output, if we want to make the output\n        available to the action we need to `export` it.\n\n    Args:\n        help: Human-readable description.\n        export: Whether the argument is to be exported to the action.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo], the return annotation is\n            `Any` so `Arg` can be used on type annotated fields without causing\n            a typing error.\n    \"\"\"\n    return FieldInfo.from_field(\n        description=help,\n        json_schema_extra={'export': export},\n    )\n</code></pre>"},{"location":"api/m/github/actions/api/#m.github.actions.api.dump_step_outputs","title":"<code>dump_step_outputs(outputs)</code>","text":"<p>Dump the outputs for a GitHub Action step.</p> <p>Github does this if we write to the file where $GITHUB_OUTPUT is pointing.</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>OutputModel</code> <p>The outputs to dump.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>A <code>OneOf</code> with 0 or an issue.</p> Source code in <code>m/github/actions/api.py</code> <pre><code>def dump_step_outputs(outputs: OutputModel) -&gt; Res[int]:\n    \"\"\"Dump the outputs for a GitHub Action step.\n\n    Github does this if we write to the file where $GITHUB_OUTPUT is pointing.\n\n    Args:\n        outputs: The outputs to dump.\n\n    Returns:\n        A `OneOf` with 0 or an issue.\n    \"\"\"\n    output_data = '\\n'.join([\n        f'{key}={output_val}'\n        for key, output_val in outputs.model_dump(by_alias=True).items()\n    ])\n    output_file = os.environ.get('GITHUB_OUTPUT', 'NO_GITHUB_OUTPUT_FILE')\n    return rw.write_file(output_file, output_data, 'a')\n</code></pre>"},{"location":"api/m/github/actions/api/#m.github.actions.api.load_step_inputs","title":"<code>load_step_inputs(model)</code>","text":"<p>Load the GitHub Action inputs from the environment.</p> <p>This function can be used provided that in the GitHub Action workflow we set up:::</p> <pre><code>env:\n    INPUT_ARG_1: ${{ inputs.arg-1 }}\n</code></pre> <p>In this way the inputs will set in the environment which we can then read in our main python function.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[InputModel]</code> <p>The class to create an instance of.</p> required <p>Returns:</p> Type Description <code>Res[InputModel]</code> <p>A <code>OneOf</code> with the model or an issue.</p> Source code in <code>m/github/actions/api.py</code> <pre><code>def load_step_inputs(model: type[InputModel]) -&gt; Res[InputModel]:\n    \"\"\"Load the GitHub Action inputs from the environment.\n\n    This function can be used provided that in the GitHub Action workflow we\n    set up:::\n\n        env:\n            INPUT_ARG_1: ${{ inputs.arg-1 }}\n\n    In this way the inputs will set in the environment which we can then read\n    in our main python function.\n\n    Args:\n        model: The class to create an instance of.\n\n    Returns:\n        A `OneOf` with the model or an issue.\n    \"\"\"\n    model_data: dict[str, str] = {}\n    for key, env_val in os.environ.items():\n        if key.startswith('INPUT_'):\n            _, input_name = key.split('INPUT_')\n            model_data[input_name.lower()] = env_val\n    try:\n        return Good(TypeAdapter(model).validate_python(model_data))\n    except Exception as ex:\n        return issue('load_step_inputs_failure', cause=ex)\n</code></pre>"},{"location":"api/m/github/actions/api/#m.github.actions.api.run_action","title":"<code>run_action(main)</code>","text":"<p>Entry point for a GitHub Action.</p> <p>This is the main function that should be used to run an action. It takes in a function that takes in a m.pydantic.KebabModel and returns a <code>Res[KebabModel]</code>.</p> <p>The only place where this function is needed is in the the if block</p> <pre><code>if __name__ == '__main__':\n    run_action(my_action)\n</code></pre> <p><code>mypy</code> will make sure that the you are providing the correct type of function to <code>run_action</code>. Keep in mind, the function is generic and we should be writing models for the inputs and outputs for all of our functions.</p> <p>Parameters:</p> Name Type Description Default <code>main</code> <code>Callable[[InputModel], Res[OutputModel]]</code> <p>The main function of the GitHub Action.</p> required Source code in <code>m/github/actions/api.py</code> <pre><code>def run_action(main: Callable[[InputModel], Res[OutputModel]]) -&gt; None:\n    \"\"\"Entry point for a GitHub Action.\n\n    This is the main function that should be used to run an action. It takes in\n    a function that takes in a [m.pydantic.KebabModel][] and returns a\n    `Res[KebabModel]`.\n\n    The only place where this function is needed is in the the if block\n\n    ```python\n    if __name__ == '__main__':\n        run_action(my_action)\n    ```\n\n    `mypy` will make sure that the you are providing the correct type of function\n    to `run_action`. Keep in mind, the function is generic and we should be writing\n    models for the inputs and outputs for all of our functions.\n\n    Args:\n        main: The main function of the GitHub Action.\n    \"\"\"\n    logging_config()\n    main_params = signature(main).parameters\n    arg_name = next(iter(main_params))\n    input_model = main_params[arg_name].annotation\n    args = load_step_inputs(input_model)\n    if isinstance(args, Bad):\n        default_issue_handler(args.value)\n        sys.exit(4)\n    inputs = args.value\n    exit_code = run_main(lambda: main(inputs), result_handler=_result_handler)\n    sys.exit(exit_code)\n</code></pre>"},{"location":"api/m/github/actions/builder/","title":"builder","text":""},{"location":"api/m/github/actions/builder/#m.github.actions.builder.assert_actions","title":"<code>assert_actions(actions)</code>","text":"<p>Assert that the actions instance is of type <code>Action</code> or <code>list[Action]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>Any</code> <p>The actions instance to assert.</p> required <p>Returns:</p> Type Description <code>Res[list[Action]]</code> <p>A <code>Good</code> containing a list of <code>Action</code>.</p> Source code in <code>m/github/actions/builder.py</code> <pre><code>def assert_actions(actions: Any) -&gt; Res[list[Action]]:\n    \"\"\"Assert that the actions instance is of type `Action` or `list[Action]`.\n\n    Args:\n        actions: The actions instance to assert.\n\n    Returns:\n        A `Good` containing a list of `Action`.\n    \"\"\"\n    if isinstance(actions, Action):\n        return Good([actions])\n    if isinstance(actions, list) and all(isinstance(a, Action) for a in actions):\n        return Good(actions)\n    suggestion = 'ensure all actions are of type \"m.github.actions.Action\"'\n    return issue('invalid_actions', context={'suggestion': suggestion})\n</code></pre>"},{"location":"api/m/github/actions/builder/#m.github.actions.builder.build_actions","title":"<code>build_actions(actions_py_file, *, check, show_traceback)</code>","text":"<p>Create the actions metadata files as described by the actions file.</p> <p>Parameters:</p> Name Type Description Default <code>actions_py_file</code> <code>str</code> <p>The path to a python script containing the actions.</p> required <code>check</code> <code>bool</code> <p>Check if generated files are up to date and skip writing them.</p> required <code>show_traceback</code> <code>bool</code> <p>Display traceback in case of an issue.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>A <code>Good</code> containing <code>None</code> if the files were written.</p> Source code in <code>m/github/actions/builder.py</code> <pre><code>def build_actions(\n    actions_py_file: str,\n    *,\n    check: bool,\n    show_traceback: bool,\n) -&gt; Res[None]:\n    \"\"\"Create the actions metadata files as described by the actions file.\n\n    Args:\n        actions_py_file: The path to a python script containing the actions.\n        check: Check if generated files are up to date and skip writing them.\n        show_traceback: Display traceback in case of an issue.\n\n    Returns:\n        A `Good` containing `None` if the files were written.\n    \"\"\"\n    return one_of(lambda: [\n        None\n        for _ in rw.assert_file_exists(actions_py_file)\n        for py_path, actions_module in update_py_path(actions_py_file)\n        for possible_actions in import_attr(f'{actions_module}.actions')\n        for actions in assert_actions(possible_actions)\n        for _ in process_actions(\n            py_path,\n            actions_module,\n            actions,\n            check=check,\n            show_traceback=show_traceback,\n        )\n    ])\n</code></pre>"},{"location":"api/m/github/actions/builder/#m.github.actions.builder.process_action","title":"<code>process_action(py_path, actions_module, action, *, check)</code>","text":"<p>Process an action to either write or check the action file.</p> <p>Parameters:</p> Name Type Description Default <code>py_path</code> <code>str</code> <p>The root directory of the actions.</p> required <code>actions_module</code> <code>str</code> <p>The name of the module containing the actions.</p> required <code>action</code> <code>Action</code> <p>The action to process.</p> required <code>check</code> <code>bool</code> <p>If True, it verifies the action file is up to date.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>An <code>Good</code> containing None or an issue.</p> Source code in <code>m/github/actions/builder.py</code> <pre><code>def process_action(\n    py_path: str,\n    actions_module: str,\n    action: Action,\n    *,\n    check: bool,\n) -&gt; Res[int]:\n    \"\"\"Process an action to either write or check the action file.\n\n    Args:\n        py_path: The root directory of the actions.\n        actions_module: The name of the module containing the actions.\n        action: The action to process.\n        check: If True, it verifies the action file is up to date.\n\n    Returns:\n        An `Good` containing None or an issue.\n    \"\"\"\n    outputs_res = action.gather_outputs()\n    if isinstance(outputs_res, Bad):\n        return Bad(outputs_res.value)\n\n    outputs, available_outputs = outputs_res.value\n    action_file = ActionFile(\n        py_path=py_path,\n        module_name=actions_module,\n        name=action.name,\n        description=action.description,\n        inputs=action.inputs or KebabModel,\n        action=action,\n        outputs=outputs,\n        python_path=py_path,\n        available_outputs=available_outputs,\n    )\n    yaml_contents = str(action_file)\n    if check:\n        current_contents_res = rw.read_file(action.file_path)\n        if isinstance(current_contents_res, Bad):\n            return Bad(current_contents_res.value)\n        current_contents = current_contents_res.value\n        if current_contents != yaml_contents:\n            return issue(\n                'action_file_out_of_date',\n                context={\n                    'action_name': action.name,\n                    'file_path': action.file_path,\n                },\n            )\n        return Good(0)\n    return rw.write_file(action.file_path, yaml_contents)\n</code></pre>"},{"location":"api/m/github/actions/builder/#m.github.actions.builder.process_actions","title":"<code>process_actions(py_path, mod_name, actions, *, check, show_traceback)</code>","text":"<p>Iterate over each action to either write or check the action file.</p> <p>Parameters:</p> Name Type Description Default <code>py_path</code> <code>str</code> <p>The root directory of the actions.</p> required <code>mod_name</code> <code>str</code> <p>The name of the module containing the actions.</p> required <code>actions</code> <code>list[Action]</code> <p>The list of actions to process.</p> required <code>check</code> <code>bool</code> <p>If True, it verifies the action file is up to date.</p> required <code>show_traceback</code> <code>bool</code> <p>Display traceback in case of an issue.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An <code>Good</code> containing None or an issue.</p> Source code in <code>m/github/actions/builder.py</code> <pre><code>def process_actions(\n    py_path: str,\n    mod_name: str,\n    actions: list[Action],\n    *,\n    check: bool,\n    show_traceback: bool,\n) -&gt; Res[None]:\n    \"\"\"Iterate over each action to either write or check the action file.\n\n    Args:\n        py_path: The root directory of the actions.\n        mod_name: The name of the module containing the actions.\n        actions: The list of actions to process.\n        check: If True, it verifies the action file is up to date.\n        show_traceback: Display traceback in case of an issue.\n\n    Returns:\n        An `Good` containing None or an issue.\n    \"\"\"\n    process_result = [\n        process_action(py_path, mod_name, action, check=check)\n        for action in actions\n    ]\n    issues = {\n        action.name: action_res.value\n        for action_res, action in zip(process_result, actions)\n        if isinstance(action_res, Bad)\n    }\n    if issues:\n        return issue(\n            'process_actions_failure',\n            context={\n                'issues': {\n                    action_name: iss.to_dict(show_traceback=show_traceback)\n                    for action_name, iss in issues.items()\n                },\n            },\n        )\n    return Good(None)\n</code></pre>"},{"location":"api/m/github/actions/builder/#m.github.actions.builder.update_py_path","title":"<code>update_py_path(actions_py_file)</code>","text":"<p>Obtain the python path and module name from the actions file.</p> <p>It also modifies the PYTHONPATH so that other files may be imported from the same directory.</p> <p>Parameters:</p> Name Type Description Default <code>actions_py_file</code> <code>str</code> <p>The path to a python script containing the actions.</p> required <p>Returns:</p> Type Description <code>Res[tuple[str, str]]</code> <p>A <code>Good</code> containing a tuple of the python path and module name.</p> Source code in <code>m/github/actions/builder.py</code> <pre><code>def update_py_path(actions_py_file: str) -&gt; Res[tuple[str, str]]:\n    \"\"\"Obtain the python path and module name from the actions file.\n\n    It also modifies the PYTHONPATH so that other files may be imported from\n    the same directory.\n\n    Args:\n        actions_py_file: The path to a python script containing the actions.\n\n    Returns:\n        A `Good` containing a tuple of the python path and module name.\n    \"\"\"\n    is_file = actions_py_file.endswith('.py')\n    parts = actions_py_file.split('/')\n    # Need to add the parent directory to the path so that we can do relative\n    # imports from the actions file.\n    py_path = (\n        '/'.join(parts[:-2])\n        if is_file\n        else '/'.join(parts[:-1])\n    )\n    sys.path.insert(0, py_path)\n    module_name = parts[-1].split('.')[0]\n    dir_name = parts[-2] if is_file else ''\n    module = f'{dir_name}.{module_name}' if is_file else module_name\n    return Good((py_path, module))\n</code></pre>"},{"location":"api/m/github/actions/misc/","title":"misc","text":""},{"location":"api/m/github/actions/misc/#m.github.actions.misc.InputIssue","title":"<code>InputIssue</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An issue with an input.</p> <p>Attributes:</p> Name Type Description <code>invalid_input_value</code> <code>str</code> <p>...</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>class InputIssue(BaseModel):\n    \"\"\"An issue with an input.\"\"\"\n\n    # Set if the value is invalid, may be set of the form \"input_name: value\"\n    invalid_input_value: str\n</code></pre>"},{"location":"api/m/github/actions/misc/#m.github.actions.misc.MetadataOutput","title":"<code>MetadataOutput</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An action metadata file output.</p> <p>Attributes:</p> Name Type Description <code>description</code> <code>str</code> <p>...</p> <code>value</code> <code>str</code> <p>...</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>class MetadataOutput(BaseModel):\n    \"\"\"An action metadata file output.\"\"\"\n\n    description: str\n    value: str  # noqa: WPS110 - Actual name of property, cannot change.\n</code></pre>"},{"location":"api/m/github/actions/misc/#m.github.actions.misc.OutputField","title":"<code>OutputField</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Digestible information about an output.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>...</p> <code>description</code> <code>str</code> <p>...</p> <code>full_ref_name</code> <code>str</code> <p>...</p> <code>short_ref_name</code> <code>str</code> <p>...</p> <code>is_export</code> <code>bool</code> <p>...</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>class OutputField(BaseModel):\n    \"\"\"Digestible information about an output.\"\"\"\n\n    # name of the output\n    name: str\n\n    # description of the output\n    description: str\n\n    # steps.{step_id}.outputs.{output_name}\n    full_ref_name: str\n\n    # {step_id}.{output_name}\n    short_ref_name: str\n\n    # flag to indicate if this output should be exported\n    is_export: bool\n\n    def get_metadata_output(self: 'OutputField') -&gt; MetadataOutput:\n        \"\"\"Get the metadata output.\n\n        Returns:\n            An instance of the metadata output.\n        \"\"\"\n        return MetadataOutput(\n            description=self.description,\n            value=expression_eval(self.full_ref_name),\n        )\n\n    @classmethod\n    def create(\n        cls: type['OutputField'],\n        step_id: str,\n        output_model: type[KebabModel],\n    ) -&gt; dict[str, 'OutputField']:\n        \"\"\"Create an instance of an output field.\n\n        Args:\n            step_id: The id of the step.\n            output_model: The model to create it from.\n\n        Returns:\n            An instance of the output field.\n        \"\"\"\n        outputs: dict[str, OutputField] = {}\n        for name, prop_info in output_model.model_fields.items():\n            kebab_name = prop_info.alias or name\n            outputs[name] = OutputField(\n                name=name,\n                description=prop_info.description or '',\n                full_ref_name=f'steps.{step_id}.outputs.{kebab_name}',\n                short_ref_name=f'{step_id}.{name}',\n                is_export=is_export(prop_info),\n            )\n        return outputs\n</code></pre>"},{"location":"api/m/github/actions/misc/#m.github.actions.misc.OutputField.create","title":"<code>create(step_id, output_model)</code>  <code>classmethod</code>","text":"<p>Create an instance of an output field.</p> <p>Parameters:</p> Name Type Description Default <code>step_id</code> <code>str</code> <p>The id of the step.</p> required <code>output_model</code> <code>type[KebabModel]</code> <p>The model to create it from.</p> required <p>Returns:</p> Type Description <code>dict[str, OutputField]</code> <p>An instance of the output field.</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>@classmethod\ndef create(\n    cls: type['OutputField'],\n    step_id: str,\n    output_model: type[KebabModel],\n) -&gt; dict[str, 'OutputField']:\n    \"\"\"Create an instance of an output field.\n\n    Args:\n        step_id: The id of the step.\n        output_model: The model to create it from.\n\n    Returns:\n        An instance of the output field.\n    \"\"\"\n    outputs: dict[str, OutputField] = {}\n    for name, prop_info in output_model.model_fields.items():\n        kebab_name = prop_info.alias or name\n        outputs[name] = OutputField(\n            name=name,\n            description=prop_info.description or '',\n            full_ref_name=f'steps.{step_id}.outputs.{kebab_name}',\n            short_ref_name=f'{step_id}.{name}',\n            is_export=is_export(prop_info),\n        )\n    return outputs\n</code></pre>"},{"location":"api/m/github/actions/misc/#m.github.actions.misc.OutputField.get_metadata_output","title":"<code>get_metadata_output()</code>","text":"<p>Get the metadata output.</p> <p>Returns:</p> Type Description <code>MetadataOutput</code> <p>An instance of the metadata output.</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>def get_metadata_output(self: 'OutputField') -&gt; MetadataOutput:\n    \"\"\"Get the metadata output.\n\n    Returns:\n        An instance of the metadata output.\n    \"\"\"\n    return MetadataOutput(\n        description=self.description,\n        value=expression_eval(self.full_ref_name),\n    )\n</code></pre>"},{"location":"api/m/github/actions/misc/#m.github.actions.misc.expression_eval","title":"<code>expression_eval(gh_expression)</code>","text":"<p>Create a string to evaluate a Github expression.</p> <p>Parameters:</p> Name Type Description Default <code>gh_expression</code> <code>str</code> <p>The Github expression to evaluate.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string to evaluate the Github expression.</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>def expression_eval(gh_expression: str) -&gt; str:\n    \"\"\"Create a string to evaluate a Github expression.\n\n    Args:\n        gh_expression: The Github expression to evaluate.\n\n    Returns:\n        A string to evaluate the Github expression.\n    \"\"\"\n    left = '{{'\n    right = '}}'\n    return f'${left} {gh_expression} {right}'\n</code></pre>"},{"location":"api/m/github/actions/misc/#m.github.actions.misc.get_inputs_outputs","title":"<code>get_inputs_outputs(run_function)</code>","text":"<p>Get the inputs and outputs of a <code>run_function</code>.</p> <p>Parameters:</p> Name Type Description Default <code>run_function</code> <code>Callable[[KebabModel], Res[KebabModel]]</code> <p>The function to obtain the inputs and outputs from.</p> required <p>Returns:</p> Type Description <code>InputOutputs</code> <p>A tuple of the inputs and outputs.</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>def get_inputs_outputs(\n    run_function: Callable[[KebabModel], Res[KebabModel]],\n) -&gt; InputOutputs:\n    \"\"\"Get the inputs and outputs of a `run_function`.\n\n    Args:\n        run_function: The function to obtain the inputs and outputs from.\n\n    Returns:\n        A tuple of the inputs and outputs.\n    \"\"\"\n    func_sig = signature(run_function)\n    in_params = func_sig.parameters\n    arg_name = next(iter(in_params))\n    input_model = in_params[arg_name].annotation\n    out_sig = func_sig.return_annotation\n    # expecting out_sig to be of type Res[Model] which is OneOf\n    output_model: type[KebabModel] = out_sig.__args__[0].__args__[1]\n    return input_model, output_model\n</code></pre>"},{"location":"api/m/github/actions/misc/#m.github.actions.misc.input_env","title":"<code>input_env(name)</code>","text":"<p>Get the name of the env variable for an input.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the input.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the env variable.</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>def input_env(name: str) -&gt; str:\n    \"\"\"Get the name of the env variable for an input.\n\n    Args:\n        name: The name of the input.\n\n    Returns:\n        The name of the env variable.\n    \"\"\"\n    upper_name = name.replace('-', '_').upper()\n    return f'INPUT_{upper_name}'\n</code></pre>"},{"location":"api/m/github/actions/misc/#m.github.actions.misc.is_export","title":"<code>is_export(field)</code>","text":"<p>Determine if a field is exported.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>FieldInfo</code> <p>The field to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the field is exported.</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>def is_export(field: FieldInfo) -&gt; bool:\n    \"\"\"Determine if a field is exported.\n\n    Args:\n        field: The field to check.\n\n    Returns:\n        Whether the field is exported.\n    \"\"\"\n    if isinstance(field.json_schema_extra, dict):\n        return bool(field.json_schema_extra.get('export', False))\n    # internally we do not set json_schema_extra to something other than dict\n    # If we are reaching the next step it is because of a custom field.\n    return False  # pragma: no cover\n</code></pre>"},{"location":"api/m/github/actions/misc/#m.github.actions.misc.is_input_key","title":"<code>is_input_key(key)</code>","text":"<p>Determine if a key is of the form <code>(step_id).(arg_name)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the key is an input key.</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>def is_input_key(key: str) -&gt; bool:\n    \"\"\"Determine if a key is of the form `(step_id).(arg_name)`.\n\n    Args:\n        key: The key to check.\n\n    Returns:\n        True if the key is an input key.\n    \"\"\"\n    pattern = r'^[\\w-]+\\.[\\w-]+$'\n    return bool(re.match(pattern, key))\n</code></pre>"},{"location":"api/m/github/actions/misc/#m.github.actions.misc.map_args","title":"<code>map_args(all_args, available_values, dict_key)</code>","text":"<p>Map the arguments to a new value using the available values.</p> <p>Parameters:</p> Name Type Description Default <code>all_args</code> <code>dict[str, str]</code> <p>A dictionary with mappable values.</p> required <code>available_values</code> <code>dict[str, str]</code> <p>A dictionary with available values.</p> required <code>dict_key</code> <code>Callable[[str], str]</code> <p>A transform function for the new key in the map.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A mapped dictionary.</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>def map_args(\n    all_args: dict[str, str],\n    available_values: dict[str, str],\n    dict_key: Callable[[str], str],\n) -&gt; dict[str, str]:\n    \"\"\"Map the arguments to a new value using the available values.\n\n    Args:\n        all_args: A dictionary with mappable values.\n        available_values: A dictionary with available values.\n        dict_key: A transform function for the new key in the map.\n\n    Returns:\n        A mapped dictionary.\n    \"\"\"\n    return {\n        dict_key(key): (\n            expression_eval(available_values[arg_val])\n            if arg_val in available_values\n            else arg_val\n        )\n        for key, arg_val in all_args.items()\n    }\n</code></pre>"},{"location":"api/m/github/actions/misc/#m.github.actions.misc.verify_inputs","title":"<code>verify_inputs(input_model, args, available_outputs)</code>","text":"<p>Verify the inputs.</p> <p>This is used to make sure we declare valid arguments in each step along with valid accessible values from the global inputs or previous steps.</p> <p>Parameters:</p> Name Type Description Default <code>input_model</code> <code>type[KebabModel]</code> <p>The model to use to verify the inputs.</p> required <code>args</code> <code>dict[str, str]</code> <p>The arguments to verify.</p> required <code>available_outputs</code> <code>dict[str, str]</code> <p>A dict of available outputs to use as inputs.</p> required <p>Returns:</p> Type Description <code>list[InputIssue]</code> <p>A list of issues.</p> Source code in <code>m/github/actions/misc.py</code> <pre><code>def verify_inputs(\n    input_model: type[KebabModel],\n    args: dict[str, str],\n    available_outputs: dict[str, str],\n) -&gt; list[InputIssue]:\n    \"\"\"Verify the inputs.\n\n    This is used to make sure we declare valid arguments in each step\n    along with valid accessible values from the global inputs or previous\n    steps.\n\n    Args:\n        input_model: The model to use to verify the inputs.\n        args: The arguments to verify.\n        available_outputs: A dict of available outputs to use as inputs.\n\n    Returns:\n        A list of issues.\n    \"\"\"\n    issues: list[InputIssue] = []\n    for prop_name in input_model.model_fields:\n        input_name = prop_name\n        arg_value = args.get(input_name)\n        not_available = arg_value not in available_outputs\n        if arg_value and not_available and is_input_key(arg_value):\n            issues.append(\n                InputIssue(\n                    invalid_input_value=f'{input_name}={arg_value}',\n                ),\n            )\n    return issues\n</code></pre>"},{"location":"api/m/github/actions/system/","title":"system","text":""},{"location":"api/m/github/actions/system/#m.github.actions.system.import_attr","title":"<code>import_attr(attr_path)</code>","text":"<p>Get an attribute from a module.</p> <p>The <code>attr_path</code> should be a fully qualified path to the attribute. For example <code>import_attr('m.core.one_of')</code> will attempt to retrieve a handle on <code>one_of</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attr_path</code> <code>str</code> <p>The path to the attribute.</p> required <p>Returns:</p> Type Description <code>Res[Any]</code> <p>A <code>Good</code> containing the attribute or an issue.</p> Source code in <code>m/github/actions/system.py</code> <pre><code>def import_attr(attr_path: str) -&gt; Res[Any]:\n    \"\"\"Get an attribute from a module.\n\n    The `attr_path` should be a fully qualified path to the attribute. For\n    example `import_attr('m.core.one_of')` will attempt to retrieve a handle\n    on `one_of`.\n\n    Args:\n        attr_path: The path to the attribute.\n\n    Returns:\n        A `Good` containing the attribute or an issue.\n    \"\"\"\n    module_parts = attr_path.split('.')\n    module_name = '.'.join(module_parts[:-1])\n    item_name = module_parts[-1]\n    try:\n        module = import_module(module_name)\n    except Exception as ex:\n        return issue(\n            'import_module_failure',\n            cause=ex,\n            context={'attr_path': attr_path, 'module_name': module_name},\n        )\n    module_dict = module.__dict__\n    if item_name not in module_dict:\n        return issue(\n            'missing_attribute',\n            context={'module': str(module), 'missing_attribute': item_name},\n        )\n    return Good(module_dict[item_name])\n</code></pre>"},{"location":"api/m/github/graphql/","title":"graphql","text":""},{"location":"api/m/github/graphql/api/","title":"api","text":""},{"location":"api/m/github/graphql/api/#m.github.graphql.api.graphql","title":"<code>graphql(token, query, variables)</code>","text":"<p>Make a request to Github's graphql API.</p> <p>https://docs.github.com/en/graphql/guides/forming-calls-with-graphql</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github PAT.</p> required <code>query</code> <code>str</code> <p>A graphql query.</p> required <code>variables</code> <code>Mapping[str, Any]</code> <p>The variables to use in the query.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>The Github response.</p> Source code in <code>m/github/graphql/api.py</code> <pre><code>def graphql(\n    token: str,\n    query: str,\n    variables: Mapping[str, Any],\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Make a request to Github's graphql API.\n\n    https://docs.github.com/en/graphql/guides/forming-calls-with-graphql\n\n    Args:\n        token: A github PAT.\n        query: A graphql query.\n        variables: The variables to use in the query.\n\n    Returns:\n        The Github response.\n    \"\"\"\n    payload = {'query': query, 'variables': variables or {}}\n    return one_of(\n        lambda: [\n            payload\n            for res in request(token, '/graphql', HttpMethod.post, payload)\n            for payload in _filter_data(res)\n        ],\n    )\n</code></pre>"},{"location":"api/m/github/graphql/enums/","title":"enums","text":""},{"location":"api/m/github/graphql/enums/#m.github.graphql.enums.MergeableState","title":"<code>MergeableState</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Whether or not a PullRequest can be merged.</p> Source code in <code>m/github/graphql/enums.py</code> <pre><code>class MergeableState(str, Enum):  # noqa: WPS600\n    \"\"\"Whether or not a PullRequest can be merged.\"\"\"\n\n    # The pull request cannot be merged due to merge conflicts.\n    conflicting = 'CONFLICTING'\n\n    # The pull request can be merged.\n    mergeable = 'MERGEABLE'\n\n    # The mergeability of the pull request is still being calculated.\n    unknown = 'UNKNOWN'\n</code></pre>"},{"location":"api/m/github/graphql/enums/#m.github.graphql.enums.PullRequestReviewState","title":"<code>PullRequestReviewState</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Possible choices for a pull request review state.</p> Source code in <code>m/github/graphql/enums.py</code> <pre><code>class PullRequestReviewState(str, Enum):  # noqa: WPS600\n    \"\"\"Possible choices for a pull request review state.\"\"\"\n\n    # A review allowing the pull request to merge.\n    approved = 'APPROVED'\n\n    # A review blocking the pull request from merging.\n    changes_requested = 'CHANGES_REQUESTED'\n\n    # An informational review.\n    commented = 'COMMENTED'\n\n    # A review that has been dismissed.\n    dismissed = 'DISMISSED'\n\n    # A review that has not yet been submitted.\n    pending = 'PENDING'\n</code></pre>"},{"location":"api/m/github/graphql/generics/","title":"generics","text":""},{"location":"api/m/github/graphql/generics/#m.github.graphql.generics.WithNodes","title":"<code>WithNodes</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[G_Item]</code></p> <p>An object that may contain nodes.</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>list[G_Item]</code> <p>...</p> Source code in <code>m/github/graphql/generics.py</code> <pre><code>class WithNodes(BaseModel, Generic[G_Item]):\n    \"\"\"An object that may contain nodes.\"\"\"\n\n    nodes: list[G_Item]\n</code></pre>"},{"location":"api/m/github/graphql/generics/#m.github.graphql.generics.identity","title":"<code>identity(x)</code>","text":"<p>Identity function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>G_Item</code> <p>The input</p> required <p>Returns:</p> Type Description <code>G_Item</code> <p>The input value.</p> Source code in <code>m/github/graphql/generics.py</code> <pre><code>def identity(x: G_Item) -&gt; G_Item:\n    \"\"\"Identity function.\n\n    Args:\n        x: The input\n\n    Returns:\n        The input value.\n    \"\"\"\n    return x\n</code></pre>"},{"location":"api/m/github/graphql/queries/","title":"queries","text":""},{"location":"api/m/github/graphql/queries/branch_prs/","title":"branch_prs","text":""},{"location":"api/m/github/graphql/queries/branch_prs/#m.github.graphql.queries.branch_prs.Actor","title":"<code>Actor</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object representing a committer.</p> <p>Attributes:</p> Name Type Description <code>login</code> <code>str</code> <p>...</p> Source code in <code>m/github/graphql/queries/branch_prs.py</code> <pre><code>class Actor(BaseModel):\n    \"\"\"An object representing a committer.\"\"\"\n\n    login: str\n</code></pre>"},{"location":"api/m/github/graphql/queries/branch_prs/#m.github.graphql.queries.branch_prs.PullRequest","title":"<code>PullRequest</code>","text":"<p>             Bases: <code>CamelModel</code></p> <p>A repository pull request.</p> <p>Attributes:</p> Name Type Description <code>closed</code> <code>bool</code> <p>...</p> <code>title</code> <code>str</code> <p>...</p> <code>number</code> <code>int</code> <p>...</p> <code>base_ref_name</code> <code>str</code> <p>...</p> <code>mergeable</code> <code>MergeableState</code> <p>...</p> <code>merged</code> <code>bool</code> <p>...</p> <code>author</code> <code>Actor</code> <p>...</p> <code>latest_reviews</code> <code>WithNodes[PullRequestReview]</code> <p>...</p> <code>url</code> <code>str</code> <p>...</p> Source code in <code>m/github/graphql/queries/branch_prs.py</code> <pre><code>class PullRequest(CamelModel):\n    \"\"\"A repository pull request.\"\"\"\n\n    closed: bool\n    title: str\n    number: int\n    base_ref_name: str\n    mergeable: MergeableState\n    merged: bool\n    author: Actor\n    latest_reviews: WithNodes[PullRequestReview]\n    url: str\n</code></pre>"},{"location":"api/m/github/graphql/queries/branch_prs/#m.github.graphql.queries.branch_prs.PullRequestReview","title":"<code>PullRequestReview</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A review object for a given pull request.</p> <p>Attributes:</p> Name Type Description <code>author</code> <code>Actor</code> <p>...</p> <code>body</code> <code>str</code> <p>...</p> <code>state</code> <code>PullRequestReviewState</code> <p>...</p> Source code in <code>m/github/graphql/queries/branch_prs.py</code> <pre><code>class PullRequestReview(BaseModel):\n    \"\"\"A review object for a given pull request.\"\"\"\n\n    author: Actor\n    body: str\n    state: PullRequestReviewState\n</code></pre>"},{"location":"api/m/github/graphql/queries/branch_prs/#m.github.graphql.queries.branch_prs.fetch","title":"<code>fetch(token, owner, repo, branch)</code>","text":"<p>Retrieve the pr information for the specified branch.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>branch</code> <code>str</code> <p>Name of the branch.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, list[PullRequest]]</code> <p>A list of pull requests connected to the branch or an issue.</p> Source code in <code>m/github/graphql/queries/branch_prs.py</code> <pre><code>def fetch(\n    token: str,\n    owner: str,\n    repo: str,\n    branch: str,\n) -&gt; OneOf[Issue, list[PullRequest]]:\n    \"\"\"Retrieve the pr information for the specified branch.\n\n    Args:\n        token: A Github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        branch: Name of the branch.\n\n    Returns:\n        A list of pull requests connected to the branch or an issue.\n    \"\"\"\n    return _fetch(\n        lambda raw: TypeAdapter(list[PullRequest]).validate_python(raw),\n        token,\n        owner,\n        repo,\n        branch,\n    )\n</code></pre>"},{"location":"api/m/log/","title":"log","text":""},{"location":"api/m/log/#m.log.EnvVars","title":"<code>EnvVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class to store the values of the environment variables.</p> <p>Attributes:</p> Name Type Description <code>ci_env</code> <code>bool</code> <p>...</p> <code>github_token</code> <code>str</code> <p>...</p> <code>server_url</code> <code>str</code> <p>...</p> <code>run_id</code> <code>str</code> <p>...</p> <code>run_number</code> <code>str</code> <p>...</p> <code>run_url</code> <code>str</code> <p>...</p> <code>git_branch</code> <code>str</code> <p>...</p> <code>git_sha</code> <code>str</code> <p>...</p> <code>triggered_by</code> <code>str</code> <p>...</p> <code>triggered_by_email</code> <code>str</code> <p>...</p> <code>triggered_by_user</code> <code>str</code> <p>...</p> Source code in <code>m/log/ci_tools/types.py</code> <pre><code>class EnvVars(BaseModel):\n    \"\"\"Class to store the values of the environment variables.\"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    ci_env: bool = False\n    github_token: str = ''\n    server_url: str = ''\n    run_id: str = ''\n    run_number: str = ''\n    run_url: str = ''\n    git_branch: str = ''\n    git_sha: str = ''\n    triggered_by: str = ''\n    triggered_by_email: str = ''\n    triggered_by_user: str = ''\n</code></pre>"},{"location":"api/m/log/#m.log.Logger","title":"<code>Logger</code>","text":"<p>Wrapper for python Logger to enable inserting logs in fp loops.</p> <p>This is also so that we may attach context data for a message.</p> <p>We can access the actual logger by using <code>inst</code>.</p> Source code in <code>m/log/logger.py</code> <pre><code>class Logger:  # noqa: WPS230 - loggers have many attributes\n    \"\"\"Wrapper for python Logger to enable inserting logs in fp loops.\n\n    This is also so that we may attach context data for a message.\n\n    We can access the actual logger by using `inst`.\n    \"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    def __init__(self, name: str):\n        \"\"\"Initialize the Logger.\n\n        Args:\n            name: The name of a logger.\n        \"\"\"\n        self.inst = logging.getLogger(name)\n        self.debug = partial(log_func_wrapper, self.inst.debug)\n        self.info = partial(log_func_wrapper, self.inst.info)  # noqa: WPS110\n        self.warning = partial(log_func_wrapper, self.inst.warning)\n        self.exception = partial(log_func_wrapper, self.inst.exception)\n        self.critical = partial(log_func_wrapper, self.inst.critical)\n        self.log = partial(log_func_wrapper, self.inst.log)\n        self.prompt = partial(\n            log_func_wrapper,\n            cast(PromptLogger, self.inst).prompt,\n        )\n        self.error = partial(log_func_wrapper, self.inst.error)\n\n    def open_block(\n        self,\n        name: str,\n        description: str,\n        stderr: bool = False,\n    ) -&gt; Res[int]:\n        \"\"\"Group log lines.\n\n        Signals the formatter that the next log lines should be placed in a\n        group.\n\n        Args:\n            name: The name of the block to open.\n            description: Not supported.\n            stderr: Force message to be displayed in stderr.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        func = self.inst.error if stderr else self.inst.info\n        func(\n            'OPEN_BLOCK',\n            extra={'open_block': (name, description)},\n            stacklevel=2,\n        )\n        return Good(0)\n\n    def close_block(\n        self,\n        name: str,\n        stderr: bool = False,\n    ) -&gt; Res[int]:\n        \"\"\"Close a group log lines.\n\n        Signals the formatter that the current group of lines should end.\n\n        Args:\n            name: The name of the block to close.\n            stderr: Force message to be displayed in stderr.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        func = self.inst.error if stderr else self.inst.info\n        func(\n            'CLOSE_BLOCK',\n            extra={'close_block': name},\n            stacklevel=2,\n        )\n        return Good(0)\n\n    def error_block(\n        self,\n        msg: str | Message,\n        context: dict | Issue,\n    ) -&gt; Res[int]:\n        \"\"\"Display an error block.\n\n        Args:\n            msg: The error message to display.\n            context: The dict/Issue to display in a block.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        self.error(msg)\n        self.open_block('error', '', stderr=True)\n        self.error('', context)\n        self.close_block('error', stderr=True)\n        return Good(0)\n\n    def waning_block(\n        self,\n        msg: str | Message,\n        context: dict | Issue,\n    ) -&gt; Res[int]:\n        \"\"\"Display a warning block.\n\n        Args:\n            msg: The warning message to display.\n            context: The dict/Issue to display in a block.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        self.warning(msg)\n        self.open_block('warning', '', stderr=True)\n        self.warning('', context)\n        self.close_block('warning', stderr=True)\n        return Good(0)\n</code></pre>"},{"location":"api/m/log/#m.log.Logger.__init__","title":"<code>__init__(name)</code>","text":"<p>Initialize the Logger.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of a logger.</p> required Source code in <code>m/log/logger.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initialize the Logger.\n\n    Args:\n        name: The name of a logger.\n    \"\"\"\n    self.inst = logging.getLogger(name)\n    self.debug = partial(log_func_wrapper, self.inst.debug)\n    self.info = partial(log_func_wrapper, self.inst.info)  # noqa: WPS110\n    self.warning = partial(log_func_wrapper, self.inst.warning)\n    self.exception = partial(log_func_wrapper, self.inst.exception)\n    self.critical = partial(log_func_wrapper, self.inst.critical)\n    self.log = partial(log_func_wrapper, self.inst.log)\n    self.prompt = partial(\n        log_func_wrapper,\n        cast(PromptLogger, self.inst).prompt,\n    )\n    self.error = partial(log_func_wrapper, self.inst.error)\n</code></pre>"},{"location":"api/m/log/#m.log.Logger.close_block","title":"<code>close_block(name, stderr=False)</code>","text":"<p>Close a group log lines.</p> <p>Signals the formatter that the current group of lines should end.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the block to close.</p> required <code>stderr</code> <code>bool</code> <p>Force message to be displayed in stderr.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def close_block(\n    self,\n    name: str,\n    stderr: bool = False,\n) -&gt; Res[int]:\n    \"\"\"Close a group log lines.\n\n    Signals the formatter that the current group of lines should end.\n\n    Args:\n        name: The name of the block to close.\n        stderr: Force message to be displayed in stderr.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    func = self.inst.error if stderr else self.inst.info\n    func(\n        'CLOSE_BLOCK',\n        extra={'close_block': name},\n        stacklevel=2,\n    )\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/#m.log.Logger.error_block","title":"<code>error_block(msg, context)</code>","text":"<p>Display an error block.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str | Message</code> <p>The error message to display.</p> required <code>context</code> <code>dict | Issue</code> <p>The dict/Issue to display in a block.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def error_block(\n    self,\n    msg: str | Message,\n    context: dict | Issue,\n) -&gt; Res[int]:\n    \"\"\"Display an error block.\n\n    Args:\n        msg: The error message to display.\n        context: The dict/Issue to display in a block.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    self.error(msg)\n    self.open_block('error', '', stderr=True)\n    self.error('', context)\n    self.close_block('error', stderr=True)\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/#m.log.Logger.open_block","title":"<code>open_block(name, description, stderr=False)</code>","text":"<p>Group log lines.</p> <p>Signals the formatter that the next log lines should be placed in a group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the block to open.</p> required <code>description</code> <code>str</code> <p>Not supported.</p> required <code>stderr</code> <code>bool</code> <p>Force message to be displayed in stderr.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def open_block(\n    self,\n    name: str,\n    description: str,\n    stderr: bool = False,\n) -&gt; Res[int]:\n    \"\"\"Group log lines.\n\n    Signals the formatter that the next log lines should be placed in a\n    group.\n\n    Args:\n        name: The name of the block to open.\n        description: Not supported.\n        stderr: Force message to be displayed in stderr.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    func = self.inst.error if stderr else self.inst.info\n    func(\n        'OPEN_BLOCK',\n        extra={'open_block': (name, description)},\n        stacklevel=2,\n    )\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/#m.log.Logger.waning_block","title":"<code>waning_block(msg, context)</code>","text":"<p>Display a warning block.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str | Message</code> <p>The warning message to display.</p> required <code>context</code> <code>dict | Issue</code> <p>The dict/Issue to display in a block.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def waning_block(\n    self,\n    msg: str | Message,\n    context: dict | Issue,\n) -&gt; Res[int]:\n    \"\"\"Display a warning block.\n\n    Args:\n        msg: The warning message to display.\n        context: The dict/Issue to display in a block.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    self.warning(msg)\n    self.open_block('warning', '', stderr=True)\n    self.warning('', context)\n    self.close_block('warning', stderr=True)\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/#m.log.Message","title":"<code>Message</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Parameters needed to deliver a warning or error message.</p> <p>Attributes:</p> Name Type Description <code>msg</code> <code>str</code> <p>message to display</p> <code>title</code> <code>str | None</code> <p>custom title</p> <code>file</code> <code>str | None</code> <p>filename</p> <code>line</code> <code>str | None</code> <p>line number, starting at 1</p> <code>end_line</code> <code>str | None</code> <p>end line number</p> <code>col</code> <code>str | None</code> <p>column number, starting at 1</p> <code>end_col</code> <code>str | None</code> <p>end column number</p> Source code in <code>m/log/ci_tools/types.py</code> <pre><code>class Message(BaseModel):\n    \"\"\"Parameters needed to deliver a warning or error message.\"\"\"\n\n    msg: str = Field(description='message to display')\n    title: str | None = Field(default=None, description='custom title')\n    file: str | None = Field(  # noqa: WPS110 - required by Github\n        default=None,\n        description='filename',\n    )\n    line: str | None = Field(\n        default=None,\n        description='line number, starting at 1',\n    )\n    end_line: str | None = Field(default=None, description='end line number')\n    col: str | None = Field(\n        default=None,\n        description='column number, starting at 1',\n    )\n    end_col: str | None = Field(default=None, description='end column number')\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/m/log/#m.log.get_ci_tool","title":"<code>get_ci_tool()</code>","text":"<p>Return the current CI Tool based on the environment variables.</p> <p>Returns:</p> Type Description <code>ProviderModule</code> <p>A <code>ProviderModule</code> instance with methods to provide messages in</p> <code>ProviderModule</code> <p>a CI environment.</p> Source code in <code>m/log/ci_tools/ci_tools.py</code> <pre><code>def get_ci_tool() -&gt; ProviderModule:\n    \"\"\"Return the current CI Tool based on the environment variables.\n\n    Returns:\n        A `ProviderModule` instance with methods to provide messages in\n        a CI environment.\n    \"\"\"\n    env = mio.env\n    if env('GITHUB_ACTIONS'):\n        return gh_tool\n    if env('TC') or env('TEAMCITY'):\n        return tc_tool\n    return local_tool\n</code></pre>"},{"location":"api/m/log/#m.log.logging_config","title":"<code>logging_config(level=None, json_file='')</code>","text":"<p>Apply a configuration to the logs.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | None</code> <p>The logging level, defaults to INFO.</p> <code>None</code> <code>json_file</code> <code>str</code> <p>Optional file name where to store each log record as json.</p> <code>''</code> Source code in <code>m/log/config.py</code> <pre><code>def logging_config(level: int | None = None, json_file: str = '') -&gt; None:\n    \"\"\"Apply a configuration to the logs.\n\n    Args:\n        level: The logging level, defaults to INFO.\n        json_file: Optional file name where to store each log record as json.\n    \"\"\"\n    formatter = CiFormatter()\n    stdout_handler = StdOutHandler(formatter)\n    stderr_handler = StdErrHandler(formatter)\n    all_handlers = [stderr_handler, stdout_handler]\n    if json_file:\n        json_formatter = JsonFormatter()\n        all_handlers.append(JsonFileHandler(json_formatter, json_file))\n\n    debug_logs = mio.env('DEBUG_M_LOGS', 'false') == 'true'\n    default_level = logging.DEBUG if debug_logs else logging.INFO\n    logging_level = level if level is not None else default_level\n    logging.basicConfig(\n        level=logging_level,\n        handlers=all_handlers,\n        force=True,\n    )\n</code></pre>"},{"location":"api/m/log/config/","title":"config","text":""},{"location":"api/m/log/config/#m.log.config.logging_config","title":"<code>logging_config(level=None, json_file='')</code>","text":"<p>Apply a configuration to the logs.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | None</code> <p>The logging level, defaults to INFO.</p> <code>None</code> <code>json_file</code> <code>str</code> <p>Optional file name where to store each log record as json.</p> <code>''</code> Source code in <code>m/log/config.py</code> <pre><code>def logging_config(level: int | None = None, json_file: str = '') -&gt; None:\n    \"\"\"Apply a configuration to the logs.\n\n    Args:\n        level: The logging level, defaults to INFO.\n        json_file: Optional file name where to store each log record as json.\n    \"\"\"\n    formatter = CiFormatter()\n    stdout_handler = StdOutHandler(formatter)\n    stderr_handler = StdErrHandler(formatter)\n    all_handlers = [stderr_handler, stdout_handler]\n    if json_file:\n        json_formatter = JsonFormatter()\n        all_handlers.append(JsonFileHandler(json_formatter, json_file))\n\n    debug_logs = mio.env('DEBUG_M_LOGS', 'false') == 'true'\n    default_level = logging.DEBUG if debug_logs else logging.INFO\n    logging_level = level if level is not None else default_level\n    logging.basicConfig(\n        level=logging_level,\n        handlers=all_handlers,\n        force=True,\n    )\n</code></pre>"},{"location":"api/m/log/formatters/","title":"formatters","text":""},{"location":"api/m/log/formatters/#m.log.formatters.CiFormatter","title":"<code>CiFormatter</code>","text":"<p>             Bases: <code>Formatter</code></p> <p>A formatter that takes into account a CI environment.</p> <p>We can still use</p> Source code in <code>m/log/formatters.py</code> <pre><code>class CiFormatter(logging.Formatter):\n    \"\"\"A formatter that takes into account a CI environment.\n\n    We can still use\n    \"\"\"\n\n    def __init__(\n        self,\n        datefmt: str = '%I:%M:%S %p - %b %d, %Y',  # noqa: WPS323\n    ):\n        \"\"\"Initialize by optionally providing a date formatter.\n\n        See https://docs.python.org/3/library/time.html#time.strftime\n        for more info on how to format the date.\n\n        Args:\n            datefmt: The date format to use.\n        \"\"\"\n        super().__init__(datefmt=datefmt)\n        self.opened_blocks: list[str] = []\n        self.ci_tool = get_ci_tool()\n        self.show_traceback = mio.is_traceback_enabled()\n        self.debug_python = mio.is_python_info_enabled()\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        \"\"\"Format a record as based on the CI environment.\n\n        Args:\n            record: The logRecord to format.\n\n        Returns:\n            A formatted string.\n        \"\"\"\n        msg = self.ci_tool.formatter(\n            self,\n            record,\n            self.show_traceback,\n            self.debug_python,\n        )\n        if self.ci_tool.ci:\n            return msg\n\n        record_dict = record.__dict__\n        open_b = record_dict.get('open_block')\n        close_b = record_dict.get('close_block')\n\n        if open_b:\n            name, _ = open_b\n            self.opened_blocks.append(name)\n        if close_b:\n            while self.opened_blocks and self.opened_blocks[-1] != close_b:\n                self.opened_blocks.pop()\n            if self.opened_blocks:\n                self.opened_blocks.pop()\n\n        if not self.opened_blocks:\n            return msg\n        return textwrap.indent(msg, '  ' * len(self.opened_blocks))\n</code></pre>"},{"location":"api/m/log/formatters/#m.log.formatters.CiFormatter.__init__","title":"<code>__init__(datefmt='%I:%M:%S %p - %b %d, %Y')</code>","text":"<p>Initialize by optionally providing a date formatter.</p> <p>See https://docs.python.org/3/library/time.html#time.strftime for more info on how to format the date.</p> <p>Parameters:</p> Name Type Description Default <code>datefmt</code> <code>str</code> <p>The date format to use.</p> <code>'%I:%M:%S %p - %b %d, %Y'</code> Source code in <code>m/log/formatters.py</code> <pre><code>def __init__(\n    self,\n    datefmt: str = '%I:%M:%S %p - %b %d, %Y',  # noqa: WPS323\n):\n    \"\"\"Initialize by optionally providing a date formatter.\n\n    See https://docs.python.org/3/library/time.html#time.strftime\n    for more info on how to format the date.\n\n    Args:\n        datefmt: The date format to use.\n    \"\"\"\n    super().__init__(datefmt=datefmt)\n    self.opened_blocks: list[str] = []\n    self.ci_tool = get_ci_tool()\n    self.show_traceback = mio.is_traceback_enabled()\n    self.debug_python = mio.is_python_info_enabled()\n</code></pre>"},{"location":"api/m/log/formatters/#m.log.formatters.CiFormatter.format","title":"<code>format(record)</code>","text":"<p>Format a record as based on the CI environment.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The logRecord to format.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/formatters.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"Format a record as based on the CI environment.\n\n    Args:\n        record: The logRecord to format.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    msg = self.ci_tool.formatter(\n        self,\n        record,\n        self.show_traceback,\n        self.debug_python,\n    )\n    if self.ci_tool.ci:\n        return msg\n\n    record_dict = record.__dict__\n    open_b = record_dict.get('open_block')\n    close_b = record_dict.get('close_block')\n\n    if open_b:\n        name, _ = open_b\n        self.opened_blocks.append(name)\n    if close_b:\n        while self.opened_blocks and self.opened_blocks[-1] != close_b:\n            self.opened_blocks.pop()\n        if self.opened_blocks:\n            self.opened_blocks.pop()\n\n    if not self.opened_blocks:\n        return msg\n    return textwrap.indent(msg, '  ' * len(self.opened_blocks))\n</code></pre>"},{"location":"api/m/log/formatters/#m.log.formatters.JsonFormatter","title":"<code>JsonFormatter</code>","text":"<p>             Bases: <code>Formatter</code></p> <p>Format each record as JSON data in one single line.</p> Source code in <code>m/log/formatters.py</code> <pre><code>class JsonFormatter(logging.Formatter):\n    \"\"\"Format each record as JSON data in one single line.\"\"\"\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        \"\"\"Format a record as json.\n\n        Args:\n            record: The logRecord to format.\n\n        Returns:\n            A formatted string.\n        \"\"\"\n        record_dict = record.__dict__\n        context = record_dict.get('context')\n        ci_info = record_dict.get('ci_info', Message(msg=record.msg))\n        replacements = {\n            **record_dict,\n            **ci_info.model_dump(),\n            'asctime': self.formatTime(record, self.datefmt),\n            'context': context,\n        }\n        replacements.pop('ci_info', '')\n        sanitized = {\n            key: non_empty\n            for key, non_empty in replacements.items()\n            if non_empty\n        }\n        return json.dumps(sanitized)\n</code></pre>"},{"location":"api/m/log/formatters/#m.log.formatters.JsonFormatter.format","title":"<code>format(record)</code>","text":"<p>Format a record as json.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The logRecord to format.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/formatters.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"Format a record as json.\n\n    Args:\n        record: The logRecord to format.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    record_dict = record.__dict__\n    context = record_dict.get('context')\n    ci_info = record_dict.get('ci_info', Message(msg=record.msg))\n    replacements = {\n        **record_dict,\n        **ci_info.model_dump(),\n        'asctime': self.formatTime(record, self.datefmt),\n        'context': context,\n    }\n    replacements.pop('ci_info', '')\n    sanitized = {\n        key: non_empty\n        for key, non_empty in replacements.items()\n        if non_empty\n    }\n    return json.dumps(sanitized)\n</code></pre>"},{"location":"api/m/log/handlers/","title":"handlers","text":""},{"location":"api/m/log/handlers/#m.log.handlers.JsonFileHandler","title":"<code>JsonFileHandler</code>","text":"<p>             Bases: <code>FileHandler</code></p> <p>A log handler to output to a file.</p> Source code in <code>m/log/handlers.py</code> <pre><code>class JsonFileHandler(logging.FileHandler):\n    \"\"\"A log handler to output to a file.\"\"\"\n\n    def __init__(self, formatter: logging.Formatter, filename: str):\n        \"\"\"Initialize the handler.\n\n        Args:\n            formatter: The formatter to use with the handler.\n            filename: The file where to store the log recrods.\n        \"\"\"\n        super().__init__(filename, encoding='UTF-8')\n        self.setFormatter(formatter)\n\n    def filter(self, _record: logging.LogRecord) -&gt; bool:\n        \"\"\"Display all records.\n\n        Args:\n            _record: A logging record instance.\n\n        Returns:\n            True\n        \"\"\"\n        return True\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.JsonFileHandler.__init__","title":"<code>__init__(formatter, filename)</code>","text":"<p>Initialize the handler.</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>Formatter</code> <p>The formatter to use with the handler.</p> required <code>filename</code> <code>str</code> <p>The file where to store the log recrods.</p> required Source code in <code>m/log/handlers.py</code> <pre><code>def __init__(self, formatter: logging.Formatter, filename: str):\n    \"\"\"Initialize the handler.\n\n    Args:\n        formatter: The formatter to use with the handler.\n        filename: The file where to store the log recrods.\n    \"\"\"\n    super().__init__(filename, encoding='UTF-8')\n    self.setFormatter(formatter)\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.JsonFileHandler.filter","title":"<code>filter(_record)</code>","text":"<p>Display all records.</p> <p>Parameters:</p> Name Type Description Default <code>_record</code> <code>LogRecord</code> <p>A logging record instance.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True</p> Source code in <code>m/log/handlers.py</code> <pre><code>def filter(self, _record: logging.LogRecord) -&gt; bool:\n    \"\"\"Display all records.\n\n    Args:\n        _record: A logging record instance.\n\n    Returns:\n        True\n    \"\"\"\n    return True\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdErrHandler","title":"<code>StdErrHandler</code>","text":"<p>             Bases: <code>StreamHandler</code></p> <p>A log handler to print to stderr.</p> Source code in <code>m/log/handlers.py</code> <pre><code>class StdErrHandler(logging.StreamHandler):\n    \"\"\"A log handler to print to stderr.\"\"\"\n\n    def __init__(self, formatter: logging.Formatter):\n        \"\"\"Initialize the handler.\n\n        Args:\n            formatter: The formatter to use with the handler.\n        \"\"\"\n        super().__init__(sys.stderr)\n        self.setFormatter(formatter)\n\n    def filter(self, record: logging.LogRecord) -&gt; bool:\n        \"\"\"Only display warnings or error records.\n\n        Args:\n            record: A logging record instance.\n\n        Returns:\n            True if the record is a warning or error.\n        \"\"\"\n        return record.levelno &gt;= logging.WARNING\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdErrHandler.__init__","title":"<code>__init__(formatter)</code>","text":"<p>Initialize the handler.</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>Formatter</code> <p>The formatter to use with the handler.</p> required Source code in <code>m/log/handlers.py</code> <pre><code>def __init__(self, formatter: logging.Formatter):\n    \"\"\"Initialize the handler.\n\n    Args:\n        formatter: The formatter to use with the handler.\n    \"\"\"\n    super().__init__(sys.stderr)\n    self.setFormatter(formatter)\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdErrHandler.filter","title":"<code>filter(record)</code>","text":"<p>Only display warnings or error records.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>A logging record instance.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the record is a warning or error.</p> Source code in <code>m/log/handlers.py</code> <pre><code>def filter(self, record: logging.LogRecord) -&gt; bool:\n    \"\"\"Only display warnings or error records.\n\n    Args:\n        record: A logging record instance.\n\n    Returns:\n        True if the record is a warning or error.\n    \"\"\"\n    return record.levelno &gt;= logging.WARNING\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdOutHandler","title":"<code>StdOutHandler</code>","text":"<p>             Bases: <code>StreamHandler</code></p> <p>A log handler to print to stdout.</p> Source code in <code>m/log/handlers.py</code> <pre><code>class StdOutHandler(logging.StreamHandler):\n    \"\"\"A log handler to print to stdout.\"\"\"\n\n    def __init__(self, formatter: logging.Formatter):\n        \"\"\"Initialize the handler.\n\n        Args:\n            formatter: The formatter to use with the handler.\n        \"\"\"\n        super().__init__(sys.stdout)\n        self.setFormatter(formatter)\n\n    def filter(self, record: logging.LogRecord) -&gt; bool:\n        \"\"\"Display non-warnings and non-error records.\n\n        Args:\n            record: A logging record instance.\n\n        Returns:\n            True if the record is not a warning or error.\n        \"\"\"\n        return record.levelno &lt; logging.WARNING\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdOutHandler.__init__","title":"<code>__init__(formatter)</code>","text":"<p>Initialize the handler.</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>Formatter</code> <p>The formatter to use with the handler.</p> required Source code in <code>m/log/handlers.py</code> <pre><code>def __init__(self, formatter: logging.Formatter):\n    \"\"\"Initialize the handler.\n\n    Args:\n        formatter: The formatter to use with the handler.\n    \"\"\"\n    super().__init__(sys.stdout)\n    self.setFormatter(formatter)\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdOutHandler.filter","title":"<code>filter(record)</code>","text":"<p>Display non-warnings and non-error records.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>A logging record instance.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the record is not a warning or error.</p> Source code in <code>m/log/handlers.py</code> <pre><code>def filter(self, record: logging.LogRecord) -&gt; bool:\n    \"\"\"Display non-warnings and non-error records.\n\n    Args:\n        record: A logging record instance.\n\n    Returns:\n        True if the record is not a warning or error.\n    \"\"\"\n    return record.levelno &lt; logging.WARNING\n</code></pre>"},{"location":"api/m/log/logger/","title":"logger","text":""},{"location":"api/m/log/logger/#m.log.logger.Logger","title":"<code>Logger</code>","text":"<p>Wrapper for python Logger to enable inserting logs in fp loops.</p> <p>This is also so that we may attach context data for a message.</p> <p>We can access the actual logger by using <code>inst</code>.</p> Source code in <code>m/log/logger.py</code> <pre><code>class Logger:  # noqa: WPS230 - loggers have many attributes\n    \"\"\"Wrapper for python Logger to enable inserting logs in fp loops.\n\n    This is also so that we may attach context data for a message.\n\n    We can access the actual logger by using `inst`.\n    \"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    def __init__(self, name: str):\n        \"\"\"Initialize the Logger.\n\n        Args:\n            name: The name of a logger.\n        \"\"\"\n        self.inst = logging.getLogger(name)\n        self.debug = partial(log_func_wrapper, self.inst.debug)\n        self.info = partial(log_func_wrapper, self.inst.info)  # noqa: WPS110\n        self.warning = partial(log_func_wrapper, self.inst.warning)\n        self.exception = partial(log_func_wrapper, self.inst.exception)\n        self.critical = partial(log_func_wrapper, self.inst.critical)\n        self.log = partial(log_func_wrapper, self.inst.log)\n        self.prompt = partial(\n            log_func_wrapper,\n            cast(PromptLogger, self.inst).prompt,\n        )\n        self.error = partial(log_func_wrapper, self.inst.error)\n\n    def open_block(\n        self,\n        name: str,\n        description: str,\n        stderr: bool = False,\n    ) -&gt; Res[int]:\n        \"\"\"Group log lines.\n\n        Signals the formatter that the next log lines should be placed in a\n        group.\n\n        Args:\n            name: The name of the block to open.\n            description: Not supported.\n            stderr: Force message to be displayed in stderr.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        func = self.inst.error if stderr else self.inst.info\n        func(\n            'OPEN_BLOCK',\n            extra={'open_block': (name, description)},\n            stacklevel=2,\n        )\n        return Good(0)\n\n    def close_block(\n        self,\n        name: str,\n        stderr: bool = False,\n    ) -&gt; Res[int]:\n        \"\"\"Close a group log lines.\n\n        Signals the formatter that the current group of lines should end.\n\n        Args:\n            name: The name of the block to close.\n            stderr: Force message to be displayed in stderr.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        func = self.inst.error if stderr else self.inst.info\n        func(\n            'CLOSE_BLOCK',\n            extra={'close_block': name},\n            stacklevel=2,\n        )\n        return Good(0)\n\n    def error_block(\n        self,\n        msg: str | Message,\n        context: dict | Issue,\n    ) -&gt; Res[int]:\n        \"\"\"Display an error block.\n\n        Args:\n            msg: The error message to display.\n            context: The dict/Issue to display in a block.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        self.error(msg)\n        self.open_block('error', '', stderr=True)\n        self.error('', context)\n        self.close_block('error', stderr=True)\n        return Good(0)\n\n    def waning_block(\n        self,\n        msg: str | Message,\n        context: dict | Issue,\n    ) -&gt; Res[int]:\n        \"\"\"Display a warning block.\n\n        Args:\n            msg: The warning message to display.\n            context: The dict/Issue to display in a block.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        self.warning(msg)\n        self.open_block('warning', '', stderr=True)\n        self.warning('', context)\n        self.close_block('warning', stderr=True)\n        return Good(0)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.Logger.__init__","title":"<code>__init__(name)</code>","text":"<p>Initialize the Logger.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of a logger.</p> required Source code in <code>m/log/logger.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initialize the Logger.\n\n    Args:\n        name: The name of a logger.\n    \"\"\"\n    self.inst = logging.getLogger(name)\n    self.debug = partial(log_func_wrapper, self.inst.debug)\n    self.info = partial(log_func_wrapper, self.inst.info)  # noqa: WPS110\n    self.warning = partial(log_func_wrapper, self.inst.warning)\n    self.exception = partial(log_func_wrapper, self.inst.exception)\n    self.critical = partial(log_func_wrapper, self.inst.critical)\n    self.log = partial(log_func_wrapper, self.inst.log)\n    self.prompt = partial(\n        log_func_wrapper,\n        cast(PromptLogger, self.inst).prompt,\n    )\n    self.error = partial(log_func_wrapper, self.inst.error)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.Logger.close_block","title":"<code>close_block(name, stderr=False)</code>","text":"<p>Close a group log lines.</p> <p>Signals the formatter that the current group of lines should end.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the block to close.</p> required <code>stderr</code> <code>bool</code> <p>Force message to be displayed in stderr.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def close_block(\n    self,\n    name: str,\n    stderr: bool = False,\n) -&gt; Res[int]:\n    \"\"\"Close a group log lines.\n\n    Signals the formatter that the current group of lines should end.\n\n    Args:\n        name: The name of the block to close.\n        stderr: Force message to be displayed in stderr.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    func = self.inst.error if stderr else self.inst.info\n    func(\n        'CLOSE_BLOCK',\n        extra={'close_block': name},\n        stacklevel=2,\n    )\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.Logger.error_block","title":"<code>error_block(msg, context)</code>","text":"<p>Display an error block.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str | Message</code> <p>The error message to display.</p> required <code>context</code> <code>dict | Issue</code> <p>The dict/Issue to display in a block.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def error_block(\n    self,\n    msg: str | Message,\n    context: dict | Issue,\n) -&gt; Res[int]:\n    \"\"\"Display an error block.\n\n    Args:\n        msg: The error message to display.\n        context: The dict/Issue to display in a block.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    self.error(msg)\n    self.open_block('error', '', stderr=True)\n    self.error('', context)\n    self.close_block('error', stderr=True)\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.Logger.open_block","title":"<code>open_block(name, description, stderr=False)</code>","text":"<p>Group log lines.</p> <p>Signals the formatter that the next log lines should be placed in a group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the block to open.</p> required <code>description</code> <code>str</code> <p>Not supported.</p> required <code>stderr</code> <code>bool</code> <p>Force message to be displayed in stderr.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def open_block(\n    self,\n    name: str,\n    description: str,\n    stderr: bool = False,\n) -&gt; Res[int]:\n    \"\"\"Group log lines.\n\n    Signals the formatter that the next log lines should be placed in a\n    group.\n\n    Args:\n        name: The name of the block to open.\n        description: Not supported.\n        stderr: Force message to be displayed in stderr.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    func = self.inst.error if stderr else self.inst.info\n    func(\n        'OPEN_BLOCK',\n        extra={'open_block': (name, description)},\n        stacklevel=2,\n    )\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.Logger.waning_block","title":"<code>waning_block(msg, context)</code>","text":"<p>Display a warning block.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str | Message</code> <p>The warning message to display.</p> required <code>context</code> <code>dict | Issue</code> <p>The dict/Issue to display in a block.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def waning_block(\n    self,\n    msg: str | Message,\n    context: dict | Issue,\n) -&gt; Res[int]:\n    \"\"\"Display a warning block.\n\n    Args:\n        msg: The warning message to display.\n        context: The dict/Issue to display in a block.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    self.warning(msg)\n    self.open_block('warning', '', stderr=True)\n    self.warning('', context)\n    self.close_block('warning', stderr=True)\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.PromptLogger","title":"<code>PromptLogger</code>","text":"<p>             Bases: <code>Logger</code></p> <p>Adding a prompt level to the logger.</p> Source code in <code>m/log/logger.py</code> <pre><code>class PromptLogger(logging.Logger):\n    \"\"\"Adding a prompt level to the logger.\"\"\"\n\n    def __init__(self, name: str, level: int = logging.NOTSET):\n        \"\"\"Override the Logger init function.\n\n        Args:\n            name: Loggers name.\n            level: An optional level.\n        \"\"\"\n        super().__init__(name, level)\n        logging.addLevelName(PROMPT, 'PROMPT')\n\n    def prompt(self, msg: str, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Log 'msg % args' with severity 'PROMPT'.\n\n        Args:\n            msg: The message to log\n            args: arguments to use in the message replacement.\n            kwargs: The keywords arguments to provide extra information.\n        \"\"\"\n        if self.isEnabledFor(PROMPT):\n            self._log(PROMPT, msg, args, **kwargs)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.PromptLogger.__init__","title":"<code>__init__(name, level=logging.NOTSET)</code>","text":"<p>Override the Logger init function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Loggers name.</p> required <code>level</code> <code>int</code> <p>An optional level.</p> <code>NOTSET</code> Source code in <code>m/log/logger.py</code> <pre><code>def __init__(self, name: str, level: int = logging.NOTSET):\n    \"\"\"Override the Logger init function.\n\n    Args:\n        name: Loggers name.\n        level: An optional level.\n    \"\"\"\n    super().__init__(name, level)\n    logging.addLevelName(PROMPT, 'PROMPT')\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.PromptLogger.prompt","title":"<code>prompt(msg, *args, **kwargs)</code>","text":"<p>Log 'msg % args' with severity 'PROMPT'.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log</p> required <code>args</code> <code>Any</code> <p>arguments to use in the message replacement.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keywords arguments to provide extra information.</p> <code>{}</code> Source code in <code>m/log/logger.py</code> <pre><code>def prompt(self, msg: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Log 'msg % args' with severity 'PROMPT'.\n\n    Args:\n        msg: The message to log\n        args: arguments to use in the message replacement.\n        kwargs: The keywords arguments to provide extra information.\n    \"\"\"\n    if self.isEnabledFor(PROMPT):\n        self._log(PROMPT, msg, args, **kwargs)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.log_func_wrapper","title":"<code>log_func_wrapper(func, msg, context=None, exit_code=0)</code>","text":"<p>Call a logger function with a message and log data.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A logger function (logger.info)</p> required <code>msg</code> <code>str | Message</code> <p>A string or Message containing information about the log.</p> required <code>context</code> <code>dict | Issue | None</code> <p>Data describing the log entry.</p> <code>None</code> <code>exit_code</code> <code>int</code> <p>Used in cli context to force an exit. Default to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> <code>Res[int]</code> <p>May be overwritten when signaling an error.</p> Source code in <code>m/log/logger.py</code> <pre><code>def log_func_wrapper(\n    func: Callable,\n    msg: str | Message,\n    context: dict | Issue | None = None,\n    exit_code: int = 0,\n) -&gt; Res[int]:\n    \"\"\"Call a logger function with a message and log data.\n\n    Args:\n        func: A logger function (logger.info)\n        msg: A string or Message containing information about the log.\n        context: Data describing the log entry.\n        exit_code: Used in cli context to force an exit. Default to 0.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n        May be overwritten when signaling an error.\n    \"\"\"\n    if isinstance(msg, str):\n        func(msg, extra={'context': context}, stacklevel=2)\n    else:\n        func(\n            msg.msg,\n            extra={'context': context, 'ci_info': msg},\n            stacklevel=2,\n        )\n    return Good(exit_code)\n</code></pre>"},{"location":"api/m/log/misc/","title":"misc","text":""},{"location":"api/m/log/misc/#m.log.misc.default_record_fmt","title":"<code>default_record_fmt(record, asctime, after_time, after_msg)</code>","text":"<p>Format a log record.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>A log record.</p> required <code>asctime</code> <code>str</code> <p>The string representing the time of creation.</p> required <code>after_time</code> <code>str</code> <p>A string that will be placed after the time.</p> required <code>after_msg</code> <code>str</code> <p>A string to be placed after the main message.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/misc.py</code> <pre><code>def default_record_fmt(\n    record: logging.LogRecord,\n    asctime: str,\n    after_time: str,\n    after_msg: str,\n) -&gt; str:\n    \"\"\"Format a log record.\n\n    Args:\n        record: A log record.\n        asctime: The string representing the time of creation.\n        after_time: A string that will be placed after the time.\n        after_msg: A string to be placed after the main message.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    level_color = {\n        logging.DEBUG: 'green',\n        logging.INFO: 'blue',\n        logging.WARNING: 'yellow',\n        PROMPT: 'bold_blue',\n        logging.ERROR: 'red',\n        logging.CRITICAL: 'bold_red',\n    }.get(record.levelno, 'gray')\n    fmt_time = color(f'{{gray}}[{asctime}]{{end}}') if asctime else ''\n    fmt_level = color(f'{{{level_color}}}[{record.levelname}]{{end}}')\n    prefix = f'{fmt_level} {fmt_time}{after_time}'.rstrip()\n    record_msg = record.msg\n    if level_color != 'blue':\n        record_msg = color(f'{{{level_color}}}{record_msg}{{end}}')\n    return f'{prefix}: {record_msg}{after_msg}'\n</code></pre>"},{"location":"api/m/log/misc/#m.log.misc.format_context","title":"<code>format_context(record, indent, show_traceback)</code>","text":"<p>Extract the context from a log record.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record instance.</p> required <code>indent</code> <code>int</code> <p>The level of indentation to apply to the string.</p> required <code>show_traceback</code> <code>bool</code> <p>Attempts to display the traceback if it exists.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string with leading new line of the context associated with a log</p> <code>str</code> <p>record.</p> Source code in <code>m/log/misc.py</code> <pre><code>def format_context(\n    record: logging.LogRecord,\n    indent: int,\n    show_traceback: bool,\n) -&gt; str:\n    \"\"\"Extract the context from a log record.\n\n    Args:\n        record: The log record instance.\n        indent: The level of indentation to apply to the string.\n        show_traceback: Attempts to display the traceback if it exists.\n\n    Returns:\n        A string with leading new line of the context associated with a log\n        record.\n    \"\"\"\n    context = record.__dict__.get('context')\n    data_dict = None\n    as_yaml = Issue.yaml_traceback\n    if isinstance(context, Issue):\n        data_dict = cast(dict, context.to_dict(show_traceback=show_traceback))\n        if context.only_context():\n            data_dict = data_dict['context']\n    else:\n        data_dict = context\n    return (\n        indent_payload(indent, data_dict, as_yaml=as_yaml)\n        if data_dict\n        else ''\n    )\n</code></pre>"},{"location":"api/m/log/misc/#m.log.misc.format_location","title":"<code>format_location(parts, default_color='aqua')</code>","text":"<p>Join a list of possible defined strings.</p> <p>Parameters:</p> Name Type Description Default <code>parts</code> <code>list[str | None]</code> <p>A list of possibly defined strings.</p> required <code>default_color</code> <code>str</code> <p>The color to use for the string.</p> <code>'aqua'</code> <p>Returns:</p> Type Description <code>str</code> <p>A string with the location or an empty string.</p> Source code in <code>m/log/misc.py</code> <pre><code>def format_location(\n    parts: list[str | None],\n    default_color: str = 'aqua',\n) -&gt; str:\n    \"\"\"Join a list of possible defined strings.\n\n    Args:\n        parts: A list of possibly defined strings.\n        default_color: The color to use for the string.\n\n    Returns:\n        A string with the location or an empty string.\n    \"\"\"\n    loc = ':'.join([x for x in parts if x])\n    return color(f'{{{default_color}}}[{loc}]{{end}}') if loc else ''\n</code></pre>"},{"location":"api/m/log/misc/#m.log.misc.indent_payload","title":"<code>indent_payload(indent, payload, prepend_new_line=True, as_yaml=True)</code>","text":"<p>Stringify a dictionary as JSON and indent it.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>The number of spaces to indent.</p> required <code>payload</code> <code>dict</code> <p>The data to stringify and indent.</p> required <code>prepend_new_line</code> <code>bool</code> <p>Prepend a new line to the payload if <code>True</code>.</p> <code>True</code> <code>as_yaml</code> <code>bool</code> <p>Dump the payload in yaml.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>An indented payload.</p> Source code in <code>m/log/misc.py</code> <pre><code>def indent_payload(\n    indent: int,\n    payload: dict,\n    prepend_new_line: bool = True,\n    as_yaml: bool = True,\n) -&gt; str:\n    \"\"\"Stringify a dictionary as JSON and indent it.\n\n    Args:\n        indent: The number of spaces to indent.\n        payload: The data to stringify and indent.\n        prepend_new_line: Prepend a new line to the payload if `True`.\n        as_yaml: Dump the payload in yaml.\n\n    Returns:\n        An indented payload.\n    \"\"\"\n    json_dict = (\n        highlight_yaml(yaml.dumps(payload))\n        if as_yaml\n        else highlight_json(json.dumps(payload, indent=2))\n    )\n    indented_payload = textwrap.indent(json_dict, ' ' * indent)\n    return f'\\n{indented_payload}' if prepend_new_line else indented_payload\n</code></pre>"},{"location":"api/m/log/ci_tools/","title":"ci_tools","text":""},{"location":"api/m/log/ci_tools/ci_tools/","title":"ci_tools","text":""},{"location":"api/m/log/ci_tools/ci_tools/#m.log.ci_tools.ci_tools.get_ci_tool","title":"<code>get_ci_tool()</code>","text":"<p>Return the current CI Tool based on the environment variables.</p> <p>Returns:</p> Type Description <code>ProviderModule</code> <p>A <code>ProviderModule</code> instance with methods to provide messages in</p> <code>ProviderModule</code> <p>a CI environment.</p> Source code in <code>m/log/ci_tools/ci_tools.py</code> <pre><code>def get_ci_tool() -&gt; ProviderModule:\n    \"\"\"Return the current CI Tool based on the environment variables.\n\n    Returns:\n        A `ProviderModule` instance with methods to provide messages in\n        a CI environment.\n    \"\"\"\n    env = mio.env\n    if env('GITHUB_ACTIONS'):\n        return gh_tool\n    if env('TC') or env('TEAMCITY'):\n        return tc_tool\n    return local_tool\n</code></pre>"},{"location":"api/m/log/ci_tools/types/","title":"types","text":""},{"location":"api/m/log/ci_tools/types/#m.log.ci_tools.types.EnvVars","title":"<code>EnvVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class to store the values of the environment variables.</p> <p>Attributes:</p> Name Type Description <code>ci_env</code> <code>bool</code> <p>...</p> <code>github_token</code> <code>str</code> <p>...</p> <code>server_url</code> <code>str</code> <p>...</p> <code>run_id</code> <code>str</code> <p>...</p> <code>run_number</code> <code>str</code> <p>...</p> <code>run_url</code> <code>str</code> <p>...</p> <code>git_branch</code> <code>str</code> <p>...</p> <code>git_sha</code> <code>str</code> <p>...</p> <code>triggered_by</code> <code>str</code> <p>...</p> <code>triggered_by_email</code> <code>str</code> <p>...</p> <code>triggered_by_user</code> <code>str</code> <p>...</p> Source code in <code>m/log/ci_tools/types.py</code> <pre><code>class EnvVars(BaseModel):\n    \"\"\"Class to store the values of the environment variables.\"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    ci_env: bool = False\n    github_token: str = ''\n    server_url: str = ''\n    run_id: str = ''\n    run_number: str = ''\n    run_url: str = ''\n    git_branch: str = ''\n    git_sha: str = ''\n    triggered_by: str = ''\n    triggered_by_email: str = ''\n    triggered_by_user: str = ''\n</code></pre>"},{"location":"api/m/log/ci_tools/types/#m.log.ci_tools.types.Message","title":"<code>Message</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Parameters needed to deliver a warning or error message.</p> <p>Attributes:</p> Name Type Description <code>msg</code> <code>str</code> <p>message to display</p> <code>title</code> <code>str | None</code> <p>custom title</p> <code>file</code> <code>str | None</code> <p>filename</p> <code>line</code> <code>str | None</code> <p>line number, starting at 1</p> <code>end_line</code> <code>str | None</code> <p>end line number</p> <code>col</code> <code>str | None</code> <p>column number, starting at 1</p> <code>end_col</code> <code>str | None</code> <p>end column number</p> Source code in <code>m/log/ci_tools/types.py</code> <pre><code>class Message(BaseModel):\n    \"\"\"Parameters needed to deliver a warning or error message.\"\"\"\n\n    msg: str = Field(description='message to display')\n    title: str | None = Field(default=None, description='custom title')\n    file: str | None = Field(  # noqa: WPS110 - required by Github\n        default=None,\n        description='filename',\n    )\n    line: str | None = Field(\n        default=None,\n        description='line number, starting at 1',\n    )\n    end_line: str | None = Field(default=None, description='end line number')\n    col: str | None = Field(\n        default=None,\n        description='column number, starting at 1',\n    )\n    end_col: str | None = Field(default=None, description='end column number')\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/m/log/ci_tools/types/#m.log.ci_tools.types.ProviderModule","title":"<code>ProviderModule</code>  <code>dataclass</code>","text":"<p>Container to store functions from the providers.</p> Source code in <code>m/log/ci_tools/types.py</code> <pre><code>@dataclass\nclass ProviderModule:\n    \"\"\"Container to store functions from the providers.\"\"\"\n\n    ci: bool\n    env_vars: Callable[[], OneOf[Issue, EnvVars]]\n    formatter: Callable[\n        [logging.Formatter, logging.LogRecord, bool, bool],\n        str,\n    ]\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/","title":"providers","text":""},{"location":"api/m/log/ci_tools/providers/github/","title":"github","text":""},{"location":"api/m/log/ci_tools/providers/github/#m.log.ci_tools.providers.github.GithubEnvVars","title":"<code>GithubEnvVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Environment variables required when running in Github.</p> <p>Attributes:</p> Name Type Description <code>repo</code> <code>str</code> <p>...</p> <code>run_id</code> <code>str</code> <p>...</p> <code>run_number</code> <code>str</code> <p>...</p> <code>github_token</code> <code>str</code> <p>...</p> <code>git_branch</code> <code>str</code> <p>...</p> <code>git_sha</code> <code>str</code> <p>...</p> <code>triggered_by</code> <code>str</code> <p>...</p> Source code in <code>m/log/ci_tools/providers/github.py</code> <pre><code>class GithubEnvVars(BaseModel):\n    \"\"\"Environment variables required when running in Github.\"\"\"\n\n    repo: str = Field('GITHUB_REPOSITORY')\n    run_id: str = Field('GITHUB_RUN_ID')\n    run_number: str = Field('GITHUB_RUN_NUMBER')\n    github_token: str = Field('GITHUB_TOKEN')\n    git_branch: str = Field('GITHUB_REF')\n    git_sha: str = Field('GITHUB_SHA')\n    triggered_by: str = Field('GITHUB_ACTOR')\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/github/#m.log.ci_tools.providers.github.env_vars","title":"<code>env_vars()</code>","text":"<p>Read the environment variables from Github Actions.</p> <p>Returns:</p> Type Description <code>OneOf[Issue, EnvVars]</code> <p>An <code>EnvVars</code> instance or an Issue.</p> Source code in <code>m/log/ci_tools/providers/github.py</code> <pre><code>def env_vars() -&gt; OneOf[Issue, EnvVars]:\n    \"\"\"Read the environment variables from Github Actions.\n\n    Returns:\n        An `EnvVars` instance or an Issue.\n    \"\"\"\n    server_url = 'https://github.com'\n    return one_of(\n        lambda: [\n            EnvVars(\n                **env.model_dump(),\n                ci_env=True,\n                server_url=server_url,\n                run_url=run_url,\n            )\n            for env in mio.env_model(GithubEnvVars)\n            for run_url in (\n                f'{server_url}/{env.repo}/actions/runs/{env.run_id}',\n            )\n        ],\n    ).flat_map_bad(hone('GH Actions env_vars failure'))\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/github/#m.log.ci_tools.providers.github.log_format","title":"<code>log_format(formatter, record, show_traceback, debug_python)</code>","text":"<p>Format a log record using the functions provided in this module.</p> <p>This function is meant to be used by a log formatter. See more info</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>Formatter</code> <p>A log formatter instance.</p> required <code>record</code> <code>LogRecord</code> <p>A log record.</p> required <code>show_traceback</code> <code>bool</code> <p>If true, display the python stack trace.</p> required <code>debug_python</code> <code>bool</code> <p>If true, display the location of the record's origin.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/ci_tools/providers/github.py</code> <pre><code>def log_format(\n    formatter: logging.Formatter,\n    record: logging.LogRecord,\n    show_traceback: bool,\n    debug_python: bool,\n) -&gt; str:\n    \"\"\"Format a log record using the functions provided in this module.\n\n    This function is meant to be used by a log formatter. See more info\n\n\n    Args:\n        formatter: A log formatter instance.\n        record: A log record.\n        show_traceback: If true, display the python stack trace.\n        debug_python: If true, display the location of the record's origin.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    record_dict = record.__dict__\n\n    open_b = record_dict.get('open_block')\n    if open_b:\n        return _format_block(*open_b)\n\n    if record_dict.get('close_block'):\n        return '::endgroup::'\n\n    is_command = record.levelname in {'WARNING', 'ERROR'}\n\n    indent_padding = 2 if is_command else 3\n    indent = len(record.levelname) + indent_padding\n\n    ci_info = record_dict.get('ci_info', Message(msg=record.msg))\n    context = format_context(record, indent, show_traceback=show_traceback)\n    if not record.msg:\n        return context[1:]\n\n    loc = (\n        format_location([record.pathname, f'{record.lineno}'])\n        if debug_python\n        else ''\n    )\n    if is_command:\n        msg = f'{loc} {record.msg}'.lstrip()\n        return _gh_format(record.levelname.lower(), ci_info, msg, context)\n    return default_record_fmt(\n        record,\n        formatter.formatTime(record, formatter.datefmt),\n        loc,\n        context,\n    )\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/local/","title":"local","text":""},{"location":"api/m/log/ci_tools/providers/local/#m.log.ci_tools.providers.local.env_vars","title":"<code>env_vars()</code>","text":"<p>Obtain basic environment variables in a local environment.</p> <p>Returns:</p> Type Description <code>OneOf[Issue, EnvVars]</code> <p>An <code>EnvVars</code> instance if successful.</p> Source code in <code>m/log/ci_tools/providers/local.py</code> <pre><code>def env_vars() -&gt; OneOf[Issue, EnvVars]:\n    \"\"\"Obtain basic environment variables in a local environment.\n\n    Returns:\n        An `EnvVars` instance if successful.\n    \"\"\"\n    return one_of(\n        lambda: [\n            EnvVars(\n                git_branch=git_branch,\n                git_sha=git_sha,\n            )\n            for git_branch in git.get_branch()\n            for git_sha in git.get_current_commit_sha()\n        ],\n    )\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/local/#m.log.ci_tools.providers.local.log_format","title":"<code>log_format(formatter, record, show_traceback, debug_python)</code>","text":"<p>Format a log record using the functions provided in this module.</p> <p>This function is meant to be used by a log formatter. See more info</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>Formatter</code> <p>A log formatter instance.</p> required <code>record</code> <code>LogRecord</code> <p>A log record.</p> required <code>show_traceback</code> <code>bool</code> <p>If true, display the python stack trace.</p> required <code>debug_python</code> <code>bool</code> <p>If true, display the location of the record's origin.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/ci_tools/providers/local.py</code> <pre><code>def log_format(\n    formatter: logging.Formatter,\n    record: logging.LogRecord,\n    show_traceback: bool,\n    debug_python: bool,\n) -&gt; str:\n    \"\"\"Format a log record using the functions provided in this module.\n\n    This function is meant to be used by a log formatter. See more info\n\n\n    Args:\n        formatter: A log formatter instance.\n        record: A log record.\n        show_traceback: If true, display the python stack trace.\n        debug_python: If true, display the location of the record's origin.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    record_dict = record.__dict__\n\n    open_b = record_dict.get('open_block')\n    if open_b:\n        name, desc = open_b\n        return f'&gt;&gt;&gt; [{name}]: {desc}'.rstrip()\n\n    if record_dict.get('close_block'):\n        return ''\n\n    indent = len(record.levelname) + 3\n    context = format_context(record, indent, show_traceback=show_traceback)\n    if not record.msg:\n        return context[1:]\n\n    ci_info = record_dict.get('ci_info', Message(msg=record.msg))\n    msg_info = format_location([ci_info.file, ci_info.line, ci_info.col])\n    loc = (\n        format_location([record.pathname, f'{record.lineno}'], 'bold_aqua')\n        if debug_python\n        else ''\n    )\n\n    return default_record_fmt(\n        record,\n        formatter.formatTime(record, formatter.datefmt),\n        f'{msg_info}{loc}',\n        context,\n    )\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/teamcity/","title":"teamcity","text":""},{"location":"api/m/log/ci_tools/providers/teamcity/#m.log.ci_tools.providers.teamcity.env_vars","title":"<code>env_vars()</code>","text":"<p>Read basic environment variables from Teamcity.</p> <p>Returns:</p> Type Description <code>OneOf[Issue, EnvVars]</code> <p>An EnvVar instance.</p> Source code in <code>m/log/ci_tools/providers/teamcity.py</code> <pre><code>def env_vars() -&gt; OneOf[Issue, EnvVars]:\n    \"\"\"Read basic environment variables from Teamcity.\n\n    Returns:\n        An EnvVar instance.\n    \"\"\"\n    # WIP: Need to map other variables here. Not willing to do\n    # at the moment since I'm using Github.\n    return Good(EnvVars(ci_env=True))\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/teamcity/#m.log.ci_tools.providers.teamcity.escape_msg","title":"<code>escape_msg(msg)</code>","text":"<p>Escapes characters so Teamcity can print correctly.</p> <p>https://www.jetbrains.com/help/teamcity/build-script-interaction-with-teamcity.html#BuildScriptInteractionwithTeamCity-Escapedvalues</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to process.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A message that can be provided to Teamcity.</p> Source code in <code>m/log/ci_tools/providers/teamcity.py</code> <pre><code>def escape_msg(msg: str) -&gt; str:\n    \"\"\"Escapes characters so Teamcity can print correctly.\n\n    https://www.jetbrains.com/help/teamcity/build-script-interaction-with-teamcity.html#BuildScriptInteractionwithTeamCity-Escapedvalues\n\n    Args:\n        msg: The message to process.\n\n    Returns:\n        A message that can be provided to Teamcity.\n    \"\"\"\n    message = msg\n    for target, replacement in REPLACEMENTS:\n        message = message.replace(target, replacement)\n    return message\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/teamcity/#m.log.ci_tools.providers.teamcity.log_format","title":"<code>log_format(_formatter, record, show_traceback, debug_python)</code>","text":"<p>Format a log record using the functions provided in this module.</p> <p>This function is meant to be used by a log formatter. See more info</p> <p>See::     https://www.jetbrains.com/help/teamcity/build-script-interaction-with-teamcity.html#BuildScriptInteractionwithTeamCity-BlocksofServiceMessages</p> <p>Parameters:</p> Name Type Description Default <code>_formatter</code> <code>Formatter</code> <p>A log formatter instance.</p> required <code>record</code> <code>LogRecord</code> <p>A log record.</p> required <code>show_traceback</code> <code>bool</code> <p>If true, display the python stack trace.</p> required <code>debug_python</code> <code>bool</code> <p>If true, display the location of the record's origin.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/ci_tools/providers/teamcity.py</code> <pre><code>def log_format(\n    _formatter: logging.Formatter,\n    record: logging.LogRecord,\n    show_traceback: bool,\n    debug_python: bool,\n) -&gt; str:\n    \"\"\"Format a log record using the functions provided in this module.\n\n    This function is meant to be used by a log formatter. See more info\n\n    See::\n        https://www.jetbrains.com/help/teamcity/build-script-interaction-with-teamcity.html#BuildScriptInteractionwithTeamCity-BlocksofServiceMessages\n\n    Args:\n        _formatter: A log formatter instance.\n        record: A log record.\n        show_traceback: If true, display the python stack trace.\n        debug_python: If true, display the location of the record's origin.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    record_dict = record.__dict__\n\n    open_b = _fmt_open(record_dict)\n    if open_b:\n        return open_b\n\n    close_b = record_dict.get('close_block')\n    if close_b:\n        return _tc('blockClosed', postfix='', name=close_b)\n\n    indent_padding = 2 if record.levelname in {'WARNING', 'ERROR'} else 3\n    indent = len(record.levelname) + indent_padding\n\n    context = format_context(record, indent, show_traceback=show_traceback)\n    if not record.msg:\n        return context[1:]\n\n    ci_info = record_dict.get('ci_info', Message(msg=record.msg))\n    msg_info = format_location([ci_info.file, ci_info.line, ci_info.col])\n    msg_info = f'{msg_info}:' if msg_info else ''\n\n    loc = (\n        format_location([record.pathname, f'{record.lineno}'])\n        if debug_python\n        else ''\n    )\n\n    msg = f'{loc}{msg_info} {record.msg}'.lstrip()\n    if record.levelname == 'WARNING':\n        msg = _tc(\n            'message',\n            status='WARNING',\n            text=msg,\n            postfix=context,\n        )\n    elif record.levelname == 'ERROR':\n        msg = _tc('buildProblem', postfix=context, description=msg)\n    else:\n        msg = default_record_fmt(record, '', f'{msg_info}{loc}', context)\n    return msg\n</code></pre>"},{"location":"api/m/npm/","title":"npm","text":""},{"location":"api/m/npm/clean_tags/","title":"clean_tags","text":""},{"location":"api/m/npm/clean_tags/#m.npm.clean_tags.clean_tags","title":"<code>clean_tags(pkg)</code>","text":"<p>Remove tags from a package that point to empty versions.</p> <p>Parameters:</p> Name Type Description Default <code>pkg</code> <code>str</code> <p>The name of the npm package.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, List[str]]</code> <p>A <code>OneOf</code> containing a summary of removed tags or an Issue.</p> Source code in <code>m/npm/clean_tags.py</code> <pre><code>def clean_tags(pkg: str) -&gt; OneOf[Issue, List[str]]:\n    \"\"\"Remove tags from a package that point to empty versions.\n\n    Args:\n        pkg: The name of the npm package.\n\n    Returns:\n        A `OneOf` containing a summary of removed tags or an Issue.\n    \"\"\"\n    return one_of(lambda: [\n        summary\n        for tag_map in get_dist_tags(pkg)\n        for summary in remove_tags(pkg, find_empty_tags(tag_map))\n    ])\n</code></pre>"},{"location":"api/m/npm/clean_tags/#m.npm.clean_tags.find_empty_tags","title":"<code>find_empty_tags(tag_map)</code>","text":"<p>Create a set containing the npm tags that are empty.</p> <p>Parameters:</p> Name Type Description Default <code>tag_map</code> <code>Dict[str, str]</code> <p>A dictionary mapping npm tags to versions.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>A set of npm tags that map to empty strings.</p> Source code in <code>m/npm/clean_tags.py</code> <pre><code>def find_empty_tags(tag_map: Dict[str, str]) -&gt; Set[str]:\n    \"\"\"Create a set containing the npm tags that are empty.\n\n    Args:\n        tag_map: A dictionary mapping npm tags to versions.\n\n    Returns:\n        A set of npm tags that map to empty strings.\n    \"\"\"\n    return {\n        tag_name\n        for tag_name, version in tag_map.items()\n        if not version\n    }\n</code></pre>"},{"location":"api/m/npm/clean_tags/#m.npm.clean_tags.remove_tags","title":"<code>remove_tags(pkg, tags)</code>","text":"<p>Call <code>npm dist-tag</code> to remove npm tags.</p> <p>See https://docs.npmjs.com/cli/v8/commands/npm-dist-tag</p> <p>Parameters:</p> Name Type Description Default <code>pkg</code> <code>str</code> <p>The npm package.</p> required <code>tags</code> <code>Set[str]</code> <p>A set containing the tags to remove.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, List[str]]</code> <p>A <code>OneOf</code> containing a list of the output for each removed tag or an</p> <code>OneOf[Issue, List[str]]</code> <p>issue with a summary.</p> Source code in <code>m/npm/clean_tags.py</code> <pre><code>def remove_tags(pkg: str, tags: Set[str]) -&gt; OneOf[Issue, List[str]]:\n    \"\"\"Call `npm dist-tag` to remove npm tags.\n\n    See https://docs.npmjs.com/cli/v8/commands/npm-dist-tag\n\n    Args:\n        pkg: The npm package.\n        tags: A set containing the tags to remove.\n\n    Returns:\n        A `OneOf` containing a list of the output for each removed tag or an\n        issue with a summary.\n    \"\"\"\n    issues: List[Issue] = []\n    removed: List[str] = []\n    for tag in tags:\n        cmd_result = remove_dist_tag(pkg, tag)\n        if cmd_result.is_bad:\n            issues.append(cast(Issue, cmd_result.value))\n        else:\n            removed.append(cast(str, cmd_result.value))\n    if issues:\n        return issue('dist-tag rm issues', context={\n            'issues': issues,\n            'removed': removed,\n        })\n    return Good(removed)\n</code></pre>"},{"location":"api/m/npm/cli/","title":"cli","text":""},{"location":"api/m/npm/cli/#m.npm.cli.get_dist_tags","title":"<code>get_dist_tags(pkg_name)</code>","text":"<p>Fetch all the npm tags for a package.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The name of the npm package.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, Dict[str, str]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or map specifying the tags to a</p> <code>OneOf[Issue, Dict[str, str]]</code> <p>published version.</p> Source code in <code>m/npm/cli.py</code> <pre><code>def get_dist_tags(pkg_name: str) -&gt; OneOf[Issue, Dict[str, str]]:\n    \"\"\"Fetch all the npm tags for a package.\n\n    Args:\n        pkg_name: The name of the npm package.\n\n    Returns:\n        A `OneOf` containing an `Issue` or map specifying the tags to a\n        published version.\n    \"\"\"\n    cmd = f'npm info {pkg_name} dist-tags --json'\n    return one_of(lambda: [\n        tag_map\n        for payload in subprocess.eval_cmd(cmd)\n        for tag_map in parse_json(payload)\n    ])\n</code></pre>"},{"location":"api/m/npm/cli/#m.npm.cli.remove_dist_tag","title":"<code>remove_dist_tag(pkg_name, tag)</code>","text":"<p>Remove an npm tag.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The name of the npm package.</p> required <code>tag</code> <code>str</code> <p>The tag to remove.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the output of the npm command.</p> Source code in <code>m/npm/cli.py</code> <pre><code>def remove_dist_tag(pkg_name: str, tag: str) -&gt; OneOf[Issue, str]:\n    \"\"\"Remove an npm tag.\n\n    Args:\n        pkg_name: The name of the npm package.\n        tag: The tag to remove.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the output of the npm command.\n    \"\"\"\n    return subprocess.eval_cmd(f'npm dist-tag rm {pkg_name} {tag} --json')\n</code></pre>"},{"location":"api/m/npm/tag/","title":"tag","text":""},{"location":"api/m/npm/tag/#m.npm.tag.npm_tags","title":"<code>npm_tags(m_tag)</code>","text":"<p>Convert an m_tag to an npm_tag.</p> <p>Parameters:</p> Name Type Description Default <code>m_tag</code> <code>str</code> <p>A tag/version provided by m.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A tag that can be used by npm during the publishing step.</p> Source code in <code>m/npm/tag.py</code> <pre><code>def npm_tags(m_tag: str) -&gt; list[str]:\n    \"\"\"Convert an m_tag to an npm_tag.\n\n    Args:\n        m_tag: A tag/version provided by m.\n\n    Returns:\n        A tag that can be used by npm during the publishing step.\n    \"\"\"\n    tags = []\n    regex = r'\\d+.\\d+.\\d+-(.*)\\.(.*)'\n    matches = re.match(regex, m_tag)\n    if matches:\n        tag, _ = matches.groups()\n        if tag.startswith('rc') or tag.startswith('hotfix'):\n            tags.append('next')\n        else:\n            tags.append(tag)\n    else:\n        tags.append('latest')\n    return tags\n</code></pre>"},{"location":"api/m/testing/","title":"testing","text":""},{"location":"api/m/testing/#m.testing.ActionStepTestCase","title":"<code>ActionStepTestCase</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Defines a test case for an action.</p> <p>Useful in the parametrization of several use cases for an action.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name for the test case. This is used as the identifier for a test case so that test failures may be easier to spot.</p> <code>py_file</code> <code>str</code> <p>Path to the python file to run.</p> <code>inputs</code> <code>dict[str, str]</code> <p>Inputs to the script. Should be of the form</p> <pre><code>{'INPUT_[SOME_NAME]': 'value'}\n</code></pre> <code>exit_code</code> <code>int</code> <p>The expected exit code (default: 0).</p> <code>expected_stdout</code> <code>str</code> <p>The expected stdout (default: empty).</p> <code>errors</code> <code>list[str]</code> <p>Errors may be noisy, specify strings that are expected to be in stderr in an array of strings.</p> <code>outputs</code> <code>list[str]</code> <p>list of Github outputs. Each entry in the array should be of the form</p> <pre><code>output-name=output-value\n</code></pre> <code>file_write_side_effect</code> <code>Any | None</code> <p>Defaults to <code>Good(0)</code>. This can be provided if we need to modify the behavior of m.core.rw.write_file. This is useful if we want to test cases in which a file failed to write.</p> Source code in <code>m/testing/testing.py</code> <pre><code>class ActionStepTestCase(BaseModel):\n    \"\"\"Defines a test case for an action.\n\n    Useful in the parametrization of several use cases for an action.\n    \"\"\"\n\n    name: str = Field(description=\"\"\"\n        Unique name for the test case. This is used as the identifier\n        for a test case so that test failures may be easier to spot.\n    \"\"\")\n\n    py_file: str = Field(description='Path to the python file to run.')\n\n    inputs: dict[str, str] = Field(description=\"\"\"\n        Inputs to the script. Should be of the form\n\n        ```py\n        {'INPUT_[SOME_NAME]': 'value'}\n        ```\n    \"\"\")\n\n    exit_code: int = Field(\n        default=0,\n        description='The expected exit code (default: 0).',\n    )\n\n    expected_stdout: str = Field(\n        default='',\n        description='The expected stdout (default: empty).',\n    )\n\n    # Errors may be noisy, specify strings that are expected to be in stderr\n    errors: list[str] = Field(\n        default=[],\n        description=\"\"\"\n            Errors may be noisy, specify strings that are expected to be in stderr\n            in an array of strings.\n        \"\"\",\n    )\n\n    # list of outputs: `output-name=output-value`\n    outputs: list[str] = Field(\n        default=[],\n        description=\"\"\"\n            list of Github outputs. Each entry in the array should be of the form\n\n            ```\n            output-name=output-value\n            ```\n        \"\"\",\n    )\n\n    file_write_side_effect: Any | None = Field(\n        default=None,\n        description=\"\"\"\n            Defaults to [`Good(0)`][m.core.fp.Good]. This can be provided if we\n            need to modify the behavior of [m.core.rw.write_file][]. This is\n            useful if we want to test cases in which a file failed to write.\n        \"\"\",\n    )\n</code></pre>"},{"location":"api/m/testing/#m.testing.block_m_side_effects","title":"<code>block_m_side_effects()</code>","text":"<p>Blocks functions that have side effects.</p> <p>This function overrides the definition of <code>m</code> so that we do not accidentally try write a lot of files or create/move directories.</p> <p>The pathlib.Path.mkdir function should only be blocked while developing tests. It is a reminder that we haven't mocked the function yet. If we want to get this reminder then add <code>touch m/.m/pytest-ran</code> after the tests run locally.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with references to the original functions that were overridden in case these are needed.</p> Source code in <code>m/testing/testing.py</code> <pre><code>def block_m_side_effects() -&gt; dict[str, Any]:\n    \"\"\"Blocks functions that have side effects.\n\n    This function overrides the definition of `m` so that we do not accidentally\n    try write a lot of files or create/move directories.\n\n    The [pathlib.Path.mkdir][] function should only be blocked while developing\n    tests. It is a reminder that we haven't mocked the function yet. If we want\n    to get this reminder then add `touch m/.m/pytest-ran` after the tests run\n    locally.\n\n    Returns:\n        A dictionary with references to the original functions that were\n            overridden in case these are needed.\n    \"\"\"\n    import shutil\n    import subprocess  # noqa: S404 - importing to disable it during testing\n    from pathlib import Path\n\n    from m.core import rw as mio\n\n    originals = {\n        'write_file': mio.write_file,\n        'Path_mkdir': Path.mkdir,\n        'shutil_move': shutil.move,\n    }\n\n    mio.write_file = mock('m.core.rw.write_file')\n    subprocess.check_output = mock('m.core.subprocess.eval_cmd')\n    subprocess.call = mock('m.core.subprocess.exec_pnpm')\n    shutil.move = mock('shutil.move')\n\n    if not os.environ.get('CI'):\n        # We want to make sure that we do not create directories during tests.\n        # To do so we will mock the Path.mkdir function. There is a problem:\n        # pytest needs this function to create directories for its own purposes.\n        # For this reason we will only mock the function after we create the\n        # m/.m/pytest-ran file.\n        if Path('m/.m/pytest-ran').exists():\n            Path.mkdir = mock('pathlib.Path.mkdir')  # type: ignore\n\n    return originals\n</code></pre>"},{"location":"api/m/testing/#m.testing.block_network_access","title":"<code>block_network_access()</code>","text":"<p>Blocks network access for all tests.</p> <p>This function overrides the definition of <code>socket</code> so that we do not accidentally try to run tests that make network calls. If our tests do not depend on other local services it is a good idea to call this before any of our tests runs.</p> <p>Otherwise we may want to modify this function to allow certain hosts to be called. (PRs welcomed).</p> Source code in <code>m/testing/testing.py</code> <pre><code>def block_network_access() -&gt; None:\n    \"\"\"Blocks network access for all tests.\n\n    This function overrides the definition of [`socket`][socket.socket] so that\n    we do not accidentally try to run tests that make network calls. If our tests\n    do not depend on other local services it is a good idea to call this before\n    any of our tests runs.\n\n    Otherwise we may want to modify this function to allow certain hosts to be\n    called. (PRs welcomed).\n    \"\"\"\n    # making sure that no calls to the internet are done\n    socket.socket = BlockNetwork  # type: ignore\n</code></pre>"},{"location":"api/m/testing/#m.testing.mock","title":"<code>mock(func_name)</code>","text":"<p>Create a function that raises an error if its not mocked.</p> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>str</code> <p>full module path to the function to mock.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A function that raises an error if its not mocked.</p> Source code in <code>m/testing/testing.py</code> <pre><code>def mock(func_name: str) -&gt; Any:\n    \"\"\"Create a function that raises an error if its not mocked.\n\n    Args:\n        func_name: full module path to the function to mock.\n\n    Returns:\n        A function that raises an error if its not mocked.\n    \"\"\"\n    return partial(needs_mocking, func_name)\n</code></pre>"},{"location":"api/m/testing/#m.testing.run_action_step","title":"<code>run_action_step(mocker, *, py_file, exit_code, env_vars, file_write_side_effect=None)</code>","text":"<p>Execute an action step in a test.</p> <p>This function expects the inputs to the script to be provided via environment variables of the form <code>INPUT_[SOME_NAME]</code>. The script will write the outputs to the file <code>FAKE_GITHUB_OUTPUT.txt</code>. We can verify the contents of the file by looking at the 3rd output from the function. This is a dictionary mapping file names to contents. Please note that this testing function mocks m.core.rw.write_file to obtain the file contents.</p> <p>Parameters:</p> Name Type Description Default <code>mocker</code> <code>MockerFixture</code> <p>A reference to the pytest <code>MockerFixture</code>.</p> required <code>py_file</code> <code>str</code> <p>The full path to the file that Github Actions will run.</p> required <code>exit_code</code> <code>int</code> <p>The expected exit code of the action. <code>0</code> means all is good.</p> required <code>env_vars</code> <code>dict[str, str]</code> <p>A dictionary of the environment variables that the action will receive.</p> required <code>file_write_side_effect</code> <code>Any | None</code> <p>This can be provided if we need to modify the behavior of m.core.rw.write_file. This is useful if we want to test cases in which a file failed to write.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, dict[str, str]]</code> <p>The standard out, standard error, and files written by m.core.rw.write_file.</p> Source code in <code>m/testing/conftest.py</code> <pre><code>def run_action_step(\n    mocker: MockerFixture,\n    *,\n    py_file: str,\n    exit_code: int,\n    env_vars: dict[str, str],\n    file_write_side_effect: Any | None = None,\n) -&gt; tuple[str, str, dict[str, str]]:\n    \"\"\"Execute an action step in a test.\n\n    This function expects the inputs to the script to be provided via environment\n    variables of the form `INPUT_[SOME_NAME]`. The script will write the outputs\n    to the file `FAKE_GITHUB_OUTPUT.txt`. We can verify the contents of the file\n    by looking at the 3rd output from the function. This is a dictionary mapping\n    file names to contents. Please note that this testing function mocks\n    [m.core.rw.write_file][] to obtain the file contents.\n\n    Args:\n        mocker: A reference to the pytest `MockerFixture`.\n        py_file: The full path to the file that Github Actions will run.\n        exit_code: The expected exit code of the action. `0` means all is good.\n        env_vars: A dictionary of the environment variables that the action will\n            receive.\n        file_write_side_effect: This can be provided if we need to modify the\n            behavior of [m.core.rw.write_file][]. This is useful if we want to\n            test cases in which a file failed to write.\n\n    Returns:\n        The standard out, standard error, and files written by [m.core.rw.write_file][].\n    \"\"\"\n    mocker.patch.dict(\n        os.environ,\n        {\n            'NO_COLOR': 'true',\n            **env_vars,\n            'GITHUB_OUTPUT': 'FAKE_GITHUB_OUTPUT.txt',\n        },\n        clear=True,\n    )\n\n    std_out = StringIO()\n    std_err = StringIO()\n    mocker.patch.object(sys, 'stdout', std_out)\n    mocker.patch.object(sys, 'stderr', std_err)\n    file_write_mock = mocker.patch('m.core.rw.write_file')\n    file_write_mock.side_effect = file_write_side_effect or [Good(0)]\n\n    prog = None\n    with pytest.raises(SystemExit) as prog_block:\n        prog = prog_block\n        runpy.run_path(py_file, {}, '__main__')\n\n    # Would be nice to be able to reset via a the mocker\n    sys.stdout = sys.__stdout__\n    sys.stderr = sys.__stderr__\n    assert prog is not None  # noqa: S101 - to be used in testing\n    file_writes = {\n        call.args[0]: call.args[1]\n        for call in file_write_mock.call_args_list\n    }\n\n    # next block should not be covered by coverage, we have this as a utility\n    # to help us write tests.\n    prog_code = prog.value.code\n    if prog_code != exit_code:  # pragma: no cover\n        print(std_out.getvalue(), file=sys.stdout)  # noqa: WPS421\n        print(std_err.getvalue(), file=sys.stderr)  # noqa: WPS421\n    assert prog_code == exit_code   # noqa: S101 - to be used in testing\n    return std_out.getvalue(), std_err.getvalue(), file_writes\n</code></pre>"},{"location":"api/m/testing/#m.testing.run_action_test_case","title":"<code>run_action_test_case(mocker, tcase)</code>","text":"<p>Execute an action step test case.</p> <p>This is a commodity wrapper to help us run the action tests case. If we need more control over the assertions we can then copy and modify the implementation.</p> <p>Parameters:</p> Name Type Description Default <code>mocker</code> <code>MockerFixture</code> <p>A reference to the pytest <code>MockerFixture</code>.</p> required <code>tcase</code> <code>ActionStepTestCase</code> <p>The test case.</p> required Source code in <code>m/testing/conftest.py</code> <pre><code>def run_action_test_case(\n    mocker: MockerFixture,\n    tcase: ActionStepTestCase,\n) -&gt; None:\n    \"\"\"Execute an action step test case.\n\n    This is a commodity wrapper to help us run the action tests case. If we need\n    more control over the assertions we can then copy and modify the implementation.\n\n    Args:\n        mocker: A reference to the pytest `MockerFixture`.\n        tcase: The test case.\n    \"\"\"\n    stdout, stderr, file_writes = run_action_step(\n        mocker,\n        py_file=tcase.py_file,\n        exit_code=tcase.exit_code,\n        env_vars=tcase.inputs,\n        file_write_side_effect=tcase.file_write_side_effect,\n    )\n    assert stdout == tcase.expected_stdout  # noqa: S101\n    if tcase.errors:\n        for error in tcase.errors:\n            assert error in stderr  # noqa: S101\n\n    if tcase.exit_code == 0:\n        assert 'FAKE_GITHUB_OUTPUT.txt' in file_writes  # noqa: S101\n        gh_output = file_writes['FAKE_GITHUB_OUTPUT.txt']\n        assert gh_output == '\\n'.join(tcase.outputs)  # noqa: S101\n</code></pre>"},{"location":"api/m/testing/conftest/","title":"conftest","text":"<p>This module is provided to help with testing.</p> <p>The following external modules are expected to be available:</p> <ul> <li>pytest</li> <li>pytest-mock</li> </ul>"},{"location":"api/m/testing/conftest/#m.testing.conftest.run_action_step","title":"<code>run_action_step(mocker, *, py_file, exit_code, env_vars, file_write_side_effect=None)</code>","text":"<p>Execute an action step in a test.</p> <p>This function expects the inputs to the script to be provided via environment variables of the form <code>INPUT_[SOME_NAME]</code>. The script will write the outputs to the file <code>FAKE_GITHUB_OUTPUT.txt</code>. We can verify the contents of the file by looking at the 3rd output from the function. This is a dictionary mapping file names to contents. Please note that this testing function mocks m.core.rw.write_file to obtain the file contents.</p> <p>Parameters:</p> Name Type Description Default <code>mocker</code> <code>MockerFixture</code> <p>A reference to the pytest <code>MockerFixture</code>.</p> required <code>py_file</code> <code>str</code> <p>The full path to the file that Github Actions will run.</p> required <code>exit_code</code> <code>int</code> <p>The expected exit code of the action. <code>0</code> means all is good.</p> required <code>env_vars</code> <code>dict[str, str]</code> <p>A dictionary of the environment variables that the action will receive.</p> required <code>file_write_side_effect</code> <code>Any | None</code> <p>This can be provided if we need to modify the behavior of m.core.rw.write_file. This is useful if we want to test cases in which a file failed to write.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, dict[str, str]]</code> <p>The standard out, standard error, and files written by m.core.rw.write_file.</p> Source code in <code>m/testing/conftest.py</code> <pre><code>def run_action_step(\n    mocker: MockerFixture,\n    *,\n    py_file: str,\n    exit_code: int,\n    env_vars: dict[str, str],\n    file_write_side_effect: Any | None = None,\n) -&gt; tuple[str, str, dict[str, str]]:\n    \"\"\"Execute an action step in a test.\n\n    This function expects the inputs to the script to be provided via environment\n    variables of the form `INPUT_[SOME_NAME]`. The script will write the outputs\n    to the file `FAKE_GITHUB_OUTPUT.txt`. We can verify the contents of the file\n    by looking at the 3rd output from the function. This is a dictionary mapping\n    file names to contents. Please note that this testing function mocks\n    [m.core.rw.write_file][] to obtain the file contents.\n\n    Args:\n        mocker: A reference to the pytest `MockerFixture`.\n        py_file: The full path to the file that Github Actions will run.\n        exit_code: The expected exit code of the action. `0` means all is good.\n        env_vars: A dictionary of the environment variables that the action will\n            receive.\n        file_write_side_effect: This can be provided if we need to modify the\n            behavior of [m.core.rw.write_file][]. This is useful if we want to\n            test cases in which a file failed to write.\n\n    Returns:\n        The standard out, standard error, and files written by [m.core.rw.write_file][].\n    \"\"\"\n    mocker.patch.dict(\n        os.environ,\n        {\n            'NO_COLOR': 'true',\n            **env_vars,\n            'GITHUB_OUTPUT': 'FAKE_GITHUB_OUTPUT.txt',\n        },\n        clear=True,\n    )\n\n    std_out = StringIO()\n    std_err = StringIO()\n    mocker.patch.object(sys, 'stdout', std_out)\n    mocker.patch.object(sys, 'stderr', std_err)\n    file_write_mock = mocker.patch('m.core.rw.write_file')\n    file_write_mock.side_effect = file_write_side_effect or [Good(0)]\n\n    prog = None\n    with pytest.raises(SystemExit) as prog_block:\n        prog = prog_block\n        runpy.run_path(py_file, {}, '__main__')\n\n    # Would be nice to be able to reset via a the mocker\n    sys.stdout = sys.__stdout__\n    sys.stderr = sys.__stderr__\n    assert prog is not None  # noqa: S101 - to be used in testing\n    file_writes = {\n        call.args[0]: call.args[1]\n        for call in file_write_mock.call_args_list\n    }\n\n    # next block should not be covered by coverage, we have this as a utility\n    # to help us write tests.\n    prog_code = prog.value.code\n    if prog_code != exit_code:  # pragma: no cover\n        print(std_out.getvalue(), file=sys.stdout)  # noqa: WPS421\n        print(std_err.getvalue(), file=sys.stderr)  # noqa: WPS421\n    assert prog_code == exit_code   # noqa: S101 - to be used in testing\n    return std_out.getvalue(), std_err.getvalue(), file_writes\n</code></pre>"},{"location":"api/m/testing/conftest/#m.testing.conftest.run_action_test_case","title":"<code>run_action_test_case(mocker, tcase)</code>","text":"<p>Execute an action step test case.</p> <p>This is a commodity wrapper to help us run the action tests case. If we need more control over the assertions we can then copy and modify the implementation.</p> <p>Parameters:</p> Name Type Description Default <code>mocker</code> <code>MockerFixture</code> <p>A reference to the pytest <code>MockerFixture</code>.</p> required <code>tcase</code> <code>ActionStepTestCase</code> <p>The test case.</p> required Source code in <code>m/testing/conftest.py</code> <pre><code>def run_action_test_case(\n    mocker: MockerFixture,\n    tcase: ActionStepTestCase,\n) -&gt; None:\n    \"\"\"Execute an action step test case.\n\n    This is a commodity wrapper to help us run the action tests case. If we need\n    more control over the assertions we can then copy and modify the implementation.\n\n    Args:\n        mocker: A reference to the pytest `MockerFixture`.\n        tcase: The test case.\n    \"\"\"\n    stdout, stderr, file_writes = run_action_step(\n        mocker,\n        py_file=tcase.py_file,\n        exit_code=tcase.exit_code,\n        env_vars=tcase.inputs,\n        file_write_side_effect=tcase.file_write_side_effect,\n    )\n    assert stdout == tcase.expected_stdout  # noqa: S101\n    if tcase.errors:\n        for error in tcase.errors:\n            assert error in stderr  # noqa: S101\n\n    if tcase.exit_code == 0:\n        assert 'FAKE_GITHUB_OUTPUT.txt' in file_writes  # noqa: S101\n        gh_output = file_writes['FAKE_GITHUB_OUTPUT.txt']\n        assert gh_output == '\\n'.join(tcase.outputs)  # noqa: S101\n</code></pre>"},{"location":"api/m/testing/testing/","title":"testing","text":""},{"location":"api/m/testing/testing/#m.testing.testing.ActionStepTestCase","title":"<code>ActionStepTestCase</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Defines a test case for an action.</p> <p>Useful in the parametrization of several use cases for an action.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name for the test case. This is used as the identifier for a test case so that test failures may be easier to spot.</p> <code>py_file</code> <code>str</code> <p>Path to the python file to run.</p> <code>inputs</code> <code>dict[str, str]</code> <p>Inputs to the script. Should be of the form</p> <pre><code>{'INPUT_[SOME_NAME]': 'value'}\n</code></pre> <code>exit_code</code> <code>int</code> <p>The expected exit code (default: 0).</p> <code>expected_stdout</code> <code>str</code> <p>The expected stdout (default: empty).</p> <code>errors</code> <code>list[str]</code> <p>Errors may be noisy, specify strings that are expected to be in stderr in an array of strings.</p> <code>outputs</code> <code>list[str]</code> <p>list of Github outputs. Each entry in the array should be of the form</p> <pre><code>output-name=output-value\n</code></pre> <code>file_write_side_effect</code> <code>Any | None</code> <p>Defaults to <code>Good(0)</code>. This can be provided if we need to modify the behavior of m.core.rw.write_file. This is useful if we want to test cases in which a file failed to write.</p> Source code in <code>m/testing/testing.py</code> <pre><code>class ActionStepTestCase(BaseModel):\n    \"\"\"Defines a test case for an action.\n\n    Useful in the parametrization of several use cases for an action.\n    \"\"\"\n\n    name: str = Field(description=\"\"\"\n        Unique name for the test case. This is used as the identifier\n        for a test case so that test failures may be easier to spot.\n    \"\"\")\n\n    py_file: str = Field(description='Path to the python file to run.')\n\n    inputs: dict[str, str] = Field(description=\"\"\"\n        Inputs to the script. Should be of the form\n\n        ```py\n        {'INPUT_[SOME_NAME]': 'value'}\n        ```\n    \"\"\")\n\n    exit_code: int = Field(\n        default=0,\n        description='The expected exit code (default: 0).',\n    )\n\n    expected_stdout: str = Field(\n        default='',\n        description='The expected stdout (default: empty).',\n    )\n\n    # Errors may be noisy, specify strings that are expected to be in stderr\n    errors: list[str] = Field(\n        default=[],\n        description=\"\"\"\n            Errors may be noisy, specify strings that are expected to be in stderr\n            in an array of strings.\n        \"\"\",\n    )\n\n    # list of outputs: `output-name=output-value`\n    outputs: list[str] = Field(\n        default=[],\n        description=\"\"\"\n            list of Github outputs. Each entry in the array should be of the form\n\n            ```\n            output-name=output-value\n            ```\n        \"\"\",\n    )\n\n    file_write_side_effect: Any | None = Field(\n        default=None,\n        description=\"\"\"\n            Defaults to [`Good(0)`][m.core.fp.Good]. This can be provided if we\n            need to modify the behavior of [m.core.rw.write_file][]. This is\n            useful if we want to test cases in which a file failed to write.\n        \"\"\",\n    )\n</code></pre>"},{"location":"api/m/testing/testing/#m.testing.testing.BlockNetwork","title":"<code>BlockNetwork</code>","text":"<p>             Bases: <code>socket</code></p> <p>Implements a socket that blocks all network calls.</p> Source code in <code>m/testing/testing.py</code> <pre><code>class BlockNetwork(socket.socket):\n    \"\"\"Implements a socket that blocks all network calls.\"\"\"\n\n    # pylint: disable-next=super-init-not-called\n    def __init__(self, *args: Any, **kwargs: Any):\n        \"\"\"Raise an error if called.\n\n        Args:\n            args: ...\n            kwargs: ...\n\n        Raises:\n            RuntimeError: Always.\n        \"\"\"\n        raise RuntimeError('Network call blocked')\n</code></pre>"},{"location":"api/m/testing/testing/#m.testing.testing.BlockNetwork.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Raise an error if called.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>...</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>...</p> <code>{}</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Always.</p> Source code in <code>m/testing/testing.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any):\n    \"\"\"Raise an error if called.\n\n    Args:\n        args: ...\n        kwargs: ...\n\n    Raises:\n        RuntimeError: Always.\n    \"\"\"\n    raise RuntimeError('Network call blocked')\n</code></pre>"},{"location":"api/m/testing/testing/#m.testing.testing.block_m_side_effects","title":"<code>block_m_side_effects()</code>","text":"<p>Blocks functions that have side effects.</p> <p>This function overrides the definition of <code>m</code> so that we do not accidentally try write a lot of files or create/move directories.</p> <p>The pathlib.Path.mkdir function should only be blocked while developing tests. It is a reminder that we haven't mocked the function yet. If we want to get this reminder then add <code>touch m/.m/pytest-ran</code> after the tests run locally.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with references to the original functions that were overridden in case these are needed.</p> Source code in <code>m/testing/testing.py</code> <pre><code>def block_m_side_effects() -&gt; dict[str, Any]:\n    \"\"\"Blocks functions that have side effects.\n\n    This function overrides the definition of `m` so that we do not accidentally\n    try write a lot of files or create/move directories.\n\n    The [pathlib.Path.mkdir][] function should only be blocked while developing\n    tests. It is a reminder that we haven't mocked the function yet. If we want\n    to get this reminder then add `touch m/.m/pytest-ran` after the tests run\n    locally.\n\n    Returns:\n        A dictionary with references to the original functions that were\n            overridden in case these are needed.\n    \"\"\"\n    import shutil\n    import subprocess  # noqa: S404 - importing to disable it during testing\n    from pathlib import Path\n\n    from m.core import rw as mio\n\n    originals = {\n        'write_file': mio.write_file,\n        'Path_mkdir': Path.mkdir,\n        'shutil_move': shutil.move,\n    }\n\n    mio.write_file = mock('m.core.rw.write_file')\n    subprocess.check_output = mock('m.core.subprocess.eval_cmd')\n    subprocess.call = mock('m.core.subprocess.exec_pnpm')\n    shutil.move = mock('shutil.move')\n\n    if not os.environ.get('CI'):\n        # We want to make sure that we do not create directories during tests.\n        # To do so we will mock the Path.mkdir function. There is a problem:\n        # pytest needs this function to create directories for its own purposes.\n        # For this reason we will only mock the function after we create the\n        # m/.m/pytest-ran file.\n        if Path('m/.m/pytest-ran').exists():\n            Path.mkdir = mock('pathlib.Path.mkdir')  # type: ignore\n\n    return originals\n</code></pre>"},{"location":"api/m/testing/testing/#m.testing.testing.block_network_access","title":"<code>block_network_access()</code>","text":"<p>Blocks network access for all tests.</p> <p>This function overrides the definition of <code>socket</code> so that we do not accidentally try to run tests that make network calls. If our tests do not depend on other local services it is a good idea to call this before any of our tests runs.</p> <p>Otherwise we may want to modify this function to allow certain hosts to be called. (PRs welcomed).</p> Source code in <code>m/testing/testing.py</code> <pre><code>def block_network_access() -&gt; None:\n    \"\"\"Blocks network access for all tests.\n\n    This function overrides the definition of [`socket`][socket.socket] so that\n    we do not accidentally try to run tests that make network calls. If our tests\n    do not depend on other local services it is a good idea to call this before\n    any of our tests runs.\n\n    Otherwise we may want to modify this function to allow certain hosts to be\n    called. (PRs welcomed).\n    \"\"\"\n    # making sure that no calls to the internet are done\n    socket.socket = BlockNetwork  # type: ignore\n</code></pre>"},{"location":"api/m/testing/testing/#m.testing.testing.mock","title":"<code>mock(func_name)</code>","text":"<p>Create a function that raises an error if its not mocked.</p> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>str</code> <p>full module path to the function to mock.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A function that raises an error if its not mocked.</p> Source code in <code>m/testing/testing.py</code> <pre><code>def mock(func_name: str) -&gt; Any:\n    \"\"\"Create a function that raises an error if its not mocked.\n\n    Args:\n        func_name: full module path to the function to mock.\n\n    Returns:\n        A function that raises an error if its not mocked.\n    \"\"\"\n    return partial(needs_mocking, func_name)\n</code></pre>"},{"location":"api/m/testing/testing/#m.testing.testing.needs_mocking","title":"<code>needs_mocking(func_name, *args, **kwargs)</code>","text":"<p>Raise an exception asking developer to mock a function.</p> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>str</code> <p>name of the function</p> required <code>args</code> <code>Any</code> <p>...</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>...</p> <code>{}</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Always.</p> Source code in <code>m/testing/testing.py</code> <pre><code>def needs_mocking(func_name: str, *args: Any, **kwargs: Any):\n    \"\"\"Raise an exception asking developer to mock a function.\n\n    Args:\n        func_name: name of the function\n        args: ...\n        kwargs: ...\n\n    Raises:\n        RuntimeError: Always.\n    \"\"\"\n    raise RuntimeError(f'DEV ERROR: Need to mock {func_name}({args},{kwargs})')\n</code></pre>"},{"location":"cli/SUMMARY/","title":"SUMMARY","text":"<ul> <li>blueprints</li> <li>end_release</li> <li>init</li> <li>json</li> <li>jsonq</li> <li>review_release</li> <li>start_hotfix</li> <li>start_release</li> <li>ci<ul> <li>assert_branch</li> <li>bump_version</li> <li>celt</li> <li>env</li> <li>npm_tag</li> <li>release_setup</li> </ul> </li> <li>devcontainer<ul> <li>bashrc</li> <li>greet</li> <li>pnpm</li> <li>pnpm_setup</li> <li>prompter</li> <li>require_env_vars</li> </ul> </li> <li>git<ul> <li>branch</li> <li>current_sha</li> <li>first_sha</li> <li>status</li> <li>tag_release</li> </ul> </li> <li>github<ul> <li>actions</li> <li>branch_prs</li> <li>build_sha</li> <li>ci</li> <li>create_pr</li> <li>latest_release</li> <li>merge_pr</li> <li>pr</li> <li>release</li> <li>status</li> </ul> </li> <li>message<ul> <li>close</li> <li>error</li> <li>open</li> <li>sibling_block</li> <li>warn</li> </ul> </li> <li>npm<ul> <li>clean_tags</li> </ul> </li> </ul>"},{"location":"cli/blueprints/","title":"m blueprints","text":"<p>Create the <code>[m_dir]/.m/blueprints</code> directory.</p> <p>This will add shell scripts to build the specified docker images as stated in the <code>[m_dir]/m.yaml</code> file.</p> Source code in <code>m/cli/commands/blueprints.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Create the `[m_dir]/.m/blueprints` directory.\n\n    This will add shell scripts to build the specified docker images as\n    stated in the `[m_dir]/m.yaml` file.\n    \"\"\"\n\n    m_dir: str = Arg(\n        default='m',\n        help='m project directory',\n        positional=True,\n    )\n    m_tag: str = Arg(\n        default='M_TAG',\n        validator=env_var_or_empty,\n        help='unique version to use for all the images',\n    )\n    cache_from_pr: str = Arg(\n        default='M_CACHE_FROM_PR',\n        validator=env_var_or_empty,\n        help='pull request number to attempt to use as cache',\n    )\n    skip_makefile: bool = Arg(\n        default=False,\n        help='do not update Makefile',\n    )\n    skip_workflow: bool = Arg(\n        default=False,\n        help='do not update github workflow',\n    )\n</code></pre>"},{"location":"cli/blueprints/#options","title":"Options","text":""},{"location":"cli/blueprints/#m_tag","title":"<code>--m-tag</code>","text":"<ul><li>default: <code>env.M_TAG</code></li></ul> <p>unique version to use for all the images</p>"},{"location":"cli/blueprints/#cache_from_pr","title":"<code>--cache-from-pr</code>","text":"<ul><li>default: <code>env.M_CACHE_FROM_PR</code></li></ul> <p>pull request number to attempt to use as cache</p>"},{"location":"cli/blueprints/#skip_makefile","title":"<code>--skip-makefile</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>do not update Makefile</p>"},{"location":"cli/blueprints/#skip_workflow","title":"<code>--skip-workflow</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>do not update github workflow</p>"},{"location":"cli/blueprints/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/blueprints/#m_dir","title":"<code>m_dir</code>","text":"<ul><li>default: <code>'m'</code></li></ul> <p>m project directory</p>"},{"location":"cli/end_release/","title":"m end_release","text":"<p>End the release process.</p> <p>Merges the release/hotfix branch into the master branch.</p> Source code in <code>m/cli/commands/end_release.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"End the release process.\n\n    Merges the release/hotfix branch into the master branch.\n    \"\"\"\n\n    github_token: str = ArgProxy(\n        '--github-token',\n        default='GITHUB_TOKEN',\n        type=env_var,\n        help='Github personal access token with repo scope',\n    )\n</code></pre>"},{"location":"cli/end_release/#options","title":"Options","text":""},{"location":"cli/end_release/#github_token","title":"<code>--github-token</code>","text":"<ul><li>default: <code>env.GITHUB_TOKEN</code></li></ul> <p>Github personal access token with repo scope</p>"},{"location":"cli/init/","title":"m init","text":"<p>Create the necessary files for an m project.</p> Source code in <code>m/cli/commands/init.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Create the necessary files for an m project.\"\"\"\n</code></pre>"},{"location":"cli/json/","title":"m json","text":"<p>Format a json payload.</p> <p>similar to <code>python -m json.tool</code> but instead it uses 2 spaces for indentation::</p> <pre><code>$ echo '{\"a\":99}' | m json\n{\n  \"a\": 99\n}\n</code></pre> <p>It is worth noting that if you have access to <code>jq</code> or <code>yq</code> then it should be used instead of <code>m json</code>::</p> <pre><code>$ echo '{\"a\":99}' | jq\n{\n  \"a\": 99\n}\n</code></pre> <ul> <li>jq: https://stedolan.github.io/jq/manual/</li> <li>yq: https://mikefarah.gitbook.io/yq/</li> </ul> Source code in <code>m/cli/commands/json.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Format a json payload.\n\n    similar to `python -m json.tool` but instead it uses 2 spaces\n    for indentation::\n\n        $ echo '{\"a\":99}' | m json\n        {\n          \"a\": 99\n        }\n\n    It is worth noting that if you have access to `jq` or `yq` then\n    it should be used instead of `m json`::\n\n        $ echo '{\"a\":99}' | jq\n        {\n          \"a\": 99\n        }\n\n    - jq: https://stedolan.github.io/jq/manual/\n    - yq: https://mikefarah.gitbook.io/yq/\n    \"\"\"\n\n    payload: Any = Arg(\n        default='@-',\n        help='json data: @- (stdin), @filename (file), string',\n        positional=True,\n        validator=validate_json_payload,\n    )\n\n    sort_keys: bool = Arg(\n        default=False,\n        help='sort the output of dictionaries alphabetically by key',\n    )\n</code></pre>"},{"location":"cli/json/#options","title":"Options","text":""},{"location":"cli/json/#sort_keys","title":"<code>--sort-keys</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>sort the output of dictionaries alphabetically by key</p>"},{"location":"cli/json/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/json/#payload","title":"<code>payload</code>","text":"<ul><li>default: <code>'@-'</code></li></ul> <p>json data: @- (stdin), @filename (file), string</p>"},{"location":"cli/jsonq/","title":"m jsonq","text":"<p>Query json data.</p> <p>single value::</p> <pre><code>m jsonq path.to.property &lt; file.json\ncat file.json | m jsonq path.to.property\nm jsonq @file.json path.to.property\n</code></pre> <p>Return the value stored in the json file. For arrays and objects it will print the python representation of the object.</p> <p>multiple values::</p> <pre><code>m jsonq path1 path2 path3 &lt; file.json\ncat file.json | m jsonq path1 path2 path3\nm jsonq @file.json path1 path2 path3\n</code></pre> <p>use <code>read</code> to store in bash variables::</p> <pre><code>read -r -d '\\n' \\\n    var1 var2 var3 \\\n    &lt;&lt;&lt; \"$(m jsonq @file.json 'path1' 'path2' 'path3')\"\n</code></pre> <p>If available, take advantage of better queries through jq and yq:</p> <ul> <li>jq: https://stedolan.github.io/jq/manual/</li> <li>yq: https://mikefarah.gitbook.io/yq/</li> </ul> Source code in <code>m/cli/commands/jsonq.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Query json data.\n\n    single value::\n\n        m jsonq path.to.property &lt; file.json\n        cat file.json | m jsonq path.to.property\n        m jsonq @file.json path.to.property\n\n    Return the value stored in the json file. For arrays and objects it\n    will print the python representation of the object.\n\n    multiple values::\n\n        m jsonq path1 path2 path3 &lt; file.json\n        cat file.json | m jsonq path1 path2 path3\n        m jsonq @file.json path1 path2 path3\n\n    use `read` to store in bash variables::\n\n        read -r -d '\\n' \\\n            var1 var2 var3 \\\n            &lt;&lt;&lt; \"$(m jsonq @file.json 'path1' 'path2' 'path3')\"\n\n    If available, take advantage of better queries through jq and yq:\n\n    - jq: https://stedolan.github.io/jq/manual/\n    - yq: https://mikefarah.gitbook.io/yq/\n    \"\"\"\n\n    payload: Any = Arg(\n        default='@-',\n        help='json data: @- (stdin), @filename (file), string',\n        validator=validate_json_payload,\n        positional=True,\n    )\n\n    query: list[str] = Arg(\n        help='path to json data',\n        positional=True,\n        nargs='+',\n    )\n\n    warn: bool = Arg(\n        default=False,\n        help='print warning messages instead of errors',\n        aliases=['w', 'warn'],\n    )\n\n    separator: str = Arg(\n        default='\\n',\n        help='separator for multiple values',\n        aliases=['s', 'separator'],\n    )\n</code></pre>"},{"location":"cli/jsonq/#options","title":"Options","text":""},{"location":"cli/jsonq/#warn","title":"<code>-w</code>, <code>--warn</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>print warning messages instead of errors</p>"},{"location":"cli/jsonq/#separator","title":"<code>-s</code>, <code>--separator</code>","text":"<ul><li>default: <code>'\\n'</code></li></ul> <p>separator for multiple values</p>"},{"location":"cli/jsonq/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/jsonq/#payload","title":"<code>payload</code>","text":"<ul><li>default: <code>'@-'</code></li></ul> <p>json data: @- (stdin), @filename (file), string</p>"},{"location":"cli/jsonq/#query","title":"<code>query</code>","text":"<p>path to json data</p>"},{"location":"cli/review_release/","title":"m review_release","text":"<p>Create Github pull request(s) to review the release.</p> Source code in <code>m/cli/commands/review_release.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Create Github pull request(s) to review the release.\"\"\"\n\n    github_token: str = ArgProxy(\n        '--github-token',\n        type=env_var,\n        default='GITHUB_TOKEN',\n        help='Github personal access token with repo scope',\n    )\n</code></pre>"},{"location":"cli/review_release/#options","title":"Options","text":""},{"location":"cli/review_release/#github_token","title":"<code>--github-token</code>","text":"<ul><li>default: <code>env.GITHUB_TOKEN</code></li></ul> <p>Github personal access token with repo scope</p>"},{"location":"cli/start_hotfix/","title":"m start_hotfix","text":"<p>Start the release process for a hotfix.</p> <p>A hotfix should always be done in the master branch.</p> <p>It may also require input from the developer to proceed with certain operations.</p> Source code in <code>m/cli/commands/start_hotfix.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Start the release process for a hotfix.\n\n    A hotfix should always be done in the master branch.\n\n    It may also require input from the developer to proceed with\n    certain operations.\n    \"\"\"\n\n    github_token: str = ArgProxy(\n        '--github-token',\n        default='GITHUB_TOKEN',\n        type=env_var,\n        help='Github personal access token with repo scope',\n    )\n</code></pre>"},{"location":"cli/start_hotfix/#options","title":"Options","text":""},{"location":"cli/start_hotfix/#github_token","title":"<code>--github-token</code>","text":"<ul><li>default: <code>env.GITHUB_TOKEN</code></li></ul> <p>Github personal access token with repo scope</p>"},{"location":"cli/start_release/","title":"m start_release","text":"<p>Start the release process.</p> <p>Depending on the workflow the <code>m</code> configuration is using we will be required to be working on the <code>master</code> or <code>develop</code> branch.</p> <p>It may also require input from the developer to proceed with certain operations.</p> Source code in <code>m/cli/commands/start_release.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Start the release process.\n\n    Depending on the workflow the `m` configuration is using we\n    will be required to be working on the `master` or `develop` branch.\n\n    It may also require input from the developer to proceed with\n    certain operations.\n    \"\"\"\n\n    github_token: str = ArgProxy(\n        '--github-token',\n        default='GITHUB_TOKEN',\n        type=env_var,\n        help='Github personal access token with repo scope',\n    )\n</code></pre>"},{"location":"cli/start_release/#options","title":"Options","text":""},{"location":"cli/start_release/#github_token","title":"<code>--github-token</code>","text":"<ul><li>default: <code>env.GITHUB_TOKEN</code></li></ul> <p>Github personal access token with repo scope</p>"},{"location":"cli/ci/assert_branch/","title":"m ci assert_branch","text":"<p>Fail command when working on a non valid branch for a release/hotfix.</p> <p>Used during a release setup or hotfix setup. We want to make sure that we are working on the correct branch depending on release type we want to make and the workflow that we are using.</p> Source code in <code>m/cli/commands/ci/assert_branch.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Fail command when working on a non valid branch for a release/hotfix.\n\n    Used during a release setup or hotfix setup. We want to make sure\n    that we are working on the correct branch depending on release type\n    we want to make and the workflow that we are using.\n    \"\"\"\n\n    type: str = ArgProxy(\n        '--type',\n        required=True,\n        choices=['release', 'hotfix'],\n        help='verification type',\n    )\n    m_dir: str = Arg(\n        help='m project directory',\n        required=True,\n        positional=True,\n    )\n</code></pre>"},{"location":"cli/ci/assert_branch/#options","title":"Options","text":""},{"location":"cli/ci/assert_branch/#type","title":"<code>--type</code>","text":"<ul><li>choices: <code>release</code>, <code>hotfix</code></li></ul> <p>verification type</p>"},{"location":"cli/ci/assert_branch/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/assert_branch/#m_dir","title":"<code>m_dir</code>","text":"<p>m project directory</p>"},{"location":"cli/ci/bump_version/","title":"m ci bump_version","text":"<p>Prompt user for the next valid semantic version.</p> Source code in <code>m/cli/commands/ci/bump_version.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Prompt user for the next valid semantic version.\"\"\"\n\n    type: str = ArgProxy(\n        '--type',\n        required=True,\n        choices=['release', 'hotfix'],\n        help='verification type',\n    )\n    version: str = Arg(\n        help='version to bump',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/ci/bump_version/#options","title":"Options","text":""},{"location":"cli/ci/bump_version/#type","title":"<code>--type</code>","text":"<ul><li>choices: <code>release</code>, <code>hotfix</code></li></ul> <p>verification type</p>"},{"location":"cli/ci/bump_version/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/bump_version/#version","title":"<code>version</code>","text":"<p>version to bump</p>"},{"location":"cli/ci/celt/","title":"m ci celt","text":"<p>Process a compiler or linter output to determine if the cli should stop.</p>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--examples","title":"Examples","text":"<pre><code>~$ m ci celt -t eslint -c @config.json &lt; &lt;(eslint [dir] -f json)\n\n~$ eslint [...options] &gt; tmp.json\n~$ m ci celt -t eslint @tmp.json -c '{\"allowedEslintRules\":{\"semi\":1}}'\n</code></pre> <p>Depending on the tool that is chosen the configuration should have an entry of the form <code>\"allowed[ToolName]Rules\"</code> or <code>\"ignored[ToolName]Rules\"</code>. Only the first letter of the tool should be capitalized to conform to the camel case style.</p> <p>The entry should define a map of rule ids to the number of allowed violations. In the case of <code>ignored[ToolName]Rules</code> we may define the rule id and assign an explanation as to why its being ignored.</p> <p>In the examples above we use <code>@config.json</code>. This means it will read the file <code>config.json</code>. You can use any file that you want. One option is to use eslintrc.json or create a brand new file called <code>allowed_errors.json</code>.</p>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--tools","title":"Tools","text":"<p>Each tool may provide have different outputs</p>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--eslint","title":"eslint","text":"<p>Should be called with the <code>-f json</code> option.</p> <pre><code>m ci celt -t eslint -c @config.json &lt; &lt;(eslint -f json [dir])\n</code></pre>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--pycodestyle","title":"pycodestyle","text":"<p>Should be called with the <code>--format=default</code> option.</p> <pre><code>m ci celt -t pycodestyle -c @config.json &lt; &lt;(pycodestyle --format=default [dir])\n</code></pre>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--flake8","title":"flake8","text":"<p>Expects default output.</p> <pre><code>m ci celt -t flake8 -c @config.json &lt; &lt;(flake8 [dir])\n</code></pre>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--pylint","title":"pylint","text":"<p>Should be called with the <code>-f json</code> option.</p> <pre><code>m ci celt -t pylint -c @config.json &lt; &lt;(pylint -f json --rcfile=[file] [dir])\n</code></pre>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--typescript","title":"typescript","text":"<p>Should be called with the <code>--pretty false</code> option.</p> <pre><code>m ci celt -t typescript -c @config.json &lt; &lt;(tsc --pretty false)\n</code></pre>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--ruff","title":"ruff","text":"<p>Should be called with the <code>--format json</code> option.</p> <pre><code>m ci celt -t ruff -c @config.json &lt; &lt;(ruff check --format json [dir])\n</code></pre> Source code in <code>m/cli/commands/ci/celt.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Process a compiler or linter output to determine if the cli should stop.\n\n    ## Examples\n\n    ```shell\n    ~$ m ci celt -t eslint -c @config.json &lt; &lt;(eslint [dir] -f json)\n\n    ~$ eslint [...options] &gt; tmp.json\n    ~$ m ci celt -t eslint @tmp.json -c '{\"allowedEslintRules\":{\"semi\":1}}'\n    ```\n\n    Depending on the tool that is chosen the configuration should have an\n    entry of the form `\"allowed[ToolName]Rules\"` or `\"ignored[ToolName]Rules\"`.\n    Only the first letter of the tool should be capitalized to conform to\n    the camel case style.\n\n    The entry should define a map of rule ids to the number of allowed\n    violations. In the case of `ignored[ToolName]Rules` we may define\n    the rule id and assign an explanation as to why its being ignored.\n\n    In the examples above we use `@config.json`. This means it\n    will read the file `config.json`. You can use any file that you want.\n    One option is to use eslintrc.json or create a brand new file called\n    `allowed_errors.json`.\n\n    ## Tools\n\n    Each tool may provide have different outputs\n\n    ### eslint\n\n    Should be called with the `-f json` option.\n\n    ```bash\n    m ci celt -t eslint -c @config.json &lt; &lt;(eslint -f json [dir])\n    ```\n\n    ### pycodestyle\n\n    Should be called with the `--format=default` option.\n\n    ```bash\n    m ci celt -t pycodestyle -c @config.json &lt; &lt;(pycodestyle --format=default [dir])\n    ```\n\n    ### flake8\n\n    Expects default output.\n\n    ```bash\n    m ci celt -t flake8 -c @config.json &lt; &lt;(flake8 [dir])\n    ```\n\n    ### pylint\n\n    Should be called with the `-f json` option.\n\n    ```bash\n    m ci celt -t pylint -c @config.json &lt; &lt;(pylint -f json --rcfile=[file] [dir])\n    ```\n\n    ### typescript\n\n    Should be called with the `--pretty false` option.\n\n    ```bash\n    m ci celt -t typescript -c @config.json &lt; &lt;(tsc --pretty false)\n    ```\n\n    ### ruff\n\n    Should be called with the `--format json` option.\n\n    ```bash\n    m ci celt -t ruff -c @config.json &lt; &lt;(ruff check --format json [dir])\n    ```\n    \"\"\"\n\n    payload: str = Arg(\n        default='@-',\n        help=\"\"\"\\\n            Output of a compiler or linter. A file may be specified by prefixing\n            a filename with `@`. To read from stdin use `@-`.\n\n            Summary: `@-` (stdin), `@filename` (file), `string`.\n        \"\"\",\n        validator=validate_payload,\n        positional=True,\n    )\n\n    tool: str = Arg(\n        help='name of a supported compiler/linter',\n        required=True,\n        aliases=['t', 'tool'],\n    )\n\n    config: Any = Arg(\n        default='{}',  # noqa: P103 - json object, not attempting to format\n        aliases=['c', 'config'],\n        help='config data: @filename (file), string',\n        validator=validate_json_payload,\n    )\n\n    max_lines: int = Arg(\n        default=5,\n        aliases=['m', 'max_lines'],\n        help='max number of error lines to print, use -1 for all',\n    )\n\n    file_regex: str | None = Arg(\n        aliases=['r', 'file_regex'],\n        help='regex expression to filter files',\n    )\n\n    file_prefix: str | None = Arg(\n        aliases=['p', 'file_prefix'],\n        help=\"replace file prefix with 'old1|old2:new'\",\n    )\n\n    ignore_error_allowance: bool = Arg(\n        default=False,\n        aliases=['i', 'ignore_error_allowance'],\n        help='set every error allowance to 0',\n    )\n\n    stats_only: bool = Arg(\n        default=False,\n        aliases=['s', 'stats_only'],\n        help='display a dictionary with current total violations',\n    )\n\n    full_message: bool = Arg(\n        default=False,\n        aliases=['f', 'full_message'],\n        help='display the full error message',\n    )\n\n    traceback: bool = Arg(\n        default=False,\n        help='display the exception traceback if available',\n    )\n</code></pre>"},{"location":"cli/ci/celt/#required-arguments","title":"Required arguments","text":""},{"location":"cli/ci/celt/#tool","title":"<code>-t</code>, <code>--tool</code>","text":"<p>name of a supported compiler/linter</p>"},{"location":"cli/ci/celt/#options","title":"Options","text":""},{"location":"cli/ci/celt/#config","title":"<code>-c</code>, <code>--config</code>","text":"<ul><li>default: <code>'{}'</code></li></ul> <p>config data: @filename (file), string</p>"},{"location":"cli/ci/celt/#max_lines","title":"<code>-m</code>, <code>--max-lines</code>","text":"<ul><li>default: <code>5</code></li></ul> <p>max number of error lines to print, use -1 for all</p>"},{"location":"cli/ci/celt/#file_regex","title":"<code>-r</code>, <code>--file-regex</code>","text":"<p>regex expression to filter files</p>"},{"location":"cli/ci/celt/#file_prefix","title":"<code>-p</code>, <code>--file-prefix</code>","text":"<p>replace file prefix with 'old1|old2:new'</p>"},{"location":"cli/ci/celt/#ignore_error_allowance","title":"<code>-i</code>, <code>--ignore-error-allowance</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>set every error allowance to 0</p>"},{"location":"cli/ci/celt/#stats_only","title":"<code>-s</code>, <code>--stats-only</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>display a dictionary with current total violations</p>"},{"location":"cli/ci/celt/#full_message","title":"<code>-f</code>, <code>--full-message</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>display the full error message</p>"},{"location":"cli/ci/celt/#traceback","title":"<code>--traceback</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>display the exception traceback if available</p>"},{"location":"cli/ci/celt/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/celt/#payload","title":"<code>payload</code>","text":"<ul><li>default: <code>'@-'</code></li></ul> <p>Output of a compiler or linter. A file may be specified by prefixing a filename with <code>@</code>. To read from stdin use <code>@-</code>.</p> <p>Summary: <code>@-</code> (stdin), <code>@filename</code> (file), <code>string</code>.</p>"},{"location":"cli/ci/env/","title":"m ci env","text":"<p>Create the [m_dir]/.m/env.list file.</p> <p>With the <code>bashrc</code> option it will print a bashrc snippet and no file will be created. Note that boolean values are lowercased in the snippet. This eventually be the case for generated env.list file.</p> Source code in <code>m/cli/commands/ci/env.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Create the [m_dir]/.m/env.list file.\n\n    With the `bashrc` option it will print a bashrc snippet and no file will\n    be created. Note that boolean values are lowercased in the snippet. This\n    eventually be the case for generated env.list file.\n    \"\"\"\n\n    pretty: bool = Arg(\n        default=False,\n        help='format json payload with indentation',\n    )\n    yaml: bool = Arg(\n        default=False,\n        help='use yaml format',\n    )\n    m_dir: str = Arg(\n        default='m',\n        help='m project directory',\n        positional=True,\n    )\n    bashrc: bool = Arg(\n        default=False,\n        help='print bashrc snippet',\n    )\n</code></pre>"},{"location":"cli/ci/env/#options","title":"Options","text":""},{"location":"cli/ci/env/#pretty","title":"<code>--pretty</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>format json payload with indentation</p>"},{"location":"cli/ci/env/#yaml","title":"<code>--yaml</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>use yaml format</p>"},{"location":"cli/ci/env/#bashrc","title":"<code>--bashrc</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>print bashrc snippet</p>"},{"location":"cli/ci/env/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/env/#m_dir","title":"<code>m_dir</code>","text":"<ul><li>default: <code>'m'</code></li></ul> <p>m project directory</p>"},{"location":"cli/ci/npm_tag/","title":"m ci npm_tag","text":"<p>Display an npm tag assigned to given version.</p> <p>examples::</p> <pre><code>~$ m ci npm_tag 0.0.0-develop.b123\ndevelop\n\n~$ m ci npm_tag 0.0.0-pr1234.b123\npr1234\n\n~$ m ci npm_tag 2.0.1-rc1234.b123\nnext\n\n~$ m ci npm_tag 2.0.1\nlatest\n</code></pre> Source code in <code>m/cli/commands/ci/npm_tag.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Display an npm tag assigned to given version.\n\n    examples::\n\n        ~$ m ci npm_tag 0.0.0-develop.b123\n        develop\n\n        ~$ m ci npm_tag 0.0.0-pr1234.b123\n        pr1234\n\n        ~$ m ci npm_tag 2.0.1-rc1234.b123\n        next\n\n        ~$ m ci npm_tag 2.0.1\n        latest\n    \"\"\"\n\n    npm_tag: str = Arg(\n        help='npm package version',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/ci/npm_tag/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/npm_tag/#npm_tag","title":"<code>npm_tag</code>","text":"<p>npm package version</p>"},{"location":"cli/ci/release_setup/","title":"m ci release_setup","text":"<p>Update the config and changelog files.</p> Source code in <code>m/cli/commands/ci/release_setup.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Update the config and changelog files.\"\"\"\n\n    changelog: str = Arg(\n        default='CHANGELOG.md',\n        help='CHANGELOG filename',\n    )\n    m_dir: str = Arg(\n        help='m project directory',\n        positional=True,\n        required=True,\n    )\n    new_ver: str = Arg(\n        help='the new version',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/ci/release_setup/#options","title":"Options","text":""},{"location":"cli/ci/release_setup/#changelog","title":"<code>--changelog</code>","text":"<ul><li>default: <code>'CHANGELOG.md'</code></li></ul> <p>CHANGELOG filename</p>"},{"location":"cli/ci/release_setup/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/release_setup/#m_dir","title":"<code>m_dir</code>","text":"<p>m project directory</p>"},{"location":"cli/ci/release_setup/#new_ver","title":"<code>new_ver</code>","text":"<p>the new version</p>"},{"location":"cli/devcontainer/bashrc/","title":"m devcontainer bashrc","text":"<p>Print a bash snippet of setup instructions.</p> <p>This snippet can be used in a <code>.bashrc</code> file to setup the environment. It will also provide aliases that call other <code>m</code> commands to help facilitate the development in a devcontainer workflow.</p> Source code in <code>m/cli/commands/devcontainer/bashrc.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Print a bash snippet of setup instructions.\n\n    This snippet can be used in a `.bashrc` file to setup the environment.\n    It will also provide aliases that call other `m` commands to help\n    facilitate the development in a devcontainer workflow.\n\n    \"\"\"\n\n    section: str | None = ArgProxy(\n        '--section',\n        choices=['env', 'devex', 'venv'],\n        help='section to print out',\n    )\n</code></pre>"},{"location":"cli/devcontainer/bashrc/#options","title":"Options","text":""},{"location":"cli/devcontainer/bashrc/#section","title":"<code>--section</code>","text":"<ul><li>choices: <code>env</code>, <code>devex</code>, <code>venv</code></li></ul> <p>section to print out</p>"},{"location":"cli/devcontainer/greet/","title":"m devcontainer greet","text":"<p>Add a log message providing basic information about the devcontainer.</p> Source code in <code>m/cli/commands/devcontainer/greet.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Add a log message providing basic information about the devcontainer.\"\"\"\n\n    img_name: str = Arg(help='name of the docker image', required=True)\n    img_version: str = Arg(help='version of the docker image', required=True)\n    changelog_url: str | None = Arg(default=None, help='url to the changelog')\n</code></pre>"},{"location":"cli/devcontainer/greet/#required-arguments","title":"Required arguments","text":""},{"location":"cli/devcontainer/greet/#img_name","title":"<code>--img-name</code>","text":"<p>name of the docker image</p>"},{"location":"cli/devcontainer/greet/#img_version","title":"<code>--img-version</code>","text":"<p>version of the docker image</p>"},{"location":"cli/devcontainer/greet/#options","title":"Options","text":""},{"location":"cli/devcontainer/greet/#changelog_url","title":"<code>--changelog-url</code>","text":"<ul><li>default: <code>None</code></li></ul> <p>url to the changelog</p>"},{"location":"cli/devcontainer/pnpm/","title":"m devcontainer pnpm","text":"<p>Run pnpm in the devcontainer.</p> <p>This command is meant to be used as an alias for <code>pnpm</code> in a devcontainer. If you want view the help for the <code>pnpm</code> command you can run::</p> <pre><code>command pnpm --help\n</code></pre> <p>Depending on the pnpm command that we want to run, this command will change the working directory to the mounted volume and execute the pnpm command.</p> <p>Currently the main commands that will be executed in the mounted volume are</p> <ul> <li>add</li> <li>install</li> <li>remove</li> <li>uninstall</li> </ul> <p>If you need to run other commands in the mounted volume you can use the <code>--force-cd</code> flag.</p> Source code in <code>m/cli/commands/devcontainer/pnpm.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Run pnpm in the devcontainer.\n\n    This command is meant to be used as an alias for `pnpm` in a devcontainer.\n    If you want view the help for the `pnpm` command you can run::\n\n        command pnpm --help\n\n    Depending on the pnpm command that we want to run, this command will change\n    the working directory to the mounted volume and execute the pnpm command.\n\n    Currently the main commands that will be executed in the mounted volume\n    are\n\n    - add\n    - install\n    - remove\n    - uninstall\n\n    If you need to run other commands in the mounted volume you can use the\n    `--force-cd` flag.\n    \"\"\"\n\n    force_cd: bool = Arg(default=False, help='force `cd` to the mounted volume')\n\n    pnpm_args: list[str] = RemainderArgs(help='arguments to pass to pnpm')\n</code></pre>"},{"location":"cli/devcontainer/pnpm/#options","title":"Options","text":""},{"location":"cli/devcontainer/pnpm/#force_cd","title":"<code>--force-cd</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>force <code>cd</code> to the mounted volume</p>"},{"location":"cli/devcontainer/pnpm/#pnpm_args","title":"<code>pnpm_args</code>","text":"<ul><li>default: <code>[]</code></li></ul> <p>arguments to pass to pnpm</p>"},{"location":"cli/devcontainer/pnpm_setup/","title":"m devcontainer pnpm_setup","text":"<p>Setup pnpm in the devcontainer.</p> <p>This command is meant run from inside the devcontainer. It will create several symbolic links so that the pnpm data may be stored in a volume and thus be able to be shared with other devcontainers.</p> Source code in <code>m/cli/commands/devcontainer/pnpm_setup.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Setup pnpm in the devcontainer.\n\n    This command is meant run from inside the devcontainer. It will\n    create several symbolic links so that the pnpm data may be stored in a\n    volume and thus be able to be shared with other devcontainers.\n    \"\"\"\n\n    work_dir: str = Arg(\n        help='the work directory containing package.json',\n        positional=True,\n        required=True,\n    )\n\n    pnpm_dir: str = Arg(\n        help='the directory where pnpm data will be stored',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/devcontainer/pnpm_setup/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/devcontainer/pnpm_setup/#work_dir","title":"<code>work_dir</code>","text":"<p>the work directory containing package.json</p>"},{"location":"cli/devcontainer/pnpm_setup/#pnpm_dir","title":"<code>pnpm_dir</code>","text":"<p>the directory where pnpm data will be stored</p>"},{"location":"cli/devcontainer/prompter/","title":"m devcontainer prompter","text":"<p>Command line prompter.</p> <p>The goal is to display useful git information in the shell prompt.</p> Source code in <code>m/cli/commands/devcontainer/prompter.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Command line prompter.\n\n    The goal is to display useful git information in the shell prompt.\n    \"\"\"\n</code></pre>"},{"location":"cli/devcontainer/require_env_vars/","title":"m devcontainer require_env_vars","text":"<p>Verify that the required environment variables are set.</p> <p>Exists with non-zero exit code if any of the required environment variables are not set.</p> Source code in <code>m/cli/commands/devcontainer/require_env_vars.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Verify that the required environment variables are set.\n\n    Exists with non-zero exit code if any of the required environment variables\n    are not set.\n    \"\"\"\n\n    env_vars: list[str] = Arg(\n        help='environment variables to check',\n        nargs='+',\n        positional=True,\n    )\n</code></pre>"},{"location":"cli/devcontainer/require_env_vars/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/devcontainer/require_env_vars/#env_vars","title":"<code>env_vars</code>","text":"<p>environment variables to check</p>"},{"location":"cli/git/branch/","title":"m git branch","text":"<p>Display the current git branch name.</p> <p>example::</p> <pre><code>$ m git branch\nmaster\n</code></pre> Source code in <code>m/cli/commands/git/branch.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Display the current git branch name.\n\n    example::\n\n        $ m git branch\n        master\n    \"\"\"\n</code></pre>"},{"location":"cli/git/current_sha/","title":"m git current_sha","text":"<p>Display the current commit sha.</p> <p>example::</p> <pre><code>$ m git current_sha\n74075a3ea5c9252a0f2b9fd6b095567b3b9b4028\n</code></pre> Source code in <code>m/cli/commands/git/current_sha.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Display the current commit sha.\n\n    example::\n\n        $ m git current_sha\n        74075a3ea5c9252a0f2b9fd6b095567b3b9b4028\n    \"\"\"\n</code></pre>"},{"location":"cli/git/first_sha/","title":"m git first_sha","text":"<p>Display the very first commit sha in the repository.</p> <p>example::</p> <pre><code>$ m git first_sha\nbf286e270e13c75dfed289a3921289092477c058\n</code></pre> Source code in <code>m/cli/commands/git/first_sha.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Display the very first commit sha in the repository.\n\n    example::\n\n        $ m git first_sha\n        bf286e270e13c75dfed289a3921289092477c058\n    \"\"\"\n</code></pre>"},{"location":"cli/git/status/","title":"m git status","text":"<p>Display a single word representing the current git status.</p> <p>example::</p> <pre><code>$ m git status\nclean\n</code></pre> <p>statuses::</p> <pre><code>unknown\nuntracked\nclean\nahead\nbehind\nstaged\ndirty\ndiverged\n?\n</code></pre> <p>If you want to check for stashed changes, use the <code>--check-stashed</code> flag.</p> Source code in <code>m/cli/commands/git/status.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Display a single word representing the current git status.\n\n    example::\n\n        $ m git status\n        clean\n\n    statuses::\n\n        unknown\n        untracked\n        clean\n        ahead\n        behind\n        staged\n        dirty\n        diverged\n        ?\n\n    If you want to check for stashed changes, use the `--check-stashed` flag.\n    \"\"\"\n\n    check_stashed: bool = Arg(\n        default=False,\n        help='check if there are any stashed changes',\n    )\n</code></pre>"},{"location":"cli/git/status/#options","title":"Options","text":""},{"location":"cli/git/status/#check_stashed","title":"<code>--check-stashed</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>check if there are any stashed changes</p>"},{"location":"cli/git/tag_release/","title":"m git tag_release","text":"<p>Supplement to <code>m github release</code>.</p> <p>This command needs the <code>git</code> cli and it is meant to be run after <code>m github release</code> to create a major and minor release tags.</p> <p>example::</p> <pre><code>$ m git tag_release --version 1.2.3\n</code></pre> <p>It will create or update the following tags::</p> <pre><code>-v1\n-v1.2\n</code></pre> <p>Note that the tags may be moved with each release to point to the latest release. This is done by deleting the tag and creating it again.</p> Source code in <code>m/cli/commands/git/tag_release.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Supplement to `m github release`.\n\n    This command needs the `git` cli and it is meant to be run after\n    `m github release` to create a major and minor release tags.\n\n\n    example::\n\n        $ m git tag_release --version 1.2.3\n\n\n    It will create or update the following tags::\n\n        -v1\n        -v1.2\n\n    Note that the tags may be moved with each release to point to the latest\n    release. This is done by deleting the tag and creating it again.\n    \"\"\"\n\n    version: str = Arg(\n        help='version to create tags from',\n        required=True,\n    )\n    sha: str = Arg(\n        default='',\n        help='sha to tag',\n    )\n    major_only: bool = Arg(\n        default=False,\n        help='only create major tag',\n    )\n</code></pre>"},{"location":"cli/git/tag_release/#required-arguments","title":"Required arguments","text":""},{"location":"cli/git/tag_release/#version","title":"<code>--version</code>","text":"<p>version to create tags from</p>"},{"location":"cli/git/tag_release/#options","title":"Options","text":""},{"location":"cli/git/tag_release/#sha","title":"<code>--sha</code>","text":"<ul><li>default: <code>''</code></li></ul> <p>sha to tag</p>"},{"location":"cli/git/tag_release/#major_only","title":"<code>--major-only</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>only create major tag</p>"},{"location":"cli/github/actions/","title":"m github actions","text":"<p>Create the actions metadata as described by given python script.</p> <p>When creating actions we need to have the <code>python_file</code> be at the root of a python project. This is because when we run the action we will set the path to the directory containing the file.</p> <p>By default it has been set to <code>src/actions.py</code> since this is a common case for python projects.</p> <p>The <code>actions.py</code> can be name anything but it must contain a variable named <code>actions</code>. This variable must be an instance or list of m.github.actions.Action.</p> Source code in <code>m/cli/commands/github/actions.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Create the actions metadata as described by given python script.\n\n    When creating actions we need to have the `python_file` be at the root\n    of a python project. This is because when we run the action we will set\n    the path to the directory containing the file.\n\n    By default it has been set to `src/actions.py` since this is a common case\n    for python projects.\n\n    The `actions.py` can be name anything but it must contain a variable named\n    `actions`. This variable must be an instance or list of\n    [m.github.actions.Action][].\n    \"\"\"\n\n    python_file: str = Arg(\n        default='src/actions.py',\n        help='Python script containing the `actions` variable.',\n        positional=True,\n        validator=validate_file_exists,\n    )\n\n    check: bool = Arg(\n        default=False,\n        help='Check if generated files are up to date and skip writing them.',\n    )\n\n    show_traceback: bool = Arg(\n        default=False,\n        help='Display traceback information in case of an error.',\n    )\n</code></pre>"},{"location":"cli/github/actions/#options","title":"Options","text":""},{"location":"cli/github/actions/#check","title":"<code>--check</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>Check if generated files are up to date and skip writing them.</p>"},{"location":"cli/github/actions/#show_traceback","title":"<code>--show-traceback</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>Display traceback information in case of an error.</p>"},{"location":"cli/github/actions/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/github/actions/#python_file","title":"<code>python_file</code>","text":"<ul><li>default: <code>'src/actions.py'</code></li></ul> <p>Python script containing the <code>actions</code> variable.</p>"},{"location":"cli/github/branch_prs/","title":"m github branch_prs","text":"<p>Retrieve pull requests associated with a branch.</p> <p>example::</p> <pre><code>$ m github branch_prs --owner jmlopez-rod --repo m release/0.18.0\n</code></pre> <p></p> Source code in <code>m/cli/commands/github/branch_prs.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Retrieve pull requests associated with a branch.\n\n    example::\n\n        $ m github branch_prs --owner jmlopez-rod --repo m release/0.18.0\n\n    ![preview](../../assets/branch_prs.svg)\n    \"\"\"\n\n    pretty: bool = Arg(\n        default=False,\n        help='format json payload with indentation',\n    )\n    yaml: bool = Arg(\n        default=False,\n        help='use yaml format',\n    )\n    owner: str = Arg(\n        default='GITHUB_REPOSITORY_OWNER',\n        validator=env_var,\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    branch: str = Arg(\n        help='branch name',\n        required=True,\n        positional=True,\n    )\n</code></pre>"},{"location":"cli/github/branch_prs/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/branch_prs/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/branch_prs/#options","title":"Options","text":""},{"location":"cli/github/branch_prs/#pretty","title":"<code>--pretty</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>format json payload with indentation</p>"},{"location":"cli/github/branch_prs/#yaml","title":"<code>--yaml</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>use yaml format</p>"},{"location":"cli/github/branch_prs/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>env.GITHUB_REPOSITORY_OWNER</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/branch_prs/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/github/branch_prs/#branch","title":"<code>branch</code>","text":"<p>branch name</p>"},{"location":"cli/github/build_sha/","title":"m github build_sha","text":"<p>Provide the build sha.</p> <p>Given the GITHUB_SHA (a merge commit it fetches the sha of the actual commit we thought we were building.</p> <p>example::</p> <pre><code>$ m github build_sha \\\n    --owner jmlopez-rod \\\n    --repo m \\\n    --sha 6bf3a8095891c551043877b922050d5b01d20284\nfa6a600729ffbe1dfd7fece76ef4566e45fbfe40\n</code></pre> <p>The sha can be obtained in Github by looking at the output of the checkout action.</p> <p>The <code>owner</code> option defaults to the value of the environment variable <code>GITHUB_REPOSITORY_OWNER</code>.</p> Source code in <code>m/cli/commands/github/build_sha.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Provide the build sha.\n\n    Given the GITHUB_SHA (a merge commit it fetches the sha of the actual\n    commit we thought we were building.\n\n    example::\n\n        $ m github build_sha \\\n            --owner jmlopez-rod \\\n            --repo m \\\n            --sha 6bf3a8095891c551043877b922050d5b01d20284\n        fa6a600729ffbe1dfd7fece76ef4566e45fbfe40\n\n    The sha can be obtained in Github by looking at the output of the\n    checkout action.\n\n    The `owner` option defaults to the value of the environment variable\n    `GITHUB_REPOSITORY_OWNER`.\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    sha: str = Arg(\n        help='commit sha',\n        required=True,\n    )\n</code></pre>"},{"location":"cli/github/build_sha/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/build_sha/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/build_sha/#sha","title":"<code>--sha</code>","text":"<p>commit sha</p>"},{"location":"cli/github/build_sha/#options","title":"Options","text":""},{"location":"cli/github/build_sha/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/ci/","title":"m github ci","text":"<p>Retrieve the information required for continuous integration.</p> <p>example::</p> <pre><code>$ m github ci \\\n    --owner jmlopez-rod \\\n    --repo pysync \\\n    --sha 4538b2a2556efcbdfc1e7df80c4f71ade45f3958 \\\n    --pr 1 \\\n    --include-release | m json\n{\n\"commit\": {\n    \"associatedPullRequests\": {\n    \"nodes\": [\n        {\n        \"author\": {\n            \"login\": \"jmlopez-rod\",\n            \"avatarUrl\": \"https://avatars.githubusercontent.com/...\",\n            \"email\": \"\"\n        },\n...\n</code></pre> <p>NOTE: Use the --merge-commit flag if you are providing a sha from github actions.</p> Source code in <code>m/cli/commands/github/ci.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Retrieve the information required for continuous integration.\n\n    example::\n\n        $ m github ci \\\n            --owner jmlopez-rod \\\n            --repo pysync \\\n            --sha 4538b2a2556efcbdfc1e7df80c4f71ade45f3958 \\\n            --pr 1 \\\n            --include-release | m json\n        {\n        \"commit\": {\n            \"associatedPullRequests\": {\n            \"nodes\": [\n                {\n                \"author\": {\n                    \"login\": \"jmlopez-rod\",\n                    \"avatarUrl\": \"https://avatars.githubusercontent.com/...\",\n                    \"email\": \"\"\n                },\n        ...\n\n    NOTE: Use the --merge-commit flag if you are providing a sha from\n    github actions.\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    sha: str = Arg(\n        help='commit sha',\n        required=True,\n    )\n    pr: int | None = Arg(help='pull request number')\n    file_count: int = Arg(\n        default=10,\n        help='max number of files to retrieve',\n    )\n    include_release: bool = Arg(\n        default=False,\n        help='include the last release information',\n    )\n    merge_commit: bool = Arg(\n        default=False,\n        help='set if the sha is a merge commit sha (from github)',\n    )\n</code></pre>"},{"location":"cli/github/ci/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/ci/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/ci/#sha","title":"<code>--sha</code>","text":"<p>commit sha</p>"},{"location":"cli/github/ci/#options","title":"Options","text":""},{"location":"cli/github/ci/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/ci/#pr","title":"<code>--pr</code>","text":"<p>pull request number</p>"},{"location":"cli/github/ci/#file_count","title":"<code>--file-count</code>","text":"<ul><li>default: <code>10</code></li></ul> <p>max number of files to retrieve</p>"},{"location":"cli/github/ci/#include_release","title":"<code>--include-release</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>include the last release information</p>"},{"location":"cli/github/ci/#merge_commit","title":"<code>--merge-commit</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>set if the sha is a merge commit sha (from github)</p>"},{"location":"cli/github/create_pr/","title":"m github create_pr","text":"<p>Create a pull request.</p> <p>https://docs.github.com/en/rest/reference/pulls#create-a-pull-request</p> <p>example::</p> <pre><code>$ m github create_pr \\\n    --owner jmlopez-rod \\\n    --repo repo \\\n    --head feature_branch \\\n    --base master \\\n    --title 'PR Title' \\\n    @file_with_pr_body | m json\n</code></pre> Source code in <code>m/cli/commands/github/create_pr.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Create a pull request.\n\n    https://docs.github.com/en/rest/reference/pulls#create-a-pull-request\n\n    example::\n\n        $ m github create_pr \\\n            --owner jmlopez-rod \\\n            --repo repo \\\n            --head feature_branch \\\n            --base master \\\n            --title 'PR Title' \\\n            @file_with_pr_body | m json\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    head: str = Arg(\n        help='name of the branch where the changes are implemented',\n        required=True,\n    )\n    base: str = Arg(\n        help='name of the branch you want the changes pulled into',\n        required=True,\n    )\n    title: str = Arg(\n        help='pull request title',\n        required=True,\n    )\n    body: str = Arg(\n        default='@-',\n        help='data: @- (stdin), @filename (file), string',\n        validator=validate_payload,\n        positional=True,\n    )\n</code></pre>"},{"location":"cli/github/create_pr/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/create_pr/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/create_pr/#head","title":"<code>--head</code>","text":"<p>name of the branch where the changes are implemented</p>"},{"location":"cli/github/create_pr/#base","title":"<code>--base</code>","text":"<p>name of the branch you want the changes pulled into</p>"},{"location":"cli/github/create_pr/#title","title":"<code>--title</code>","text":"<p>pull request title</p>"},{"location":"cli/github/create_pr/#options","title":"Options","text":""},{"location":"cli/github/create_pr/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/create_pr/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/github/create_pr/#body","title":"<code>body</code>","text":"<ul><li>default: <code>'@-'</code></li></ul> <p>data: @- (stdin), @filename (file), string</p>"},{"location":"cli/github/latest_release/","title":"m github latest_release","text":"<p>Retrieve the latest release.</p> <p>example::</p> <pre><code>$ m github latest_release --owner microsoft --repo typescript\n</code></pre> Source code in <code>m/cli/commands/github/latest_release.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Retrieve the latest release.\n\n    example::\n\n        $ m github latest_release --owner microsoft --repo typescript\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n</code></pre>"},{"location":"cli/github/latest_release/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/latest_release/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/latest_release/#options","title":"Options","text":""},{"location":"cli/github/latest_release/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/merge_pr/","title":"m github merge_pr","text":"<p>Merge a pull request.</p> <p>https://docs.github.com/en/rest/reference/pulls#merge-a-pull-request</p> <p>example::</p> <pre><code>$ m github merge_pr \\\\\n    --owner owner \\\\\n    --repo repo \\\\\n    --commit-title 'commit_title' \\\\\n    99\n</code></pre> Source code in <code>m/cli/commands/github/merge_pr.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Merge a pull request.\n\n    https://docs.github.com/en/rest/reference/pulls#merge-a-pull-request\n\n    example::\n\n        $ m github merge_pr \\\\\n            --owner owner \\\\\n            --repo repo \\\\\n            --commit-title 'commit_title' \\\\\n            99\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    commit_title: str | None = Arg(\n        help='commit title',\n    )\n    pr: int = Arg(\n        help='the pr number',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/github/merge_pr/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/merge_pr/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/merge_pr/#options","title":"Options","text":""},{"location":"cli/github/merge_pr/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/merge_pr/#commit_title","title":"<code>--commit-title</code>","text":"<p>commit title</p>"},{"location":"cli/github/merge_pr/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/github/merge_pr/#pr","title":"<code>pr</code>","text":"<p>the pr number</p>"},{"location":"cli/github/pr/","title":"m github pr","text":"<p>Retrieve a pull request information.</p> <p>example::</p> <pre><code>$ m github pr --owner microsoft --repo typescript 44710 | m json\n{\n    \"headRefName\": \"ReduceExceptions\",\n    \"headRefOid\": \"d9ae52cf49732a2d45b6cb7f4069205c88af39eb\",\n    \"baseRefName\": \"main\",\n    \"baseRefOid\": \"6452cfbad0afcc6d09b75e0a1e32da1d07e0b7ca\",\n    \"title\": \"Reduce exceptions\",\n    \"body\": \"...\n</code></pre> <p>Or use the <code>--pretty</code> option to avoid piping.</p> Source code in <code>m/cli/commands/github/pr.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Retrieve a pull request information.\n\n    example::\n\n        $ m github pr --owner microsoft --repo typescript 44710 | m json\n        {\n            \"headRefName\": \"ReduceExceptions\",\n            \"headRefOid\": \"d9ae52cf49732a2d45b6cb7f4069205c88af39eb\",\n            \"baseRefName\": \"main\",\n            \"baseRefOid\": \"6452cfbad0afcc6d09b75e0a1e32da1d07e0b7ca\",\n            \"title\": \"Reduce exceptions\",\n            \"body\": \"...\n\n    Or use the `--pretty` option to avoid piping.\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    files: int = Arg(\n        default=10,\n        help='max number of files to retrieve',\n    )\n    pretty: bool = Arg(\n        default=False,\n        help='format json payload with indentation',\n    )\n    yaml: bool = Arg(\n        default=False,\n        help='use yaml format',\n    )\n    pr_number: int = Arg(\n        help='the pr number',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/github/pr/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/pr/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/pr/#options","title":"Options","text":""},{"location":"cli/github/pr/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/pr/#files","title":"<code>--files</code>","text":"<ul><li>default: <code>10</code></li></ul> <p>max number of files to retrieve</p>"},{"location":"cli/github/pr/#pretty","title":"<code>--pretty</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>format json payload with indentation</p>"},{"location":"cli/github/pr/#yaml","title":"<code>--yaml</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>use yaml format</p>"},{"location":"cli/github/pr/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/github/pr/#pr_number","title":"<code>pr_number</code>","text":"<p>the pr number</p>"},{"location":"cli/github/release/","title":"m github release","text":"<p>Create a release in Github.</p> <p>https://docs.github.com/en/rest/reference/repos#create-a-release</p> <p>example::</p> <pre><code>$ m github release \\\n    --owner jmlopez-rod \\\n    --repo pysync \\\n    --version 1.0.0\n</code></pre> <p>The <code>owner</code> option defaults to the value of the environment variable <code>GITHUB_REPOSITORY_OWNER</code>.</p> Source code in <code>m/cli/commands/github/release.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Create a release in Github.\n\n    https://docs.github.com/en/rest/reference/repos#create-a-release\n\n    example::\n\n        $ m github release \\\n            --owner jmlopez-rod \\\n            --repo pysync \\\n            --version 1.0.0\n\n    The `owner` option defaults to the value of the environment variable\n    `GITHUB_REPOSITORY_OWNER`.\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    version: str = Arg(\n        help='version to release',\n        required=True,\n    )\n    branch: str | None = Arg(\n        help='The branch where the git tag will be created',\n    )\n</code></pre>"},{"location":"cli/github/release/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/release/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/release/#version","title":"<code>--version</code>","text":"<p>version to release</p>"},{"location":"cli/github/release/#options","title":"Options","text":""},{"location":"cli/github/release/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/release/#branch","title":"<code>--branch</code>","text":"<p>The branch where the git tag will be created</p>"},{"location":"cli/github/status/","title":"m github status","text":"<p>Create a commit status.</p> <ul> <li>https://docs.github.com/en/rest/reference/repos#create-a-commit-status</li> </ul> <p>example::</p> <pre><code>$ m github status \\\n    --owner jmlopez-rod \\\n    --repo pysync \\\n    --sha [sha] \\\n    --context github-check \\\n    --state pending \\\n    --description 'running checks'\n</code></pre> <p>The <code>owner</code> option defaults to the value of the environment variable <code>GITHUB_REPOSITORY_OWNER</code>.</p> Source code in <code>m/cli/commands/github/status.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Create a commit status.\n\n    - https://docs.github.com/en/rest/reference/repos#create-a-commit-status\n\n    example::\n\n        $ m github status \\\n            --owner jmlopez-rod \\\n            --repo pysync \\\n            --sha [sha] \\\n            --context github-check \\\n            --state pending \\\n            --description 'running checks'\n\n    The `owner` option defaults to the value of the environment variable\n    `GITHUB_REPOSITORY_OWNER`.\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    sha: str = Arg(\n        help='commit sha',\n        required=True,\n    )\n    context: str = Arg(\n        help='unique identifier for the status (a name?)',\n        required=True,\n    )\n    state: str = ArgProxy(\n        '--state',\n        required=True,\n        choices=['error', 'failure', 'pending', 'success'],\n        help='the state of the status',\n    )\n    description: str = Arg(\n        help='a short description of the status',\n        required=True,\n    )\n    url: str | None = Arg(\n        help='URL to associate with this status',\n    )\n</code></pre>"},{"location":"cli/github/status/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/status/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/status/#sha","title":"<code>--sha</code>","text":"<p>commit sha</p>"},{"location":"cli/github/status/#context","title":"<code>--context</code>","text":"<p>unique identifier for the status (a name?)</p>"},{"location":"cli/github/status/#description","title":"<code>--description</code>","text":"<p>a short description of the status</p>"},{"location":"cli/github/status/#options","title":"Options","text":""},{"location":"cli/github/status/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/status/#state","title":"<code>--state</code>","text":"<ul><li>choices: <code>error</code>, <code>failure</code>, <code>pending</code>, <code>success</code></li></ul> <p>the state of the status</p>"},{"location":"cli/github/status/#url","title":"<code>--url</code>","text":"<p>URL to associate with this status</p>"},{"location":"cli/message/close/","title":"m message close","text":"<p>Close a block.</p> <p>When a block is closed, all its inner blocks are closed automatically. Not all CI Tools support nesting.</p> Source code in <code>m/cli/commands/message/close.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Close a block.\n\n    When a block is closed, all its inner blocks are closed automatically.\n    Not all CI Tools support nesting.\n    \"\"\"\n\n    name: str = Arg(\n        help='block name to close',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/message/close/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/message/close/#name","title":"<code>name</code>","text":"<p>block name to close</p>"},{"location":"cli/message/error/","title":"m message error","text":"<p>Report an error.</p> <p>example::</p> <pre><code>~$ m message error 'this is an error'\n::error::this is an error\n~$ echo $?\n1\n</code></pre> <p>The procedure exits with non-zero code.</p> Source code in <code>m/cli/commands/message/error.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Report an error.\n\n    example::\n\n        ~$ m message error 'this is an error'\n        ::error::this is an error\n        ~$ echo $?\n        1\n\n    The procedure exits with non-zero code.\n    \"\"\"\n\n    message: str = Arg(\n        help='error message',\n        positional=True,\n        required=True,\n    )\n    file: str | None = Arg(  # noqa: WPS110 - required by Github\n        aliases=['f', 'file'],\n        help='filename where error occurred',\n    )\n    line: str | None = Arg(\n        aliases=['l', 'line'],\n        help='line where error occurred',\n    )\n    col: str | None = Arg(\n        aliases=['c', 'col'],\n        help='column where error occurred',\n    )\n</code></pre>"},{"location":"cli/message/error/#options","title":"Options","text":""},{"location":"cli/message/error/#file","title":"<code>-f</code>, <code>--file</code>","text":"<p>filename where error occurred</p>"},{"location":"cli/message/error/#line","title":"<code>-l</code>, <code>--line</code>","text":"<p>line where error occurred</p>"},{"location":"cli/message/error/#col","title":"<code>-c</code>, <code>--col</code>","text":"<p>column where error occurred</p>"},{"location":"cli/message/error/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/message/error/#message","title":"<code>message</code>","text":"<p>error message</p>"},{"location":"cli/message/open/","title":"m message open","text":"<p>Open a block to group several messages in the build log.</p> Source code in <code>m/cli/commands/message/open.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Open a block to group several messages in the build log.\"\"\"\n\n    name: str = Arg(\n        help='block name to open',\n        positional=True,\n        required=True,\n    )\n    description: str = Arg(\n        help='block description',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/message/open/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/message/open/#name","title":"<code>name</code>","text":"<p>block name to open</p>"},{"location":"cli/message/open/#description","title":"<code>description</code>","text":"<p>block description</p>"},{"location":"cli/message/sibling_block/","title":"m message sibling_block","text":"<p>Close and immediately open another block.</p> Source code in <code>m/cli/commands/message/sibling_block.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Close and immediately open another block.\"\"\"\n\n    to_close: str = Arg(\n        help='block name to close',\n        positional=True,\n        required=True,\n    )\n    name: str = Arg(\n        help='block name to open',\n        positional=True,\n        required=True,\n    )\n    description: str = Arg(\n        help='block description',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/message/sibling_block/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/message/sibling_block/#to_close","title":"<code>to_close</code>","text":"<p>block name to close</p>"},{"location":"cli/message/sibling_block/#name","title":"<code>name</code>","text":"<p>block name to open</p>"},{"location":"cli/message/sibling_block/#description","title":"<code>description</code>","text":"<p>block description</p>"},{"location":"cli/message/warn/","title":"m message warn","text":"<p>Report a warning.</p> <p>example::</p> <pre><code>~$ m message warn 'this is a warning' -f app.js -l 1 -c 5\n::warning file=app.js,line=1,col=5::Missing semicolon\n</code></pre> Source code in <code>m/cli/commands/message/warn.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Report a warning.\n\n    example::\n\n        ~$ m message warn 'this is a warning' -f app.js -l 1 -c 5\n        ::warning file=app.js,line=1,col=5::Missing semicolon\n    \"\"\"\n\n    message: str = Arg(\n        help='warning message',\n        positional=True,\n        required=True,\n    )\n    file: str | None = Arg(  # noqa: WPS110 - required by Github\n        aliases=['f', 'file'],\n        help='filename where warning occurred',\n    )\n    line: str | None = Arg(\n        aliases=['l', 'line'],\n        help='line where warning occurred',\n    )\n    col: str | None = Arg(\n        aliases=['c', 'col'],\n        help='column where warning occurred',\n    )\n</code></pre>"},{"location":"cli/message/warn/#options","title":"Options","text":""},{"location":"cli/message/warn/#file","title":"<code>-f</code>, <code>--file</code>","text":"<p>filename where warning occurred</p>"},{"location":"cli/message/warn/#line","title":"<code>-l</code>, <code>--line</code>","text":"<p>line where warning occurred</p>"},{"location":"cli/message/warn/#col","title":"<code>-c</code>, <code>--col</code>","text":"<p>column where warning occurred</p>"},{"location":"cli/message/warn/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/message/warn/#message","title":"<code>message</code>","text":"<p>warning message</p>"},{"location":"cli/npm/clean_tags/","title":"m npm clean_tags","text":"<p>Remove empty npm tags.</p> <pre><code>$ m npm clean_tags @scope/package\n</code></pre> <p>When packages are removed there will be empty tags that point to nothing. This command will find those empty tags and remove them.</p> Source code in <code>m/cli/commands/npm/clean_tags.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Remove empty npm tags.\n\n        $ m npm clean_tags @scope/package\n\n    When packages are removed there will be empty tags that point to nothing.\n    This command will find those empty tags and remove them.\n    \"\"\"\n\n    package_name: str = Arg(\n        help='name of the npm package',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/npm/clean_tags/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/npm/clean_tags/#package_name","title":"<code>package_name</code>","text":"<p>name of the npm package</p>"},{"location":"github-actions/api/","title":"API","text":"<p>This page has been added here as a quick reference for the API of the <code>m.github.actions</code> module.</p>"},{"location":"github-actions/api/#m.github.actions.Action","title":"<code>Action</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A Github action.</p> <p>The main object to help us define the <code>actions.yaml</code> file. Each repository can declare several actions. For this reason we can declare the <code>actions</code> object as a single <code>Action</code> or a list of them.</p> <p>We could technically do everything in one single step but when we use external actions then we are forced to split the step. Note that we have no way of having the <code>if</code> fields in each step. This is because we are encouraged to handle that logic in each of the steps we declare. We have full control of the output to <code>stdout</code> and <code>stderr</code> here.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>str</code> <p>The full path to the <code>action.yaml</code> file.</p> <code>name</code> <code>str</code> <p>The name of the action.</p> <code>description</code> <code>str</code> <p>Short description for the action.</p> <code>inputs</code> <code>type[KebabModel] | None</code> <p>A model describing the inputs for the action. If the action does not need inputs then provide <code>None</code>. It is important to be explicit in this step so that we do not wonder why we cannot use <code>inputs.[argname]</code> when we declare a step.</p> <code>steps</code> <code>list[RunStep | UsesStep]</code> <p>The steps for the action</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>class Action(BaseModel):\n    \"\"\"A Github action.\n\n    The main object to help us define the `actions.yaml` file. Each repository can\n    declare several actions. For this reason we can declare the `actions` object as\n    a single `Action` or a list of them.\n\n    We could technically do everything in one single step but when we use external\n    actions then we are forced to split the step. Note that we have no way of\n    having the `if` fields in each step. This is because we are encouraged to handle\n    that logic in each of the steps we declare. We have full control of the output to\n    `stdout` and `stderr` here.\n    \"\"\"\n\n    file_path: str = Field(description='The full path to the `action.yaml` file.')\n\n    name: str = Field(description='The name of the action.')\n\n    description: str = Field(description='Short description for the action.')\n\n    inputs: type[KebabModel] | None = Field(description=\"\"\"\n        A model describing the inputs for the action. If the action does not\n        need inputs then provide `None`. It is important to be explicit in this step\n        so that we do not wonder why we cannot use `inputs.[argname]` when we declare a\n        step.\n    \"\"\")\n\n    steps: list[RunStep | UsesStep] = Field(\n        description='The steps for the action',\n    )\n\n    def gather_outputs(self: 'Action') -&gt; Res[ActionOutputs]:\n        \"\"\"Obtain a tuple with the action outputs and all steps outputs.\n\n        The steps outputs is a dictionary that maps keys of the form\n        [step_id].[step_output_arg] to the output of another step, action\n        input or some other value that should be used as input.\n\n        This function validates that all the keys are valid.\n\n        Returns:\n            A tuple with the outputs if successful, otherwise an issue.\n        \"\"\"\n        action_inputs = self.inputs or KebabModel\n        available_outputs: dict[str, str] = {\n            f'inputs.{name}': f'inputs.{arg_info.alias}'\n            for name, arg_info in action_inputs.model_fields.items()\n        }\n\n        outputs: dict[str, MetadataOutput] = {}\n        all_issues: dict[str, list[dict]] = {}\n        for step in self.steps:\n            input_model, output_model = step.get_inputs_outputs()\n            output_fields = OutputField.create(step.id, output_model)\n            # mypy has trouble seeing that its bound to KebabModel\n            self_args = cast(KebabModel, step.args)\n            all_args = self_args.model_dump() if self_args else {}\n            issues = verify_inputs(input_model, all_args, available_outputs)\n            if issues:\n                all_issues[step.id] = [\n                    iss.model_dump(exclude_none=True)\n                    for iss in issues\n                ]\n            for name, field in output_fields.items():\n                short_name = field.short_ref_name\n                available_outputs[short_name] = field.full_ref_name\n                if field.is_export:\n                    outputs[name] = field.get_metadata_output()\n        if all_issues:\n            return issue('step_inputs_failure', context=all_issues)\n        return Good((outputs, available_outputs))\n</code></pre>"},{"location":"github-actions/api/#m.github.actions.Action.gather_outputs","title":"<code>gather_outputs()</code>","text":"<p>Obtain a tuple with the action outputs and all steps outputs.</p> <p>The steps outputs is a dictionary that maps keys of the form [step_id].[step_output_arg] to the output of another step, action input or some other value that should be used as input.</p> <p>This function validates that all the keys are valid.</p> <p>Returns:</p> Type Description <code>Res[ActionOutputs]</code> <p>A tuple with the outputs if successful, otherwise an issue.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def gather_outputs(self: 'Action') -&gt; Res[ActionOutputs]:\n    \"\"\"Obtain a tuple with the action outputs and all steps outputs.\n\n    The steps outputs is a dictionary that maps keys of the form\n    [step_id].[step_output_arg] to the output of another step, action\n    input or some other value that should be used as input.\n\n    This function validates that all the keys are valid.\n\n    Returns:\n        A tuple with the outputs if successful, otherwise an issue.\n    \"\"\"\n    action_inputs = self.inputs or KebabModel\n    available_outputs: dict[str, str] = {\n        f'inputs.{name}': f'inputs.{arg_info.alias}'\n        for name, arg_info in action_inputs.model_fields.items()\n    }\n\n    outputs: dict[str, MetadataOutput] = {}\n    all_issues: dict[str, list[dict]] = {}\n    for step in self.steps:\n        input_model, output_model = step.get_inputs_outputs()\n        output_fields = OutputField.create(step.id, output_model)\n        # mypy has trouble seeing that its bound to KebabModel\n        self_args = cast(KebabModel, step.args)\n        all_args = self_args.model_dump() if self_args else {}\n        issues = verify_inputs(input_model, all_args, available_outputs)\n        if issues:\n            all_issues[step.id] = [\n                iss.model_dump(exclude_none=True)\n                for iss in issues\n            ]\n        for name, field in output_fields.items():\n            short_name = field.short_ref_name\n            available_outputs[short_name] = field.full_ref_name\n            if field.is_export:\n                outputs[name] = field.get_metadata_output()\n    if all_issues:\n        return issue('step_inputs_failure', context=all_issues)\n    return Good((outputs, available_outputs))\n</code></pre>"},{"location":"github-actions/api/#m.github.actions.KebabModel","title":"<code>KebabModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Allows models to be defined with kebab case properties.</p> <p>Inputs and outputs need to be written using a <code>KebabModel</code> as a base class. This is so that their definitions may be written using kebab casing in the final <code>action.yaml</code>.</p> <pre><code>from m.github.actions import KebabModel, InArg\n\nclass MyInput(KebabModel):\n    my_input: str = InArg(help='description')\n</code></pre> Source code in <code>m/pydantic.py</code> <pre><code>class KebabModel(BaseModel):\n    \"\"\"Allows models to be defined with kebab case properties.\n\n    Inputs and outputs need to be written using a `KebabModel` as a base class.\n    This is so that their definitions may be written using kebab casing in the\n    final `action.yaml`.\n\n    ```python\n    from m.github.actions import KebabModel, InArg\n\n    class MyInput(KebabModel):\n        my_input: str = InArg(help='description')\n    ```\n    \"\"\"\n\n    model_config = ConfigDict(\n        alias_generator=to_kebab,\n        populate_by_name=True,\n    )\n</code></pre>"},{"location":"github-actions/api/#m.github.actions.RunStep","title":"<code>RunStep</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[InputModel, OutputModel]</code></p> <p>Model used to define a \"run\" step in a Github action.</p> <p>The <code>id</code> is important because this is how we will be able to refer to the outputs generated by the step. Say our action called other external actions such as the cache action. Then if we wanted to pass one of the outputs to the cache action we would have to get a handle on the step.</p> <pre><code>args=SomeInput(some_arg='my_run_step_id.some_output')\n</code></pre> <p>The <code>args</code> should leverage the help of their own input models. All they require is that we provide the handle to other outputs from other steps or some other values we wish to pass.</p> <p>Experiment with different values to see what <code>action.yaml</code> generates.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The id of the step.</p> <code>run_if</code> <code>str | None</code> <p>The condition to run the step.</p> <code>run</code> <code>Callable[[InputModel], Res[OutputModel]]</code> <p>The function passed to <code>run_action</code>.</p> <code>args</code> <code>InputModel | None</code> <p>The arguments to pass to the run function.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>class RunStep(BaseModel, Generic[InputModel, OutputModel]):\n    \"\"\"Model used to define a \"run\" step in a Github action.\n\n    The `id` is important because this is how we will be able to refer to the\n    outputs generated by the step. Say our action called other external actions\n    such as the cache action. Then if we wanted to pass one of the outputs to\n    the cache action we would have to get a handle on the step.\n\n    ```python\n    args=SomeInput(some_arg='my_run_step_id.some_output')\n    ```\n\n    The `args` should leverage the help of their own input models. All they\n    require is that we provide the handle to other outputs from other steps or\n    some other values we wish to pass.\n\n    Experiment with different values to see what `action.yaml` generates.\n    \"\"\"\n\n    id: str = Field(description='The id of the step.')\n\n    run_if: str | None = Field(\n        default=None,\n        description='The condition to run the step.',\n    )\n\n    run: Callable[[InputModel], Res[OutputModel]] = Field(\n        description='The function passed to [`run_action`][m.github.actions.api.run_action].',\n    )\n\n    args: InputModel | None = Field(\n        description='The arguments to pass to the run function.',\n    )\n\n    def get_inputs_outputs(self: 'RunStep') -&gt; InputOutputs:\n        \"\"\"Get the inputs and outputs for the step.\n\n        Returns:\n            A tuple of the inputs and outputs.\n        \"\"\"\n        return get_inputs_outputs(self.run)\n\n    def to_str(\n        self: 'RunStep',\n        python_path: str,\n        available_values: dict[str, str],\n    ) -&gt; str:\n        \"\"\"Generate a string to use in the Github Action.\n\n        Args:\n            python_path: The path to the python module.\n            available_values: The values that are available to the step.\n\n        Returns:\n            A string to add to the Github action.\n        \"\"\"\n        template = \"\"\"\\\n            - id: {id}{run_if}\n              shell: bash{env}\n              run: PYTHONPATH=\"$GITHUB_ACTION_PATH{py_path}\" python -m {mod}\n        \"\"\"\n        run_if = _run_if(self.run_if, available_values)\n        # mypy has trouble seeing that its bound to KebabModel\n        self_args = cast(KebabModel, self.args)\n        all_args = self_args.model_dump() if self_args else {}\n        mapped_args = map_args(all_args, available_values, input_env)\n        env = ''\n        if mapped_args:\n            arg_lines = '\\n'.join([\n                f'    {key}: {env_val}'\n                for key, env_val in mapped_args.items()\n            ])\n            env = f'\\n  env:\\n{arg_lines}'\n        py_path = f'/{python_path}' if python_path else ''\n        return dedent(template).format(\n            id=self.id,\n            env=env,\n            run_if=run_if,\n            py_path=py_path,\n            mod=self.run.__module__,\n        ).rstrip()\n</code></pre>"},{"location":"github-actions/api/#m.github.actions.RunStep.get_inputs_outputs","title":"<code>get_inputs_outputs()</code>","text":"<p>Get the inputs and outputs for the step.</p> <p>Returns:</p> Type Description <code>InputOutputs</code> <p>A tuple of the inputs and outputs.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def get_inputs_outputs(self: 'RunStep') -&gt; InputOutputs:\n    \"\"\"Get the inputs and outputs for the step.\n\n    Returns:\n        A tuple of the inputs and outputs.\n    \"\"\"\n    return get_inputs_outputs(self.run)\n</code></pre>"},{"location":"github-actions/api/#m.github.actions.RunStep.to_str","title":"<code>to_str(python_path, available_values)</code>","text":"<p>Generate a string to use in the Github Action.</p> <p>Parameters:</p> Name Type Description Default <code>python_path</code> <code>str</code> <p>The path to the python module.</p> required <code>available_values</code> <code>dict[str, str]</code> <p>The values that are available to the step.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github action.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def to_str(\n    self: 'RunStep',\n    python_path: str,\n    available_values: dict[str, str],\n) -&gt; str:\n    \"\"\"Generate a string to use in the Github Action.\n\n    Args:\n        python_path: The path to the python module.\n        available_values: The values that are available to the step.\n\n    Returns:\n        A string to add to the Github action.\n    \"\"\"\n    template = \"\"\"\\\n        - id: {id}{run_if}\n          shell: bash{env}\n          run: PYTHONPATH=\"$GITHUB_ACTION_PATH{py_path}\" python -m {mod}\n    \"\"\"\n    run_if = _run_if(self.run_if, available_values)\n    # mypy has trouble seeing that its bound to KebabModel\n    self_args = cast(KebabModel, self.args)\n    all_args = self_args.model_dump() if self_args else {}\n    mapped_args = map_args(all_args, available_values, input_env)\n    env = ''\n    if mapped_args:\n        arg_lines = '\\n'.join([\n            f'    {key}: {env_val}'\n            for key, env_val in mapped_args.items()\n        ])\n        env = f'\\n  env:\\n{arg_lines}'\n    py_path = f'/{python_path}' if python_path else ''\n    return dedent(template).format(\n        id=self.id,\n        env=env,\n        run_if=run_if,\n        py_path=py_path,\n        mod=self.run.__module__,\n    ).rstrip()\n</code></pre>"},{"location":"github-actions/api/#m.github.actions.UsesStep","title":"<code>UsesStep</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[InputModel, OutputModel]</code></p> <p>A \"uses\" step in a Github action.</p> <p>Model similar to <code>RunStep</code> but since we do not have access to the code that gets executed all we can do is provide the <code>uses</code> field and our models to describe what the action expects.</p> <p>For instance, say we wanted to use the <code>actions/cache@v4</code> action. To avoid having issues in the future we should create the input and output models manually by looking at the documentation https://github.com/actions/cache#inputs.</p> <pre><code>class CacheInputs(KebabModel):\n    key: str = InArg(help='An explicit key for a cache entry')\n    path: str = InArg(help=\"\"\"\n        A list of files, directories, and wildcard patterns to cache and\n        restore.\n    \"\"\")\n</code></pre> <p>Similarly for the outputs we can define a model. This in the long run should help us maintain the composite action better. It is recommended to check the inputs and outputs as we update action versions to ensure compatibility.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The step id.</p> <code>run_if</code> <code>str | None</code> <p>The condition to run the step.</p> <code>uses</code> <code>str</code> <p>A string referencing an action.</p> <code>inputs</code> <code>type[InputModel]</code> <p>A reference to a KebabModel type.</p> <code>outputs</code> <code>type[OutputModel]</code> <p>A reference to a KebabModel type.</p> <code>args</code> <code>InputModel | None</code> <p>The arguments to pass to the action</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>class UsesStep(BaseModel, Generic[InputModel, OutputModel]):\n    \"\"\"A \"uses\" step in a Github action.\n\n    Model similar to [`RunStep`][m.github.actions.RunStep] but since we do\n    not have access to the code that gets executed all we can do is provide the\n    `uses` field and our models to describe what the action expects.\n\n    For instance, say we wanted to use the `actions/cache@v4` action. To avoid\n    having issues in the future we should create the input and output models\n    manually by looking at the documentation\n    &lt;https://github.com/actions/cache#inputs&gt;.\n\n    ```python\n    class CacheInputs(KebabModel):\n        key: str = InArg(help='An explicit key for a cache entry')\n        path: str = InArg(help=\\\"\\\"\\\"\n            A list of files, directories, and wildcard patterns to cache and\n            restore.\n        \\\"\\\"\\\")\n    ```\n\n    Similarly for the outputs we can define a model. This in the long run should\n    help us maintain the composite action better. It is recommended to check the\n    inputs and outputs as we update action versions to ensure compatibility.\n    \"\"\"  # noqa: D301, D300 - Angry with slash but we need to escape them\n\n    id: str = Field(description='The step id.')\n\n    run_if: str | None = Field(\n        default=None,\n        description='The condition to run the step.',\n    )\n\n    uses: str = Field(description='A string referencing an action.')\n\n    inputs: type[InputModel] = Field(\n        description='A reference to a [KebabModel][m.pydantic.KebabModel] type.',\n    )\n\n    outputs: type[OutputModel] = Field(\n        description='A reference to a [KebabModel][m.pydantic.KebabModel] type.',\n    )\n\n    args: InputModel | None = Field(\n        description='The arguments to pass to the action',\n    )\n\n    def get_inputs_outputs(self: 'UsesStep') -&gt; InputOutputs:\n        \"\"\"Get the inputs and outputs for the step.\n\n        Returns:\n            A tuple of the inputs and outputs.\n        \"\"\"\n        return self.inputs, self.outputs\n\n    def to_str(\n        self: 'UsesStep',\n        _python_path: str,\n        available_values: dict[str, str],\n    ) -&gt; str:\n        \"\"\"Generate a string to use in the Github Action.\n\n        Args:\n            _python_path: The path to the python module.\n            available_values: The values that are available to the step.\n\n        Returns:\n            A string to add to the Github action.\n        \"\"\"\n        template = \"\"\"\\\n            - id: {id}{run_if}\n              uses: {uses}{env}\n        \"\"\"\n        run_if = _run_if(self.run_if, available_values)\n        # mypy has trouble seeing that its bound to KebabModel\n        self_args = cast(KebabModel, self.args)\n        all_args = self_args.model_dump() if self_args else {}\n        mapped_args = map_args(\n            all_args,\n            available_values,\n            lambda x: x.replace('_', '-', -1),\n        )\n        env = ''\n        if mapped_args:\n            arg_lines = '\\n'.join([\n                f'    {key}: {env_val}'\n                for key, env_val in mapped_args.items()\n            ])\n            env = f'\\n  with:\\n{arg_lines}'\n        return dedent(template).format(\n            id=self.id,\n            run_if=run_if,\n            uses=self.uses,\n            env=env,\n        ).rstrip()\n</code></pre>"},{"location":"github-actions/api/#m.github.actions.UsesStep.get_inputs_outputs","title":"<code>get_inputs_outputs()</code>","text":"<p>Get the inputs and outputs for the step.</p> <p>Returns:</p> Type Description <code>InputOutputs</code> <p>A tuple of the inputs and outputs.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def get_inputs_outputs(self: 'UsesStep') -&gt; InputOutputs:\n    \"\"\"Get the inputs and outputs for the step.\n\n    Returns:\n        A tuple of the inputs and outputs.\n    \"\"\"\n    return self.inputs, self.outputs\n</code></pre>"},{"location":"github-actions/api/#m.github.actions.UsesStep.to_str","title":"<code>to_str(_python_path, available_values)</code>","text":"<p>Generate a string to use in the Github Action.</p> <p>Parameters:</p> Name Type Description Default <code>_python_path</code> <code>str</code> <p>The path to the python module.</p> required <code>available_values</code> <code>dict[str, str]</code> <p>The values that are available to the step.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github action.</p> Source code in <code>m/github/actions/actions.py</code> <pre><code>def to_str(\n    self: 'UsesStep',\n    _python_path: str,\n    available_values: dict[str, str],\n) -&gt; str:\n    \"\"\"Generate a string to use in the Github Action.\n\n    Args:\n        _python_path: The path to the python module.\n        available_values: The values that are available to the step.\n\n    Returns:\n        A string to add to the Github action.\n    \"\"\"\n    template = \"\"\"\\\n        - id: {id}{run_if}\n          uses: {uses}{env}\n    \"\"\"\n    run_if = _run_if(self.run_if, available_values)\n    # mypy has trouble seeing that its bound to KebabModel\n    self_args = cast(KebabModel, self.args)\n    all_args = self_args.model_dump() if self_args else {}\n    mapped_args = map_args(\n        all_args,\n        available_values,\n        lambda x: x.replace('_', '-', -1),\n    )\n    env = ''\n    if mapped_args:\n        arg_lines = '\\n'.join([\n            f'    {key}: {env_val}'\n            for key, env_val in mapped_args.items()\n        ])\n        env = f'\\n  with:\\n{arg_lines}'\n    return dedent(template).format(\n        id=self.id,\n        run_if=run_if,\n        uses=self.uses,\n        env=env,\n    ).rstrip()\n</code></pre>"},{"location":"github-actions/api/#m.github.actions.InArg","title":"<code>InArg(*, help, default=None)</code>","text":"<p>Force proper annotation of the input of a GitHub Action.</p> <p>Should be used to declare the input arguments of an action. It returns <code>Any</code> to bypass <code>mypy</code>'s type checking. Similar to pydantic.fields.Field but it is tailored to help us write the inputs for an action and its steps.</p> <p>Note</p> <p>By default all input arguments are required. If you want to make an input not required then provide a default value.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>Human-readable description.</p> required <code>default</code> <code>str | None</code> <p>The default value for the argument.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>, the return annotation is <code>Any</code> so <code>InArg</code> can be used on type annotated fields without causing typing errors.</p> Source code in <code>m/github/actions/api.py</code> <pre><code>def InArg(  # noqa: N802\n    *,\n    help: str,  # noqa: WPS125\n    default: str | None = None,\n) -&gt; Any:\n    \"\"\"Force proper annotation of the input of a GitHub Action.\n\n    Should be used to declare the input arguments of an action. It returns\n    [`Any`][typing.Any] to bypass `mypy`'s type checking. Similar to\n    [pydantic.fields.Field][] but it is tailored to help us write the inputs for\n    an action and its steps.\n\n    !!! note\n\n        By default all input arguments are required. If you want to make an\n        input not required then provide a default value.\n\n    Args:\n        help: Human-readable description.\n        default: The default value for the argument.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo], the return annotation is\n            `Any` so `InArg` can be used on type annotated fields without\n            causing typing errors.\n    \"\"\"\n    args = {\n        'description': help,\n    }\n    if default is not None:\n        args['default'] = default\n    return FieldInfo.from_field(**args)\n</code></pre>"},{"location":"github-actions/api/#m.github.actions.OutArg","title":"<code>OutArg(*, help, export=False)</code>","text":"<p>Force proper annotation of the output of a GitHub Action.</p> <p>Note</p> <p>All steps have access to the steps output, if we want to make the output available to the action we need to <code>export</code> it.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>Human-readable description.</p> required <code>export</code> <code>bool</code> <p>Whether the argument is to be exported to the action.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>, the return annotation is <code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/github/actions/api.py</code> <pre><code>def OutArg(  # noqa: N802\n    *,\n    help: str,  # noqa: WPS125\n    export: bool = False,\n) -&gt; Any:\n    \"\"\"Force proper annotation of the output of a GitHub Action.\n\n    !!! note\n        All steps have access to the steps output, if we want to make the output\n        available to the action we need to `export` it.\n\n    Args:\n        help: Human-readable description.\n        export: Whether the argument is to be exported to the action.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo], the return annotation is\n            `Any` so `Arg` can be used on type annotated fields without causing\n            a typing error.\n    \"\"\"\n    return FieldInfo.from_field(\n        description=help,\n        json_schema_extra={'export': export},\n    )\n</code></pre>"},{"location":"github-actions/api/#m.github.actions.run_action","title":"<code>run_action(main)</code>","text":"<p>Entry point for a GitHub Action.</p> <p>This is the main function that should be used to run an action. It takes in a function that takes in a m.pydantic.KebabModel and returns a <code>Res[KebabModel]</code>.</p> <p>The only place where this function is needed is in the the if block</p> <pre><code>if __name__ == '__main__':\n    run_action(my_action)\n</code></pre> <p><code>mypy</code> will make sure that the you are providing the correct type of function to <code>run_action</code>. Keep in mind, the function is generic and we should be writing models for the inputs and outputs for all of our functions.</p> <p>Parameters:</p> Name Type Description Default <code>main</code> <code>Callable[[InputModel], Res[OutputModel]]</code> <p>The main function of the GitHub Action.</p> required Source code in <code>m/github/actions/api.py</code> <pre><code>def run_action(main: Callable[[InputModel], Res[OutputModel]]) -&gt; None:\n    \"\"\"Entry point for a GitHub Action.\n\n    This is the main function that should be used to run an action. It takes in\n    a function that takes in a [m.pydantic.KebabModel][] and returns a\n    `Res[KebabModel]`.\n\n    The only place where this function is needed is in the the if block\n\n    ```python\n    if __name__ == '__main__':\n        run_action(my_action)\n    ```\n\n    `mypy` will make sure that the you are providing the correct type of function\n    to `run_action`. Keep in mind, the function is generic and we should be writing\n    models for the inputs and outputs for all of our functions.\n\n    Args:\n        main: The main function of the GitHub Action.\n    \"\"\"\n    logging_config()\n    main_params = signature(main).parameters\n    arg_name = next(iter(main_params))\n    input_model = main_params[arg_name].annotation\n    args = load_step_inputs(input_model)\n    if isinstance(args, Bad):\n        default_issue_handler(args.value)\n        sys.exit(4)\n    inputs = args.value\n    exit_code = run_main(lambda: main(inputs), result_handler=_result_handler)\n    sys.exit(exit_code)\n</code></pre>"},{"location":"github-actions/intro/","title":"Motivation","text":"<p>Github actions does not support python as well as it does typescript projects. The following are thoughts on how to leverage the python type system to help us create actions with python. To begin we need to be aware of the metadata file.</p>"},{"location":"github-actions/intro/#actionyaml","title":"<code>action.yaml</code>","text":"<p>This file may be placed at the root of the repo. There may be other actions in the same repo but we'll cover them as we explore.</p> <p>The first thing to note is that we are expected to create the yaml file of inputs and outputs and define the composite steps in which we call our python scripts. Here is a quick example</p> <pre><code># action.yaml\nname: square-number\ndescription: takes in an input number and returns its square\ninputs:\n  num:\n    description: the number to square\n    required: true\noutputs:\n  num-squared:\n    description: the input squared\n    value: ${{ steps.get-square.outputs.num-squared }}\n\nruns:\n  using: 'composite'\n  steps:\n    - id: get-square\n      shell: bash\n      env:\n        INPUT_NUM: ${{ inputs.num }}\n      run: PYTHONPATH=\"$GITHUB_ACTION_PATH/src\" python -m square_number\n</code></pre> <p>and the python file</p> <pre><code># src/square_number.py\nimport os\n\ndef append_to_output(var_name: str, var_value: str) -&gt; None:\n    with open(os.environ.get(\"GITHUB_OUTPUT\"), 'a') as f:\n        f.write(f'{var_name}={var_value}\\n')\n\ndef main() -&gt; None:\n    num = int(os.environ.get('INPUT_NUM'))\n    result = num * num\n    append_to_output('num-square', str(result))\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>One thing to mention here is that the <code>PYTHONPATH</code> is set before calling the main function so that we may be able to use several files in the <code>src</code> directory.</p>"},{"location":"github-actions/intro/#downsides","title":"Downsides","text":"<p>Maintaining the <code>action.yaml</code> file is not an easy task. As we add new inputs we need to also add the input to the step that needs it. Managing outputs is also not straight forward. We may write to <code>$GITHUB_OUTPUT</code> inside a script but we may forget to declare it in the <code>action.yaml</code> file. Just in the creation of the example above there was 4 mistakes made. Some mistakes were as simple as not using the proper name of the python module in the <code>action.yaml</code> file.</p> <p>Once we start adding more functionality it gets harder to keep track of the variables, inputs, outputs and script names and the usual way to test is to modify the script and use it in a workflow. This is not ideal.</p>"},{"location":"github-actions/intro/#prototype","title":"Prototype","text":"<p>If we can manage to always write the <code>action.yaml</code> file by keeping the pattern of only calling python scripts and providing inputs via environment variables then we can generate the <code>action.yaml</code> and instead create a more strict format to help us creation actions using python.</p> <p>The first assumption will be the action can only be executed in an environment that has <code>python</code> and <code>m</code>. An attempt can be made by creating a yaml format where we specify the classes used as inputs and outputs and the function to execute.</p> <pre><code># m.yaml prototype\ngithub_actions:\n  _python_path: src\n  _inputs: square_number.GithubInputs\n  square_number:\n    - id: square_number\n      inputs: square_number.GithubInputs\n      outputs: square_number.SquareNumberOutputs\n      args:\n        num: inputs.num\n</code></pre> <p>We can verify that the classes exist and provide useful errors instead of running directly in Github. The downside to this approach is that we are still bound to make mistakes while creating the configuration. A better approach is to simply create an <code>m</code> cli that takes in the path to a python file with an <code>actions</code> object. This object can be required to be of type <code>Action</code> or <code>list[Action]</code>.</p> <p>Here is an example of how such file could look like</p> <pre><code>from m.github.actions import Action\nfrom models import GithubInputs\nfrom square_number import MainInputs, main_step\n\n\nactions = Action(\n    file_path='action.yaml',\n    name='square-number',\n    description='takes in an input number and returns its square',\n    inputs=GithubInputs,\n    steps=[\n        main_step('main', MainInputs(\n            main_in='inputs.num',\n        )),\n    ],\n)\n</code></pre> <p>Every class and function can be inspected to obtain documentation sources and file locations to help us create the yaml file. Overall, with a pattern like this the only mistake <code>mypy</code> would not be able to help us catch is declaring the input references from the <code>inputs</code> or other steps. But this is a small mistake which will be caught when generating the metadata <code>action.yaml</code> file.</p>"},{"location":"github-actions/testing/","title":"Testing","text":"<p><code>m</code> provides several utilities to help us test our actions. We can start with this example</p> <pre><code>import pytest\nfrom m.github.actions import Action\nfrom m.testing import ActionStepTestCase as TCase\nfrom m.testing import run_action_test_case\nfrom pytest_mock import MockerFixture\n\nfrom pkg.actions import actions\n\n\n@pytest.mark.parametrize(\n    'tcase',\n    [\n        TCase(\n            name='test_id',\n            py_file=f'src/pkg/main.py',\n            inputs={\n              'INPUT_ARG_A': 'val_a',\n              'INPUT_ARG_B': 'val_b',\n            },\n            expected_stdout='Anything we print to stdout',\n            outputs=['some-output=some_value'],\n        ),\n    ],\n    ids=lambda tcase: tcase.name,\n)\ndef test_m_gh_actions_api(tcase: TCase, mocker: MockerFixture) -&gt; None:\n    run_action_test_case(mocker, tcase)\n\n\ndef test_actions_instance() -&gt; None:\n    assert isinstance(actions, Action)\n    assert actions.name == 'Action Name'\n</code></pre> <p>Important</p> <p>This is not required but it is recommended to have this in the <code>__init__.py</code> for the root of the tests.</p> <pre><code>from m.testing import block_m_side_effects, block_network_access\n\nblock_m_side_effects()\nblock_network_access()\n</code></pre> <p>This will make sure that our tests do not make any calls to the internet and prevents our code from writing files. Instead it will force us to create mocks.</p>"},{"location":"github-actions/testing/#testing-api","title":"Testing API","text":""},{"location":"github-actions/testing/#m.testing.ActionStepTestCase","title":"<code>ActionStepTestCase</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Defines a test case for an action.</p> <p>Useful in the parametrization of several use cases for an action.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name for the test case. This is used as the identifier for a test case so that test failures may be easier to spot.</p> <code>py_file</code> <code>str</code> <p>Path to the python file to run.</p> <code>inputs</code> <code>dict[str, str]</code> <p>Inputs to the script. Should be of the form</p> <pre><code>{'INPUT_[SOME_NAME]': 'value'}\n</code></pre> <code>exit_code</code> <code>int</code> <p>The expected exit code (default: 0).</p> <code>expected_stdout</code> <code>str</code> <p>The expected stdout (default: empty).</p> <code>errors</code> <code>list[str]</code> <p>Errors may be noisy, specify strings that are expected to be in stderr in an array of strings.</p> <code>outputs</code> <code>list[str]</code> <p>list of Github outputs. Each entry in the array should be of the form</p> <pre><code>output-name=output-value\n</code></pre> <code>file_write_side_effect</code> <code>Any | None</code> <p>Defaults to <code>Good(0)</code>. This can be provided if we need to modify the behavior of m.core.rw.write_file. This is useful if we want to test cases in which a file failed to write.</p> Source code in <code>m/testing/testing.py</code> <pre><code>class ActionStepTestCase(BaseModel):\n    \"\"\"Defines a test case for an action.\n\n    Useful in the parametrization of several use cases for an action.\n    \"\"\"\n\n    name: str = Field(description=\"\"\"\n        Unique name for the test case. This is used as the identifier\n        for a test case so that test failures may be easier to spot.\n    \"\"\")\n\n    py_file: str = Field(description='Path to the python file to run.')\n\n    inputs: dict[str, str] = Field(description=\"\"\"\n        Inputs to the script. Should be of the form\n\n        ```py\n        {'INPUT_[SOME_NAME]': 'value'}\n        ```\n    \"\"\")\n\n    exit_code: int = Field(\n        default=0,\n        description='The expected exit code (default: 0).',\n    )\n\n    expected_stdout: str = Field(\n        default='',\n        description='The expected stdout (default: empty).',\n    )\n\n    # Errors may be noisy, specify strings that are expected to be in stderr\n    errors: list[str] = Field(\n        default=[],\n        description=\"\"\"\n            Errors may be noisy, specify strings that are expected to be in stderr\n            in an array of strings.\n        \"\"\",\n    )\n\n    # list of outputs: `output-name=output-value`\n    outputs: list[str] = Field(\n        default=[],\n        description=\"\"\"\n            list of Github outputs. Each entry in the array should be of the form\n\n            ```\n            output-name=output-value\n            ```\n        \"\"\",\n    )\n\n    file_write_side_effect: Any | None = Field(\n        default=None,\n        description=\"\"\"\n            Defaults to [`Good(0)`][m.core.fp.Good]. This can be provided if we\n            need to modify the behavior of [m.core.rw.write_file][]. This is\n            useful if we want to test cases in which a file failed to write.\n        \"\"\",\n    )\n</code></pre>"},{"location":"github-actions/testing/#m.testing.block_m_side_effects","title":"<code>block_m_side_effects()</code>","text":"<p>Blocks functions that have side effects.</p> <p>This function overrides the definition of <code>m</code> so that we do not accidentally try write a lot of files or create/move directories.</p> <p>The pathlib.Path.mkdir function should only be blocked while developing tests. It is a reminder that we haven't mocked the function yet. If we want to get this reminder then add <code>touch m/.m/pytest-ran</code> after the tests run locally.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with references to the original functions that were overridden in case these are needed.</p> Source code in <code>m/testing/testing.py</code> <pre><code>def block_m_side_effects() -&gt; dict[str, Any]:\n    \"\"\"Blocks functions that have side effects.\n\n    This function overrides the definition of `m` so that we do not accidentally\n    try write a lot of files or create/move directories.\n\n    The [pathlib.Path.mkdir][] function should only be blocked while developing\n    tests. It is a reminder that we haven't mocked the function yet. If we want\n    to get this reminder then add `touch m/.m/pytest-ran` after the tests run\n    locally.\n\n    Returns:\n        A dictionary with references to the original functions that were\n            overridden in case these are needed.\n    \"\"\"\n    import shutil\n    import subprocess  # noqa: S404 - importing to disable it during testing\n    from pathlib import Path\n\n    from m.core import rw as mio\n\n    originals = {\n        'write_file': mio.write_file,\n        'Path_mkdir': Path.mkdir,\n        'shutil_move': shutil.move,\n    }\n\n    mio.write_file = mock('m.core.rw.write_file')\n    subprocess.check_output = mock('m.core.subprocess.eval_cmd')\n    subprocess.call = mock('m.core.subprocess.exec_pnpm')\n    shutil.move = mock('shutil.move')\n\n    if not os.environ.get('CI'):\n        # We want to make sure that we do not create directories during tests.\n        # To do so we will mock the Path.mkdir function. There is a problem:\n        # pytest needs this function to create directories for its own purposes.\n        # For this reason we will only mock the function after we create the\n        # m/.m/pytest-ran file.\n        if Path('m/.m/pytest-ran').exists():\n            Path.mkdir = mock('pathlib.Path.mkdir')  # type: ignore\n\n    return originals\n</code></pre>"},{"location":"github-actions/testing/#m.testing.block_network_access","title":"<code>block_network_access()</code>","text":"<p>Blocks network access for all tests.</p> <p>This function overrides the definition of <code>socket</code> so that we do not accidentally try to run tests that make network calls. If our tests do not depend on other local services it is a good idea to call this before any of our tests runs.</p> <p>Otherwise we may want to modify this function to allow certain hosts to be called. (PRs welcomed).</p> Source code in <code>m/testing/testing.py</code> <pre><code>def block_network_access() -&gt; None:\n    \"\"\"Blocks network access for all tests.\n\n    This function overrides the definition of [`socket`][socket.socket] so that\n    we do not accidentally try to run tests that make network calls. If our tests\n    do not depend on other local services it is a good idea to call this before\n    any of our tests runs.\n\n    Otherwise we may want to modify this function to allow certain hosts to be\n    called. (PRs welcomed).\n    \"\"\"\n    # making sure that no calls to the internet are done\n    socket.socket = BlockNetwork  # type: ignore\n</code></pre>"},{"location":"github-actions/testing/#m.testing.mock","title":"<code>mock(func_name)</code>","text":"<p>Create a function that raises an error if its not mocked.</p> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>str</code> <p>full module path to the function to mock.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A function that raises an error if its not mocked.</p> Source code in <code>m/testing/testing.py</code> <pre><code>def mock(func_name: str) -&gt; Any:\n    \"\"\"Create a function that raises an error if its not mocked.\n\n    Args:\n        func_name: full module path to the function to mock.\n\n    Returns:\n        A function that raises an error if its not mocked.\n    \"\"\"\n    return partial(needs_mocking, func_name)\n</code></pre>"},{"location":"github-actions/testing/#m.testing.run_action_step","title":"<code>run_action_step(mocker, *, py_file, exit_code, env_vars, file_write_side_effect=None)</code>","text":"<p>Execute an action step in a test.</p> <p>This function expects the inputs to the script to be provided via environment variables of the form <code>INPUT_[SOME_NAME]</code>. The script will write the outputs to the file <code>FAKE_GITHUB_OUTPUT.txt</code>. We can verify the contents of the file by looking at the 3rd output from the function. This is a dictionary mapping file names to contents. Please note that this testing function mocks m.core.rw.write_file to obtain the file contents.</p> <p>Parameters:</p> Name Type Description Default <code>mocker</code> <code>MockerFixture</code> <p>A reference to the pytest <code>MockerFixture</code>.</p> required <code>py_file</code> <code>str</code> <p>The full path to the file that Github Actions will run.</p> required <code>exit_code</code> <code>int</code> <p>The expected exit code of the action. <code>0</code> means all is good.</p> required <code>env_vars</code> <code>dict[str, str]</code> <p>A dictionary of the environment variables that the action will receive.</p> required <code>file_write_side_effect</code> <code>Any | None</code> <p>This can be provided if we need to modify the behavior of m.core.rw.write_file. This is useful if we want to test cases in which a file failed to write.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, dict[str, str]]</code> <p>The standard out, standard error, and files written by m.core.rw.write_file.</p> Source code in <code>m/testing/conftest.py</code> <pre><code>def run_action_step(\n    mocker: MockerFixture,\n    *,\n    py_file: str,\n    exit_code: int,\n    env_vars: dict[str, str],\n    file_write_side_effect: Any | None = None,\n) -&gt; tuple[str, str, dict[str, str]]:\n    \"\"\"Execute an action step in a test.\n\n    This function expects the inputs to the script to be provided via environment\n    variables of the form `INPUT_[SOME_NAME]`. The script will write the outputs\n    to the file `FAKE_GITHUB_OUTPUT.txt`. We can verify the contents of the file\n    by looking at the 3rd output from the function. This is a dictionary mapping\n    file names to contents. Please note that this testing function mocks\n    [m.core.rw.write_file][] to obtain the file contents.\n\n    Args:\n        mocker: A reference to the pytest `MockerFixture`.\n        py_file: The full path to the file that Github Actions will run.\n        exit_code: The expected exit code of the action. `0` means all is good.\n        env_vars: A dictionary of the environment variables that the action will\n            receive.\n        file_write_side_effect: This can be provided if we need to modify the\n            behavior of [m.core.rw.write_file][]. This is useful if we want to\n            test cases in which a file failed to write.\n\n    Returns:\n        The standard out, standard error, and files written by [m.core.rw.write_file][].\n    \"\"\"\n    mocker.patch.dict(\n        os.environ,\n        {\n            'NO_COLOR': 'true',\n            **env_vars,\n            'GITHUB_OUTPUT': 'FAKE_GITHUB_OUTPUT.txt',\n        },\n        clear=True,\n    )\n\n    std_out = StringIO()\n    std_err = StringIO()\n    mocker.patch.object(sys, 'stdout', std_out)\n    mocker.patch.object(sys, 'stderr', std_err)\n    file_write_mock = mocker.patch('m.core.rw.write_file')\n    file_write_mock.side_effect = file_write_side_effect or [Good(0)]\n\n    prog = None\n    with pytest.raises(SystemExit) as prog_block:\n        prog = prog_block\n        runpy.run_path(py_file, {}, '__main__')\n\n    # Would be nice to be able to reset via a the mocker\n    sys.stdout = sys.__stdout__\n    sys.stderr = sys.__stderr__\n    assert prog is not None  # noqa: S101 - to be used in testing\n    file_writes = {\n        call.args[0]: call.args[1]\n        for call in file_write_mock.call_args_list\n    }\n\n    # next block should not be covered by coverage, we have this as a utility\n    # to help us write tests.\n    prog_code = prog.value.code\n    if prog_code != exit_code:  # pragma: no cover\n        print(std_out.getvalue(), file=sys.stdout)  # noqa: WPS421\n        print(std_err.getvalue(), file=sys.stderr)  # noqa: WPS421\n    assert prog_code == exit_code   # noqa: S101 - to be used in testing\n    return std_out.getvalue(), std_err.getvalue(), file_writes\n</code></pre>"},{"location":"github-actions/testing/#m.testing.run_action_test_case","title":"<code>run_action_test_case(mocker, tcase)</code>","text":"<p>Execute an action step test case.</p> <p>This is a commodity wrapper to help us run the action tests case. If we need more control over the assertions we can then copy and modify the implementation.</p> <p>Parameters:</p> Name Type Description Default <code>mocker</code> <code>MockerFixture</code> <p>A reference to the pytest <code>MockerFixture</code>.</p> required <code>tcase</code> <code>ActionStepTestCase</code> <p>The test case.</p> required Source code in <code>m/testing/conftest.py</code> <pre><code>def run_action_test_case(\n    mocker: MockerFixture,\n    tcase: ActionStepTestCase,\n) -&gt; None:\n    \"\"\"Execute an action step test case.\n\n    This is a commodity wrapper to help us run the action tests case. If we need\n    more control over the assertions we can then copy and modify the implementation.\n\n    Args:\n        mocker: A reference to the pytest `MockerFixture`.\n        tcase: The test case.\n    \"\"\"\n    stdout, stderr, file_writes = run_action_step(\n        mocker,\n        py_file=tcase.py_file,\n        exit_code=tcase.exit_code,\n        env_vars=tcase.inputs,\n        file_write_side_effect=tcase.file_write_side_effect,\n    )\n    assert stdout == tcase.expected_stdout  # noqa: S101\n    if tcase.errors:\n        for error in tcase.errors:\n            assert error in stderr  # noqa: S101\n\n    if tcase.exit_code == 0:\n        assert 'FAKE_GITHUB_OUTPUT.txt' in file_writes  # noqa: S101\n        gh_output = file_writes['FAKE_GITHUB_OUTPUT.txt']\n        assert gh_output == '\\n'.join(tcase.outputs)  # noqa: S101\n</code></pre>"},{"location":"github-actions/tutorial/","title":"Tutorial","text":"<p>This document attempts to describe the process of creating a new project using the <code>m</code> cli to generate a new action. The end result can be seen in https://github.com/jmlopez-rod/gha-square-num-m.</p>"},{"location":"github-actions/tutorial/#create-a-new-project","title":"Create a new project","text":"<p>The <code>gha-square-num-m</code> action started with the creation of a devcontainer. You may skip this if you are comfortable running things locally in your machine. The only requirement is to have <code>python&gt;=3.10</code> and <code>m</code> installed.</p> <p>As of this writing the <code>m github actions</code> cli is not yet available in PyPI, so you need to install directly from the working branch.</p> <pre><code>pip install git+https://github.com/jmlopez-rod/m.git@github-actions\n</code></pre> <p>In this commit we can see several files being added. The relevant parts are the <code>Makefile</code> and the <code>src</code> directory.</p>"},{"location":"github-actions/tutorial/#makefile","title":"Makefile","text":"<p>Start by adding the <code>mypy</code> target. This is to remind developers that we can run <code>make mypy</code>. Please make sure that the <code>src</code> directory is included in the <code>PYTHONPATH</code>. This was done via the devcontainer but if you are having issues with your IDE you may need to add it manually.</p> <pre><code>mypy:\n  PYTHONPATH=src mypy src\n</code></pre> <p>We should also add the <code>action</code> target so that we can run <code>make action</code>. You are encouraged to try to run this as many times as possible to make sure the cli is giving useful information. <code>make mypy</code> and <code>make action</code> should be the main commands to run during development.</p> <p>The final form of the Makefile should be something like this</p> <pre><code>mypy:\n    mypy src\n\naction:\n    m github actions src/pkg/actions.py\n\ntests:\n    ./src/tests/run.sh\n</code></pre>"},{"location":"github-actions/tutorial/#src-directory","title":"src directory","text":"<p>Make sure have the following directory structure</p> <pre><code>src\n\u251c\u2500\u2500 pkg\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 actions.py\n\u2502   \u251c\u2500\u2500 inputs.py\n\u2502   \u2514\u2500\u2500 main.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 run.sh\n    \u2514\u2500\u2500 test_action.py\n</code></pre> <p>All files can be empty at this point. We'll go over each one of those in the next section.</p>"},{"location":"github-actions/tutorial/#create-the-action","title":"Create the action","text":"<p>We'll start by creating the action inputs. You may define these in the <code>actions.py</code> or in its own file. For this example we have placed them in their own file since those inputs will be used by the main step.</p>"},{"location":"github-actions/tutorial/#inputspy","title":"inputs.py","text":"<pre><code># src/pkg/inputs.py\nfrom m.github.actions import InArg, KebabModel\n\n\nclass GithubInputs(KebabModel):\n    \"\"\"Inputs from the Github Action.\"\"\"\n\n    num: str = InArg(help='the number to square')\n</code></pre> <p>All inputs and outputs should be defined as strings. The <code>InArg</code> is a wrapper around <code>pydantic</code>s <code>Field</code> to function to help provide useful descriptions to the inputs. Note that these description will be used in the final <code>action.yaml</code> file. We can continue adding more inputs as needed, some may even have defaults. For instance, we could have done</p> <pre><code>class GithubInputs(kebabModel):\n    num: str = InArg(help='description', default='99')\n</code></pre> <p>Note that in python we use snake case. The <code>KebabModel</code> is an extension of <code>pydantic.BaseModel</code> so that it may generate kebab case properties. In the github actions yaml file we will see all variables using kebab casing.</p>"},{"location":"github-actions/tutorial/#mainpy","title":"main.py","text":"<p>Now we can create the main step. This is the main entry point for the single action step.</p> <p>For every step we create we need to define inputs and output models. Since all the inputs will be coming from the github action we can use the <code>GithubInputs</code> model.</p> <pre><code>from m.github.actions import KebabModel, OutArg\n\nfrom pkg.inputs import GithubInputs\n\nclass Outputs(KebabModel):\n    \"\"\"Outputs from the Github Action.\"\"\"\n\n    squared_num: str = OutArg(help='the squared number', export=True)\n</code></pre> <p>Each step will automatically export all of its outputs, but only some of those will be exported to the action itself. We may do so my setting <code>export=True</code> in in our output model.</p> <p>Note</p> <p>One of the common issues when creating a new action is to forget to add the output from a step. There is usually some typo while writing <code>${{ steps.[step-id].outputs.[output-name]}}</code>. By declaring the outputs with a flag now we can forget about it.</p> <p>Now that the inputs and outputs are defined we can create the main step.</p> <pre><code>def main(inputs: GithubInputs) -&gt; Res[Outputs]:\n    \"\"\"Square the given number.\n\n    Args:\n        inputs: The inputs to the step.\n\n    Returns:\n        The outputs of the step or an issue.\n    \"\"\"\n    print('Squaring the number')\n    num = int(inputs.num)\n    result = num * num\n    return Good(Outputs(squared_num=str(result)))\n</code></pre> <p><code>Res</code> and <code>Good</code> are imported from <code>m.core</code>. Each of the main entries need to return either a <code>Good</code> or <code>Bad</code> value. It is ok to raise exceptions to fail the step as well but <code>m</code> has been created using only <code>OneOf</code>s in order to avoid exceptions. The main reason behind this is so that mypy can help us catch errors by looking at a function signature.</p> <p>In this particular example we printed some message. This was done intentionally so that we can test that the action will print it.</p> <p>Each step may declare a wrapper function to facilitate the creation of the <code>actions</code> object. In this case all we want to import the <code>main_step</code> so we defined</p> <pre><code>def main_step(\n    step_id: str,\n    args: GithubInputs\n) -&gt; RunStep[GithubInputs, Outputs]:\n    \"\"\"Create a step to square the given number.\n\n    Args:\n        step_id: The id of the step.\n        inputs: The inputs to the step.\n\n    Returns:\n        A step to use in the action.\n    \"\"\"\n    return RunStep[GithubInputs, Outputs](id=step_id, run=main, args=args)\n</code></pre> <p>Note that with this we avoid having to import the <code>run</code> function and the outputs in the final <code>actions.py</code> file. This is a personal preference but we can do whatever we want as long as mypy and your linters allow it. The <code>RunStep</code> class can be imported from <code>m.github.actions</code>.</p> <p>The final step is to run it.</p> <pre><code>if __name__ == '__main__':\n    run_action(main)\n</code></pre> <p>The <code>run_action</code> function will take care of running the action and can be imported from <code>m.github.actions</code>. It makes sure to provide the inputs from the environment variables and to append the outputs to the file <code>$GITHUB_OUTPUT</code>. If there are any issues while running the <code>main</code> function it will display a message and exit with a non zero code so that Github may fail the run.</p>"},{"location":"github-actions/tutorial/#actionspy","title":"actions.py","text":"<p>It is time to put it all together. The <code>actions.py</code> file is the entry point that we use to generate the <code>actions.yaml</code> file.</p> <pre><code># src/pkg/actions.py\nfrom m.github.actions import Action\n\nfrom pkg.inputs import GithubInputs\nfrom pkg.main import main_step\n\nactions = Action(\n    name='Square Number',\n    description='Square the given number',\n    fle_path='action.yaml',\n    inputs=GithubInputs,\n    steps=[\n        main_step(step_id='square', args=GithubInputs(num='inputs.num')),\n    ]\n)\n</code></pre> <p>We could have defaulted the value of <code>file_path</code> but there can be several actions in a repo (see actions/cache) we need to be explicit about the file the action is meant to use. To create other actions we could have written</p> <pre><code>actions = [\n  Action(name='action 1', file_path='actions.yaml', ...),\n  Action(name='action 2', file_path='another_action/action.yaml', ...),\n]\n</code></pre> <p>At this point we can run <code>make action</code> and we should see the <code>action.yaml</code> file. We can also run <code>make mypy</code> to make sure that everything is working as expected. This already should give us confidence that we did not mess up writing the <code>action.yaml</code> file. The only thing that may go wrong is the implementation of the main function. The next step is write tests to make sure our code works.</p>"},{"location":"github-actions/tutorial/#testing","title":"Testing","text":"<p>One of the main pain points for developers is writing tests and setting things up. A nice thing about writing out actions the way we have done is that it makes it very easy to test. That is, we can write tests to show what happens with our functions with different inputs. We can verify that the outputs are written and are the expected values. We can also verify that that the text written to stdout and stderr satisfy certain conditions.</p> <p>The tests have been done in this commit.</p> <p>One requirement to run the tests is to have <code>pytest</code>, <code>pytest-mock</code> and <code>coverage</code> installed. <code>m</code> has some testing utilities that will make testing easier.</p>"},{"location":"github-actions/tutorial/#test_actionpy","title":"test_action.py","text":"<p>One of our goals is to obtain 100% coverage.</p> <pre><code>import pytest\nfrom m.github.actions import Action\nfrom m.testing import ActionStepTestCase as TCase\nfrom m.testing import run_action_test_case\nfrom pytest_mock import MockerFixture\n\nfrom pkg.actions import actions\n\n\n@pytest.mark.parametrize(\n    'tcase',\n    [\n        TCase(\n            name='square_number',\n            py_file=f'src/pkg/main.py',\n            inputs={'INPUT_NUM': '4'},\n            expected_stdout='Squaring the number\\n',\n            outputs=['squared-num=16'],\n        ),\n    ],\n    ids=lambda tcase: tcase.name,\n)\ndef test_m_gh_actions_api(tcase: TCase, mocker: MockerFixture) -&gt; None:\n    run_action_test_case(mocker, tcase)\n\n\ndef test_actions_instance() -&gt; None:\n    assert isinstance(actions, Action)\n    assert actions.name == 'Square Number'\n</code></pre> <p>This file has two tests. One tests the <code>main.py</code> file and the other tests the <code>actions.py</code> file. The <code>test_m_gh_actions_api</code> is a parametrized test that can run the step with different parameters. In this case we only run with <code>num</code> being <code>4</code> We need to provide all inputs with the <code>INPUT_</code> prefix. Here we can see that we are also testing the stdout and the outputs. Try changing any of those values to make sure that the test fails. The final test is simple to make sure that the <code>actions.py</code> file actually declares the <code>actions</code> object. If we had declared a list we could assert that the object is a list and that it has a certain length.</p> <p>Tip</p> <p>If the step had errors under certain inputs we could also verify that those errors are reported. We can do so by adding <code>errors</code> to the test case.</p> <pre><code>TCase(\n  ...,\n  errors=[\n    'some text in error',\n    'another text',\n  ],\n)\n</code></pre> <p>In this way if we ever change the error messages then the tests will fail.</p> <p>The <code>run.sh</code> file is a script that runs the tests. We won't go into details but this can be used during development by commenting out <code>SINGLE=false</code> so that only certain tests may run.</p>"},{"location":"github-actions/tutorial/#cicd","title":"CI/CD","text":"<p>This is out of scope for the tutorial but given if <code>make mypy</code> and <code>make actions</code> run without issues we can feel assured that the action will work as expected. What is left in the project is to use <code>m</code> to create releases and start using it.</p>"},{"location":"github-actions/tutorial/#example","title":"Example","text":"<p>In another project we can try out the action.</p> <pre><code>name: example-workflow\n\non:\n  push:\n    branches: [master]\n  pull_request:\n    branches: [master]\n\njobs:\n  setup:\n    runs-on: ubuntu-22.04\n    steps:\n      - name: install m\n        run: pip install git+https://github.com/jmlopez-rod/m.git@github-actions\n      - name: square\n        id: square\n        uses: jmlopez-rod/gha-square-num@master\n        with:\n          num: 5\n      - name: result\n        run: echo \"The square of 5 is ${{ steps.square.outputs.num-squared }}\"\n      - name: square-m\n        id: square-m\n        uses: jmlopez-rod/gha-square-num-m@master\n        with:\n          num: 25\n      - name: result\n        run:\n          echo \"The square of 25 is ${{ steps.square-m.outputs.squared-num }}\"\n</code></pre> <p>Note that we are using two different actions. One is the first action written in the motivation page and the other one is the one in this tutorial. The nice thing about this pattern is that the only failure when trying out the workflow was forgetting to have <code>m</code> installed. Other than that the action worked as expected.</p>"}]}