{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>The goal of <code>m</code> is to help maintain Github projects. This usually involves keeping a CHANGELOG, building, publishing and releasing packages. To achieve this, <code>m</code> comes with several utilities that can be used in the Github pipelines and on the developer's local environment.</p> <p>This process makes <code>m</code> to be opinionated. If the following points are acceptable by the project's maintainers then <code>m</code> may be a nice integration.</p>"},{"location":"#caveats","title":"Caveats","text":""},{"location":"#github-repositories","title":"Github repositories","text":"<p>All communication with repositories is done strictly with Github. <code>git</code> is used locally via <code>ssh</code> but any other user and pull request information is obtained via Github's APIs.</p> <p>Warning</p> <p>The git configuration should use <code>ssh</code> instead of <code>http</code>. This is done to avoid issues with the developers prefered git tool and/or user interface.</p> <pre><code>[remote \"origin\"]\n  url = git@github.com:&lt;owner&gt;/&lt;repo&gt;.git\n</code></pre>"},{"location":"#changelog","title":"Changelog","text":"<p>All projects are required to have a <code>CHANGELOG.md</code> file that follows the keep a changelog format. All a developer is required to do is to write/verify that a changelog entry.</p>"},{"location":"#versioning","title":"Versioning","text":"<p>A lot of projects in Github use tags of the form <code>v1.2.3</code>. Here we drop the <code>v</code> and simply use the semantic version when creating releases.</p>"},{"location":"#development-flows","title":"Development flows","text":"<p><code>m</code> currently supports three development flows: <code>free-flow</code>, <code>git-flow</code> and the <code>m-flow</code>. Depending on the flow chosen for the project a few extra setup is required on the Github repository's settings.</p>"},{"location":"install/","title":"Packaged versions","text":"<p>You can download it from the Python Package Index. For installation of packages from PyPI, try pip, it works on all major platforms.</p> <pre><code>pip install jmlopez-m\n</code></pre>"},{"location":"install/#compatibility","title":"Compatibility","text":"<p>Requires <code>python &gt;= 3.10</code>.</p>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>m<ul> <li>ci<ul> <li>assert_branch</li> <li>celt<ul> <li>core<ul> <li>io</li> <li>process</li> <li>types</li> </ul> </li> <li>post_processor</li> <li>post_processors<ul> <li>eslint</li> <li>pycodestyle</li> <li>pylint</li> <li>ruff</li> <li>typescript</li> </ul> </li> </ul> </li> <li>config</li> <li>docker<ul> <li>config</li> <li>docker_build</li> <li>env</li> <li>filenames</li> <li>gh_workflow_multi</li> <li>gh_workflow_single</li> <li>image</li> <li>shell_command</li> <li>shell_scripts</li> <li>tags</li> </ul> </li> <li>end_release</li> <li>git_env</li> <li>init</li> <li>m_blueprints</li> <li>m_env</li> <li>release_env</li> <li>release_setup</li> <li>release_utils</li> <li>review_release</li> <li>start_release</li> <li>types</li> <li>versioning</li> </ul> </li> <li>cli<ul> <li>args</li> <li>cli</li> <li>engine<ul> <li>argparse</li> <li>misc</li> <li>parsers<ul> <li>boolean</li> <li>positional</li> <li>proxy</li> <li>remainder</li> <li>standard</li> </ul> </li> <li>sys</li> <li>types</li> </ul> </li> <li>handlers</li> <li>validators</li> </ul> </li> <li>color<ul> <li>colors</li> <li>disable</li> <li>pygment</li> </ul> </li> <li>core<ul> <li>fp</li> <li>http</li> <li>io</li> <li>issue</li> <li>json</li> <li>maybe</li> <li>one_of</li> <li>rw</li> <li>subprocess</li> <li>types</li> <li>yaml</li> <li>yaml_fp</li> </ul> </li> <li>devcontainer<ul> <li>bashrc</li> <li>env</li> <li>greet</li> <li>pnpm</li> <li>prompter</li> </ul> </li> <li>git</li> <li>github<ul> <li>api</li> <li>ci</li> <li>ci_dataclasses</li> <li>ci_graph_queries</li> <li>cli</li> <li>graphql<ul> <li>api</li> <li>enums</li> <li>generics</li> <li>queries<ul> <li>branch_prs</li> </ul> </li> </ul> </li> <li>request</li> </ul> </li> <li>log<ul> <li>ci_tools<ul> <li>ci_tools</li> <li>providers<ul> <li>github</li> <li>local</li> <li>teamcity</li> </ul> </li> <li>types</li> </ul> </li> <li>config</li> <li>formatters</li> <li>handlers</li> <li>logger</li> <li>misc</li> </ul> </li> <li>npm<ul> <li>clean_tags</li> <li>cli</li> <li>tag</li> </ul> </li> <li>pydantic</li> <li>version</li> </ul> </li> </ul>"},{"location":"api/m/","title":"m","text":""},{"location":"api/m/git/","title":"git","text":""},{"location":"api/m/git/#m.git.checkout_branch","title":"<code>checkout_branch(branch, create=True)</code>","text":"<p>Checkout a branch.</p> <p>Parameters:</p> Name Type Description Default <code>branch</code> <code>str</code> <p>name of branch to checkout</p> required <code>create</code> <code>bool</code> <p>create new branch</p> <code>True</code> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> of the git response.</p> Source code in <code>m/git.py</code> <pre><code>def checkout_branch(branch: str, create: bool = True) -&gt; Res[str]:\n    \"\"\"Checkout a branch.\n\n    Args:\n        branch: name of branch to checkout\n        create: create new branch\n\n    Returns:\n        A `OneOf` containing an `Issue` of the git response.\n    \"\"\"\n    opt = '-b' if create else ''\n    res = subprocess.eval_cmd(f'git checkout {opt} {branch}')\n    return res.flat_map_bad(hone('git checkout failure'))\n</code></pre>"},{"location":"api/m/git/#m.git.commit","title":"<code>commit(msg)</code>","text":"<p>Create a commit.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>commit description.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from the git command.</p> Source code in <code>m/git.py</code> <pre><code>def commit(msg: str) -&gt; Res[str]:\n    \"\"\"Create a commit.\n\n    Args:\n        msg: commit description.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from the git command.\n    \"\"\"\n    res = subprocess.eval_cmd(f'git commit -m \"{msg}\"')\n    return res.flat_map_bad(hone('git commit failure'))\n</code></pre>"},{"location":"api/m/git/#m.git.get_branch","title":"<code>get_branch()</code>","text":"<p>Get the current git branch name.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a string specifying the branch.</p> Source code in <code>m/git.py</code> <pre><code>def get_branch() -&gt; Res[str]:\n    \"\"\"Get the current git branch name.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a string specifying the branch.\n    \"\"\"\n    return subprocess.eval_cmd('git rev-parse --abbrev-ref HEAD')\n</code></pre>"},{"location":"api/m/git/#m.git.get_commits","title":"<code>get_commits(first, latest='HEAD')</code>","text":"<p>Get a list of all the commits between two tags.</p> <p>May return <code>None</code> in the special case when <code>first</code> is <code>0.0.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>first</code> <code>str</code> <p>The first tag.</p> required <code>latest</code> <code>str</code> <p>The second tag, defaults to HEAD.</p> <code>'HEAD'</code> <p>Returns:</p> Type Description <code>Res[list[str] | None]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of all the commits.</p> Source code in <code>m/git.py</code> <pre><code>def get_commits(\n    first: str,\n    latest: str = 'HEAD',\n) -&gt; Res[list[str] | None]:\n    \"\"\"Get a list of all the commits between two tags.\n\n    May return `None` in the special case when `first` is `0.0.0`.\n\n    Args:\n        first: The first tag.\n        latest: The second tag, defaults to HEAD.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of all the commits.\n    \"\"\"\n    if first == '0.0.0':\n        return Good(None)\n    cmd = f'git log {latest}...{first} --oneline --no-color'\n    return subprocess.eval_cmd(cmd).map(lambda out: out.splitlines())\n</code></pre>"},{"location":"api/m/git/#m.git.get_current_commit_sha","title":"<code>get_current_commit_sha()</code>","text":"<p>Find the sha of the current commit.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a string of the current commit sha.</p> Source code in <code>m/git.py</code> <pre><code>def get_current_commit_sha() -&gt; Res[str]:\n    \"\"\"Find the sha of the current commit.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a string of the current commit sha.\n    \"\"\"\n    return subprocess.eval_cmd('git rev-parse HEAD')\n</code></pre>"},{"location":"api/m/git/#m.git.get_first_commit_sha","title":"<code>get_first_commit_sha()</code>","text":"<p>Find the first commit sha in the repository.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a string of the first commit sha.</p> Source code in <code>m/git.py</code> <pre><code>def get_first_commit_sha() -&gt; Res[str]:\n    \"\"\"Find the first commit sha in the repository.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a string of the first commit sha.\n    \"\"\"\n    return subprocess.eval_cmd('git rev-list --max-parents=0 HEAD')\n</code></pre>"},{"location":"api/m/git/#m.git.get_remote_url","title":"<code>get_remote_url()</code>","text":"<p>Find the remote url of the repo.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a string with the url.</p> Source code in <code>m/git.py</code> <pre><code>def get_remote_url() -&gt; Res[str]:\n    \"\"\"Find the remote url of the repo.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a string with the url.\n    \"\"\"\n    return subprocess.eval_cmd('git config --get remote.origin.url')\n</code></pre>"},{"location":"api/m/git/#m.git.get_repo_path","title":"<code>get_repo_path()</code>","text":"<p>Get the absolute path to the repository.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>An issue or a string of the path to the repo.</p> Source code in <code>m/git.py</code> <pre><code>def get_repo_path() -&gt; Res[str]:\n    \"\"\"Get the absolute path to the repository.\n\n    Returns:\n        An issue or a string of the path to the repo.\n    \"\"\"\n    return subprocess.eval_cmd('git rev-parse --show-toplevel')\n</code></pre>"},{"location":"api/m/git/#m.git.get_status","title":"<code>get_status(*, check_stash=False)</code>","text":"<p>Find the current git status.</p> <p>Note that checking for stashed changes is not part of the regular git status. To opt in you must set <code>check_stash=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>check_stash</code> <code>bool</code> <p>Check if there are any stashed changes.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[tuple[str, str]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a word denoting the git status.</p> Source code in <code>m/git.py</code> <pre><code>def get_status(*, check_stash: bool = False) -&gt; Res[tuple[str, str]]:\n    \"\"\"Find the current git status.\n\n    Note that checking for stashed changes is not part of the regular git\n    status. To opt in you must set `check_stash=True`.\n\n    Args:\n        check_stash: Check if there are any stashed changes.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a word denoting the git status.\n    \"\"\"\n    res = subprocess.eval_cmd('git status')\n    if check_stash:\n        stash_files = subprocess.eval_cmd('git stash show').get_or_else('')\n        has_untracked = res.get_or_else('').startswith('Untracked files')\n        if not has_untracked and stash_files:\n            return Good(('stash', 'stash'))\n    return one_of(\n        lambda: [\n            _extract_status(msg)\n            for msg in res\n        ],\n    )\n</code></pre>"},{"location":"api/m/git/#m.git.list_tags","title":"<code>list_tags(pattern)</code>","text":"<p>List all the tags matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>The pattern to match.</p> required <p>Returns:</p> Type Description <code>Res[dict[str, str]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a string specifying the branch.</p> Source code in <code>m/git.py</code> <pre><code>def list_tags(pattern: str) -&gt; Res[dict[str, str]]:\n    \"\"\"List all the tags matching a pattern.\n\n    Args:\n        pattern: The pattern to match.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a string specifying the branch.\n    \"\"\"\n    cmd = f'git ls-remote --tags origin -l \"{pattern}\"'\n    return one_of(\n        lambda: [\n            _list_tags(output)\n            for output in subprocess.eval_cmd(cmd)\n        ],\n    )\n</code></pre>"},{"location":"api/m/git/#m.git.push_branch","title":"<code>push_branch(branch)</code>","text":"<p>Push branch.</p> <p>Parameters:</p> Name Type Description Default <code>branch</code> <code>str</code> <p>name of branch to push.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from the command.</p> Source code in <code>m/git.py</code> <pre><code>def push_branch(branch: str) -&gt; Res[str]:\n    \"\"\"Push branch.\n\n    Args:\n        branch: name of branch to push.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from the command.\n    \"\"\"\n    res = subprocess.eval_cmd(f'git push -u origin \"{branch}\"')\n    return res.flat_map_bad(hone('git push failure'))\n</code></pre>"},{"location":"api/m/git/#m.git.raw_status","title":"<code>raw_status()</code>","text":"<p>Obtain the output of \"git status\".</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the output of \"git status\".</p> Source code in <code>m/git.py</code> <pre><code>def raw_status() -&gt; Res[str]:\n    \"\"\"Obtain the output of \"git status\".\n\n    Returns:\n        A `OneOf` containing an `Issue` or the output of \"git status\".\n    \"\"\"\n    return subprocess.eval_cmd('git status')\n</code></pre>"},{"location":"api/m/git/#m.git.remove_git_tag","title":"<code>remove_git_tag(tag)</code>","text":"<p>Remove a git tag.</p> <p>It is important to remove the local tag before removing the remote tag.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The tag to remove.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from the git command.</p> Source code in <code>m/git.py</code> <pre><code>def remove_git_tag(tag: str) -&gt; Res[str]:\n    \"\"\"Remove a git tag.\n\n    It is important to remove the local tag before removing the remote tag.\n\n    Args:\n        tag: The tag to remove.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from the git command.\n    \"\"\"\n    tag_ref = f'refs/tags/{tag}'\n    return one_of(lambda: [\n        f'{local}\\n{remote}'\n        for _ in subprocess.eval_cmd(f'git fetch origin +{tag_ref}:{tag_ref}')\n        for local in subprocess.eval_cmd(f'git tag -d {tag}')\n        for remote in subprocess.eval_cmd(f'git push origin :{tag_ref}')\n    ])\n</code></pre>"},{"location":"api/m/git/#m.git.stage_all","title":"<code>stage_all()</code>","text":"<p>Stage the current changes in the branch.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from <code>git add .</code>.</p> Source code in <code>m/git.py</code> <pre><code>def stage_all() -&gt; Res[str]:\n    \"\"\"Stage the current changes in the branch.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from `git add .`.\n    \"\"\"\n    res = subprocess.eval_cmd('git add .')\n    return res.flat_map_bad(hone('git add failure'))\n</code></pre>"},{"location":"api/m/git/#m.git.stash","title":"<code>stash()</code>","text":"<p>Stash the current changes in the branch.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from <code>git stash</code>.</p> Source code in <code>m/git.py</code> <pre><code>def stash() -&gt; Res[str]:\n    \"\"\"Stash the current changes in the branch.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from `git stash`.\n    \"\"\"\n    return subprocess.eval_cmd('git stash')\n</code></pre>"},{"location":"api/m/git/#m.git.stash_pop","title":"<code>stash_pop()</code>","text":"<p>Pop the changes stored in the git stash.</p> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from <code>git stash pop</code>.</p> Source code in <code>m/git.py</code> <pre><code>def stash_pop() -&gt; Res[str]:\n    \"\"\"Pop the changes stored in the git stash.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from `git stash pop`.\n    \"\"\"\n    return subprocess.eval_cmd('git stash pop')\n</code></pre>"},{"location":"api/m/git/#m.git.tag_release","title":"<code>tag_release(version, sha, *, major_only)</code>","text":"<p>Create a git tags for a release.</p> <p>This is done to keep a major and minor versions tags pointing to the latest.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>The version to tag.</p> required <code>sha</code> <code>str</code> <p>The commit sha to tag.</p> required <code>major_only</code> <code>bool</code> <p>Only create the major tag.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from the git command.</p> Source code in <code>m/git.py</code> <pre><code>def tag_release(version: str, sha: str, *, major_only: bool) -&gt; Res[str]:\n    \"\"\"Create a git tags for a release.\n\n    This is done to keep a major and minor versions tags pointing to the latest.\n\n    Args:\n        version: The version to tag.\n        sha: The commit sha to tag.\n        major_only: Only create the major tag.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from the git command.\n    \"\"\"\n    v_parts = version.split('.')\n    # Assuming the version is valid\n    major, minor = v_parts[0], v_parts[1]\n    major_tag = f'v{major}'\n    minor_tag = f'v{major}.{minor}'\n\n    return one_of(lambda: [\n        '\\n'.join([major_out, minor_out])\n        for all_tags in list_tags(f'v{major}*')\n        for major_out in update_git_tag(major_tag, sha, list(all_tags))\n        for minor_out in update_git_tag(\n            minor_tag,\n            sha,\n            list(all_tags),\n            skip=major_only,\n        )\n    ])\n</code></pre>"},{"location":"api/m/git/#m.git.update_git_tag","title":"<code>update_git_tag(tag, sha, remote_tags, *, skip=False)</code>","text":"<p>Create or move a git tag.</p> <p>The remote_tags should be provided to determine if we need to remove them before moving the tag. See https://stackoverflow.com/a/28280404 for more details on the git commands.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The tag to set.</p> required <code>sha</code> <code>str</code> <p>The commit sha to set the tag to.</p> required <code>remote_tags</code> <code>list[str]</code> <p>The list of remote tags.</p> required <code>skip</code> <code>bool</code> <p>Skip process if set to true.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the response from the git command.</p> Source code in <code>m/git.py</code> <pre><code>def update_git_tag(\n    tag: str,\n    sha: str,\n    remote_tags: list[str],\n    *,\n    skip: bool = False,\n) -&gt; Res[str]:\n    \"\"\"Create or move a git tag.\n\n    The remote_tags should be provided to determine if we need to remove them\n    before moving the tag. See https://stackoverflow.com/a/28280404 for more\n    details on the git commands.\n\n    Args:\n        tag: The tag to set.\n        sha: The commit sha to set the tag to.\n        remote_tags: The list of remote tags.\n        skip: Skip process if set to true.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the response from the git command.\n    \"\"\"\n    if skip:\n        return Good(f'skipping {tag}')\n    removal_output = ''\n    if tag in remote_tags:\n        removal_res = remove_git_tag(tag)\n        if isinstance(removal_res, Bad):\n            return Bad(removal_res.value)\n        removal_output = f'{removal_res.value}\\n'\n    return one_of(lambda: [\n        f'{removal_output}{local}\\n{remote}'\n        for local in subprocess.eval_cmd(f'git tag {tag} {sha}')\n        for remote in subprocess.eval_cmd(f'git push origin {tag}')\n    ])\n</code></pre>"},{"location":"api/m/pydantic/","title":"pydantic","text":""},{"location":"api/m/pydantic/#m.pydantic.CamelModel","title":"<code>CamelModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Allows models to be defined with camel case properties.</p> See <p>https://medium.com/analytics-vidhya/camel-case-models-with-fast-api-and-pydantic-5a8acb6c0eee</p> <p>Attributes:</p> Source code in <code>m/pydantic.py</code> <pre><code>class CamelModel(BaseModel):\n    \"\"\"Allows models to be defined with camel case properties.\n\n    See:\n        https://medium.com/analytics-vidhya/camel-case-models-with-fast-api-and-pydantic-5a8acb6c0eee\n    \"\"\"\n\n    model_config = ConfigDict(\n        alias_generator=to_camel,\n        populate_by_name=True,\n    )\n</code></pre>"},{"location":"api/m/pydantic/#m.pydantic.load_model","title":"<code>load_model(model, file_path, transform=None)</code>","text":"<p>Load a model from a json or yaml file.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[GenericModel]</code> <p>The class to create an instance of.</p> required <code>file_path</code> <code>str</code> <p>The path to the file.</p> required <code>transform</code> <code>DataTransformer | None</code> <p>A function to transform the data before creating the model.</p> <code>None</code> <p>Returns:</p> Type Description <code>Res[GenericModel]</code> <p>A <code>OneOf</code> with the model or an issue.</p> Source code in <code>m/pydantic.py</code> <pre><code>def load_model(\n    model: type[GenericModel],\n    file_path: str,\n    transform: DataTransformer | None = None,\n) -&gt; Res[GenericModel]:\n    \"\"\"Load a model from a json or yaml file.\n\n    Args:\n        model: The class to create an instance of.\n        file_path: The path to the file.\n        transform: A function to transform the data before creating the model.\n\n    Returns:\n        A `OneOf` with the model or an issue.\n    \"\"\"\n    context = {'file_path': file_path, 'model': str(model)}\n    transform_function = transform or Good\n    return one_of(\n        lambda: [\n            model_inst\n            for _ in assert_file_exists(file_path)\n            for model_data in read_yson(file_path)\n            for transformed_data in transform_function(model_data)\n            for model_inst in parse_model(model, transformed_data)\n        ],\n    ).flat_map_bad(hone('pydantic.load_model_failure', context))\n</code></pre>"},{"location":"api/m/pydantic/#m.pydantic.parse_model","title":"<code>parse_model(model, model_data)</code>","text":"<p>Parse a python object using pydantics TypeAdapter.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[GenericModel]</code> <p>The class to create an instance of.</p> required <code>model_data</code> <code>Any</code> <p>The data to parse.</p> required <p>Returns:</p> Type Description <code>Res[GenericModel]</code> <p>A <code>OneOf</code> with the model or an issue.</p> Source code in <code>m/pydantic.py</code> <pre><code>def parse_model(model: type[GenericModel], model_data: Any) -&gt; Res[GenericModel]:\n    \"\"\"Parse a python object using pydantics TypeAdapter.\n\n    Args:\n        model: The class to create an instance of.\n        model_data: The data to parse.\n\n    Returns:\n        A `OneOf` with the model or an issue.\n    \"\"\"\n    try:\n        return Good(TypeAdapter(model).validate_python(model_data))\n    except Exception as ex:\n        return issue('parse_model_failure', cause=ex)\n</code></pre>"},{"location":"api/m/pydantic/#m.pydantic.to_camel","title":"<code>to_camel(snake_case)</code>","text":"<p>Transform a string in snake_case to camel case.</p> <p>Parameters:</p> Name Type Description Default <code>snake_case</code> <code>str</code> <p>string in snake case.</p> required <p>Returns:</p> Type Description <code>str</code> <p>string in camel case.</p> Source code in <code>m/pydantic.py</code> <pre><code>def to_camel(snake_case: str) -&gt; str:\n    \"\"\"Transform a string in snake_case to camel case.\n\n    Args:\n        snake_case: string in snake case.\n\n    Returns:\n        string in camel case.\n    \"\"\"\n    s = sub('(_|-)+', ' ', snake_case).title().replace(' ', '')\n    return ''.join([s[0].lower(), s[1:]])\n</code></pre>"},{"location":"api/m/version/","title":"version","text":""},{"location":"api/m/ci/","title":"ci","text":""},{"location":"api/m/ci/assert_branch/","title":"assert_branch","text":""},{"location":"api/m/ci/assert_branch/#m.ci.assert_branch.assert_branch","title":"<code>assert_branch(assertion_type, m_dir)</code>","text":"<p>Make sure git is using the correct branch based on the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>assertion_type</code> <code>str</code> <p>Either 'release' or 'hotfix'.</p> required <code>m_dir</code> <code>str</code> <p>The directory for the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[Config]</code> <p>A OneOf containing <code>None</code> or an <code>Issue</code>.</p> Source code in <code>m/ci/assert_branch.py</code> <pre><code>def assert_branch(assertion_type: str, m_dir: str) -&gt; Res[Config]:\n    \"\"\"Make sure git is using the correct branch based on the workflow.\n\n    Args:\n        assertion_type:\n            Either 'release' or 'hotfix'.\n        m_dir:\n            The directory for the m configuration.\n\n    Returns:\n        A OneOf containing `None` or an `Issue`.\n    \"\"\"\n    return one_of(lambda: [\n        config\n        for config in cfg_mod.read_config(m_dir)\n        for branch in git.get_branch()\n        for _ in _verify_branch(config, branch, assertion_type)\n    ])\n</code></pre>"},{"location":"api/m/ci/config/","title":"config","text":""},{"location":"api/m/ci/config/#m.ci.config.Config","title":"<code>Config</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Object to store the m project configuration.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <code>str</code> <p>...</p> <code>owner</code> <code>str</code> <p>...</p> <code>repo</code> <code>str</code> <p>...</p> <code>version</code> <code>str</code> <p>...</p> <code>workflow</code> <code>Workflow</code> <p>...</p> <code>git_flow</code> <code>GitFlowConfig</code> <p>...</p> <code>m_flow</code> <code>MFlowConfig</code> <p>...</p> <code>build_tag_with_version</code> <code>bool</code> <p>...</p> <code>docker_config</code> <code>DockerConfig | None</code> <p>...</p> Source code in <code>m/ci/config.py</code> <pre><code>class Config(BaseModel):\n    \"\"\"Object to store the m project configuration.\"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    m_dir: str\n    owner: str\n    repo: str\n    version: str = '0.0.0'\n    workflow: Workflow = Workflow.free_flow\n    git_flow: GitFlowConfig = GitFlowConfig(\n        master_branch=Branches.master,\n        develop_branch=Branches.develop,\n        release_prefix=Branches.release,\n        hotfix_prefix=Branches.hotfix,\n    )\n    m_flow: MFlowConfig = MFlowConfig(\n        master_branch=Branches.master,\n        release_prefix=Branches.release,\n        hotfix_prefix=Branches.hotfix,\n    )\n    build_tag_with_version: bool = False\n    docker_config: DockerConfig | None = None\n\n    model_config = ConfigDict(use_enum_values=True)\n\n    def uses_git_flow(self) -&gt; bool:\n        \"\"\"Check if configuration is using the git flow.\n\n        Returns:\n            True if workflow is the git flow.\n        \"\"\"\n        return self.workflow == Workflow.git_flow\n\n    def uses_m_flow(self) -&gt; bool:\n        \"\"\"Check if configuration is using the m flow.\n\n        Returns:\n            True if workflow is the m flow.\n        \"\"\"\n        return self.workflow == Workflow.m_flow\n\n    def uses_free_flow(self) -&gt; bool:\n        \"\"\"Check if configuration is using the free flow.\n\n        Returns:\n            True if workflow is the free flow.\n        \"\"\"\n        return self.workflow == Workflow.free_flow\n\n    def get_master_branch(self) -&gt; str:\n        \"\"\"Obtain the name of the branch that aliases the \"master\" branch.\n\n        Returns:\n            The name/alias assigned to the `master` branch.\n        \"\"\"\n        if self.uses_m_flow():\n            return self.m_flow.master_branch\n        if self.uses_git_flow():\n            return self.git_flow.master_branch\n        return 'master'\n\n    def get_develop_branch(self) -&gt; str:\n        \"\"\"Obtain the name of the branch that aliases the \"develop\" branch.\n\n        Returns:\n            The name/alias assigned to the `develop` branch.\n        \"\"\"\n        if self.uses_git_flow():\n            return self.git_flow.develop_branch\n        return 'develop'\n\n    def get_default_branch(self) -&gt; str:\n        \"\"\"Obtain the name of the branch that aliases the \"default\" branch.\n\n        This is dependent on the flow. For instance, in the git flow we\n        use the `develop` branch as default.\n\n        Returns:\n            The name/alias assigned to the default branch.\n        \"\"\"\n        if self.uses_m_flow():\n            return self.m_flow.master_branch\n        if self.uses_git_flow():\n            return self.git_flow.develop_branch\n        return 'master'\n\n    def verify_version(\n        self,\n        gh_latest: str,\n        is_release_pr: bool,\n        is_release: bool,\n    ) -&gt; Res[int]:\n        \"\"\"Verify that the configuration version is valid.\n\n        Args:\n            gh_latest:\n                The version stored in `Github`. Checks are skipped if\n                this value is empty.\n            is_release_pr:\n                Set to `True` if the build is done during a release pr.\n            is_release:\n                Set to `True` if the build is done during a release.\n\n        Returns:\n            A `OneOf` containing 0 if all is well, otherwise an `Issue`.\n        \"\"\"\n        if not gh_latest:\n            return Good(0)\n        err_data = {\n            'config_version': self.version,\n            'gh_latest': gh_latest,\n            'is_release': is_release,\n            'is_release_pr': is_release_pr,\n        }\n        try:\n            p_ver = Version(self.version)\n        except Exception as ex:\n            return issue('error parsing version', cause=ex, context=err_data)\n        try:\n            p_latest = Version(gh_latest)\n        except Exception as ex:  # noqa: WPS440\n            return issue('error parsing latest', cause=ex, context=err_data)\n        ver_gt_latest = p_ver &gt; p_latest\n        ver_lt_latest = p_ver &lt; p_latest\n        msg: str = ''\n        if is_release_pr:\n            msg = _handle_release_pr(ver_gt_latest)\n        elif is_release:\n            msg = _handle_release(ver_gt_latest)\n        else:\n            msg = _handle_non_release(ver_lt_latest, ver_gt_latest)\n        return issue(msg, context=err_data) if msg else Good(0)\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.get_default_branch","title":"<code>get_default_branch()</code>","text":"<p>Obtain the name of the branch that aliases the \"default\" branch.</p> <p>This is dependent on the flow. For instance, in the git flow we use the <code>develop</code> branch as default.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name/alias assigned to the default branch.</p> Source code in <code>m/ci/config.py</code> <pre><code>def get_default_branch(self) -&gt; str:\n    \"\"\"Obtain the name of the branch that aliases the \"default\" branch.\n\n    This is dependent on the flow. For instance, in the git flow we\n    use the `develop` branch as default.\n\n    Returns:\n        The name/alias assigned to the default branch.\n    \"\"\"\n    if self.uses_m_flow():\n        return self.m_flow.master_branch\n    if self.uses_git_flow():\n        return self.git_flow.develop_branch\n    return 'master'\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.get_develop_branch","title":"<code>get_develop_branch()</code>","text":"<p>Obtain the name of the branch that aliases the \"develop\" branch.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name/alias assigned to the <code>develop</code> branch.</p> Source code in <code>m/ci/config.py</code> <pre><code>def get_develop_branch(self) -&gt; str:\n    \"\"\"Obtain the name of the branch that aliases the \"develop\" branch.\n\n    Returns:\n        The name/alias assigned to the `develop` branch.\n    \"\"\"\n    if self.uses_git_flow():\n        return self.git_flow.develop_branch\n    return 'develop'\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.get_master_branch","title":"<code>get_master_branch()</code>","text":"<p>Obtain the name of the branch that aliases the \"master\" branch.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name/alias assigned to the <code>master</code> branch.</p> Source code in <code>m/ci/config.py</code> <pre><code>def get_master_branch(self) -&gt; str:\n    \"\"\"Obtain the name of the branch that aliases the \"master\" branch.\n\n    Returns:\n        The name/alias assigned to the `master` branch.\n    \"\"\"\n    if self.uses_m_flow():\n        return self.m_flow.master_branch\n    if self.uses_git_flow():\n        return self.git_flow.master_branch\n    return 'master'\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.uses_free_flow","title":"<code>uses_free_flow()</code>","text":"<p>Check if configuration is using the free flow.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if workflow is the free flow.</p> Source code in <code>m/ci/config.py</code> <pre><code>def uses_free_flow(self) -&gt; bool:\n    \"\"\"Check if configuration is using the free flow.\n\n    Returns:\n        True if workflow is the free flow.\n    \"\"\"\n    return self.workflow == Workflow.free_flow\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.uses_git_flow","title":"<code>uses_git_flow()</code>","text":"<p>Check if configuration is using the git flow.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if workflow is the git flow.</p> Source code in <code>m/ci/config.py</code> <pre><code>def uses_git_flow(self) -&gt; bool:\n    \"\"\"Check if configuration is using the git flow.\n\n    Returns:\n        True if workflow is the git flow.\n    \"\"\"\n    return self.workflow == Workflow.git_flow\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.uses_m_flow","title":"<code>uses_m_flow()</code>","text":"<p>Check if configuration is using the m flow.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if workflow is the m flow.</p> Source code in <code>m/ci/config.py</code> <pre><code>def uses_m_flow(self) -&gt; bool:\n    \"\"\"Check if configuration is using the m flow.\n\n    Returns:\n        True if workflow is the m flow.\n    \"\"\"\n    return self.workflow == Workflow.m_flow\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.Config.verify_version","title":"<code>verify_version(gh_latest, is_release_pr, is_release)</code>","text":"<p>Verify that the configuration version is valid.</p> <p>Parameters:</p> Name Type Description Default <code>gh_latest</code> <code>str</code> <p>The version stored in <code>Github</code>. Checks are skipped if this value is empty.</p> required <code>is_release_pr</code> <code>bool</code> <p>Set to <code>True</code> if the build is done during a release pr.</p> required <code>is_release</code> <code>bool</code> <p>Set to <code>True</code> if the build is done during a release.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>A <code>OneOf</code> containing 0 if all is well, otherwise an <code>Issue</code>.</p> Source code in <code>m/ci/config.py</code> <pre><code>def verify_version(\n    self,\n    gh_latest: str,\n    is_release_pr: bool,\n    is_release: bool,\n) -&gt; Res[int]:\n    \"\"\"Verify that the configuration version is valid.\n\n    Args:\n        gh_latest:\n            The version stored in `Github`. Checks are skipped if\n            this value is empty.\n        is_release_pr:\n            Set to `True` if the build is done during a release pr.\n        is_release:\n            Set to `True` if the build is done during a release.\n\n    Returns:\n        A `OneOf` containing 0 if all is well, otherwise an `Issue`.\n    \"\"\"\n    if not gh_latest:\n        return Good(0)\n    err_data = {\n        'config_version': self.version,\n        'gh_latest': gh_latest,\n        'is_release': is_release,\n        'is_release_pr': is_release_pr,\n    }\n    try:\n        p_ver = Version(self.version)\n    except Exception as ex:\n        return issue('error parsing version', cause=ex, context=err_data)\n    try:\n        p_latest = Version(gh_latest)\n    except Exception as ex:  # noqa: WPS440\n        return issue('error parsing latest', cause=ex, context=err_data)\n    ver_gt_latest = p_ver &gt; p_latest\n    ver_lt_latest = p_ver &lt; p_latest\n    msg: str = ''\n    if is_release_pr:\n        msg = _handle_release_pr(ver_gt_latest)\n    elif is_release:\n        msg = _handle_release(ver_gt_latest)\n    else:\n        msg = _handle_non_release(ver_lt_latest, ver_gt_latest)\n    return issue(msg, context=err_data) if msg else Good(0)\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.get_m_filename","title":"<code>get_m_filename(m_dir)</code>","text":"<p>Obtain the path to the m configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory with the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>The name of the configuration file or an issue if it doesn't exist.</p> Source code in <code>m/ci/config.py</code> <pre><code>def get_m_filename(m_dir: str) -&gt; Res[str]:\n    \"\"\"Obtain the path to the m configuration file.\n\n    Args:\n        m_dir: The directory with the m configuration.\n\n    Returns:\n        The name of the configuration file or an issue if it doesn't exist.\n    \"\"\"\n    filenames = (f'{m_dir}/m.yaml', f'{m_dir}/m.yml', f'{m_dir}/m.json')\n    for filename in filenames:\n        if Path(filename).exists():\n            return Good(filename)\n    return issue('m_file not found', context={\n        'm_dir': m_dir,\n        'valid_m_files': filenames,\n    })\n</code></pre>"},{"location":"api/m/ci/config/#m.ci.config.read_config","title":"<code>read_config(m_dir)</code>","text":"<p>Read an m configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>Directory containing <code>m.json</code>.</p> required <p>Returns:</p> Type Description <code>Res[Config]</code> <p>A <code>OneOf</code> containing the <code>m</code> configuration or an <code>Issue</code>.</p> Source code in <code>m/ci/config.py</code> <pre><code>def read_config(m_dir: str) -&gt; Res[Config]:\n    \"\"\"Read an m configuration file.\n\n    Args:\n        m_dir: Directory containing `m.json`.\n\n    Returns:\n        A `OneOf` containing the `m` configuration or an `Issue`.\n    \"\"\"\n    return one_of(lambda: [\n        Config(m_dir=m_dir, **m_cfg)\n        for m_filename in get_m_filename(m_dir)\n        for m_cfg in yaml_fp.read_yson(m_filename)\n    ]).flat_map_bad(hone('read_config failure'))\n</code></pre>"},{"location":"api/m/ci/end_release/","title":"end_release","text":""},{"location":"api/m/ci/end_release/#m.ci.end_release.end_release","title":"<code>end_release(gh_token)</code>","text":"<p>End the release process.</p> <p>Parameters:</p> Name Type Description Default <code>gh_token</code> <code>str</code> <p>The GITHUB_TOKEN to use to make api calls to Github.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, otherwise an issue.</p> Source code in <code>m/ci/end_release.py</code> <pre><code>def end_release(gh_token: str) -&gt; Res[None]:\n    \"\"\"End the release process.\n\n    Args:\n        gh_token: The GITHUB_TOKEN to use to make api calls to Github.\n\n    Returns:\n        None if successful, otherwise an issue.\n    \"\"\"\n    return one_of(lambda: [\n        None\n        for branch in git.get_branch()\n        for _, target_ver in assert_branch(branch, 'end')\n        for config in read_config('m')\n        for prs in fetch_branch_prs(\n            gh_token,\n            config.owner,\n            config.repo,\n            branch,\n        )\n        for _ in inspect_prs(prs)\n        for _ in merge_prs(gh_token, config, prs, target_ver)\n        for default_branch in Good[Issue, str](config.get_default_branch())\n        for checkout in git.checkout_branch(default_branch, create=False)\n        for _ in _switch_branch(default_branch, checkout)\n    ])\n</code></pre>"},{"location":"api/m/ci/end_release/#m.ci.end_release.inspect_prs","title":"<code>inspect_prs(prs)</code>","text":"<p>Inspect the release pull requests.</p> <p>Attempts to warn the users of possible issues that may be encountered.</p> <p>Parameters:</p> Name Type Description Default <code>prs</code> <code>list[PullRequest]</code> <p>The list of pull requests to merge.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue if the user decides to cancel, None otherwise.</p> Source code in <code>m/ci/end_release.py</code> <pre><code>def inspect_prs(prs: list[PullRequest]) -&gt; Res[None]:\n    \"\"\"Inspect the release pull requests.\n\n    Attempts to warn the users of possible issues that may be encountered.\n\n    Args:\n        prs: The list of pull requests to merge.\n\n    Returns:\n        An issue if the user decides to cancel, None otherwise.\n    \"\"\"\n    if not prs:\n        return issue('no prs associated with the release/hotfix branch')\n    conflicting = [\n        pr\n        for pr in prs\n        if pr.mergeable == MergeableState.conflicting\n    ]\n    if conflicting:\n        return issue('found conflicting prs', context={\n            'prs': {pr.number: pr.url for pr in conflicting},\n            'suggestion': 'check out the pull requests',\n        })\n    # Nice to have: handle code reviews - warn if there are requested changes\n    # To introduce this we need to prompt the user if we should proceed to\n    # merge the pr even when there are pending reviews. This is mainly\n    # done for admins that may be able to merge without approvals.\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/end_release/#m.ci.end_release.merge_prs","title":"<code>merge_prs(gh_token, config, prs, target_ver)</code>","text":"<p>Merge the given prs.</p> <p>Parameters:</p> Name Type Description Default <code>gh_token</code> <code>str</code> <p>The GITHUB_TOKEN to use to make api calls to Github.</p> required <code>config</code> <code>Config</code> <p>The m configuration.</p> required <code>prs</code> <code>list[PullRequest]</code> <p>The pull requests to merge.</p> required <code>target_ver</code> <code>str</code> <p>The version to release.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue if there is a problem while merging or None if successful.</p> Source code in <code>m/ci/end_release.py</code> <pre><code>def merge_prs(\n    gh_token: str,\n    config: Config,\n    prs: list[PullRequest],\n    target_ver: str,\n) -&gt; Res[None]:\n    \"\"\"Merge the given prs.\n\n    Args:\n        gh_token: The GITHUB_TOKEN to use to make api calls to Github.\n        config: The m configuration.\n        prs: The pull requests to merge.\n        target_ver: The version to release.\n\n    Returns:\n        An issue if there is a problem while merging or None if successful.\n    \"\"\"\n    master_branch = config.get_master_branch()\n    first_index = 0 if prs[0].base_ref_name == master_branch else 1\n    second_index = 0 if first_index == 1 else 1\n    first_pr = prs[first_index]\n    second_pr = None\n    if len(prs) == 2:\n        second_pr = prs[second_index]\n\n    first_merged_result: Res[None]\n    if first_pr.merged or first_pr.closed:\n        msg = f'{master_branch} branch pr already merged/closed'\n        logger.warning(msg, context={\n            'pr_info': first_pr.model_dump(),\n        })\n        first_merged_result = Good(None)\n    else:\n        msg = f'merged pr{first_pr.number} to {master_branch}'\n        first_merged_result = merge_pr(\n            gh_token,\n            config.owner,\n            config.repo,\n            first_pr.number,\n            None,\n        ).map(lambda res: logger.info(msg, res)).map(lambda _: None)\n\n    return one_of(lambda: [\n        None\n        for _ in first_merged_result\n        for _ in _merge_second_pr(gh_token, config, second_pr, target_ver)\n    ])\n</code></pre>"},{"location":"api/m/ci/end_release/#m.ci.end_release.wait_until","title":"<code>wait_until(predicate)</code>","text":"<p>Sleep until the predicate function returns False.</p> <p>Will print a <code>.</code> (dot) every 10 seconds thus every 6 dots denote a minute.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[], Res[bool]]</code> <p>function returning an Issue or a boolean</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue or None.</p> Source code in <code>m/ci/end_release.py</code> <pre><code>def wait_until(\n    predicate: Callable[[], Res[bool]],\n) -&gt; Res[None]:\n    \"\"\"Sleep until the predicate function returns False.\n\n    Will print a `.` (dot) every 10 seconds thus every 6 dots\n    denote a minute.\n\n    Args:\n        predicate: function returning an Issue or a boolean\n\n    Returns:\n        An issue or None.\n    \"\"\"\n    should_loop = predicate()\n    counter = 0\n    indent = '       '\n    sys.stdout.write(indent)\n    while not should_loop.is_bad and should_loop.value is True:\n        time.sleep(10)\n        counter += 1\n        modifier = ''\n        if counter % 6 == 0:\n            modifier = '    '\n        if counter % _checks_per_line == 0:\n            modifier = f'\\n{indent}'\n        sys.stdout.write(f'.{modifier}')\n        sys.stdout.flush()\n        should_loop = predicate()\n    sys.stdout.write('\\n')\n    return should_loop.map(lambda _: None)\n</code></pre>"},{"location":"api/m/ci/git_env/","title":"git_env","text":""},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv","title":"<code>GitEnv</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Object to store the git configuration.</p> <p>Attributes:</p> Name Type Description <code>sha</code> <code>str</code> <p>...</p> <code>branch</code> <code>str</code> <p>...</p> <code>target_branch</code> <code>str</code> <p>...</p> <code>commit</code> <code>Commit | None</code> <p>...</p> <code>pull_request</code> <code>PullRequest | None</code> <p>...</p> <code>release</code> <code>Release | None</code> <p>...</p> Source code in <code>m/ci/git_env.py</code> <pre><code>class GitEnv(BaseModel):\n    \"\"\"Object to store the git configuration.\"\"\"\n\n    sha: str\n    branch: str\n    target_branch: str\n    commit: Commit | None = None\n    pull_request: PullRequest | None = None\n    release: Release | None = None\n\n    def get_pr_branch(self) -&gt; str:\n        \"\"\"Get the pull request branch or empty string.\n\n        Returns:\n            The name of the pull request branch or an empty string when not\n            dealing with a pull request.\n        \"\"\"\n        return self.pull_request.pr_branch if self.pull_request else ''\n\n    def get_pr_number(self) -&gt; int:\n        \"\"\"Get the pull request number or 0 if not a pull request.\n\n        Returns:\n            The pull request number or 0 if not a pull request.\n        \"\"\"\n        return self.pull_request.pr_number if self.pull_request else 0\n\n    def is_release(self, config: Config) -&gt; bool:\n        \"\"\"Determine if the current commit should create a release.\n\n        Args:\n            config: The `m` configuration.\n\n        Returns:\n            True if we are dealing with a release.\n        \"\"\"\n        if not self.commit:\n            return False\n        release_prefix = get_release_prefix(config)\n        hotfix_prefix = get_hotfix_prefix(config)\n        if config.uses_m_flow() and self.branch != config.m_flow.master_branch:\n            return False\n        if config.uses_git_flow():\n            if self.branch != config.git_flow.master_branch:\n                return False\n        return (\n            self.commit.is_release(release_prefix)\n            or self.commit.is_release(hotfix_prefix)\n        )\n\n    def is_release_pr(self, config: Config) -&gt; bool:\n        \"\"\"Determine if the the current pr is a release pr.\n\n        Args:\n            config: The `m` configuration.\n\n        Returns:\n            True if we are dealing with a release pr.\n        \"\"\"\n        if not self.pull_request:\n            return False\n        release_prefix = get_release_prefix(config)\n        return self.pull_request.is_release_pr(release_prefix)\n\n    def is_hotfix_pr(self, config: Config) -&gt; bool:\n        \"\"\"Determine if the the current pr is a hotfix pr.\n\n        It is a release pr as far as the pull request should see it but\n        from the context of the git environment we need to label it as a\n        hotfix pr.\n\n        Args:\n            config: The m configuration object.\n\n        Returns:\n            True if the we are dealing with hotfix pr.\n        \"\"\"\n        if not self.pull_request:\n            return False\n        hotfix_prefix = get_hotfix_prefix(config)\n        return self.pull_request.is_release_pr(hotfix_prefix)\n\n    def get_build_tag(self, config: Config, run_id: str) -&gt; Res[str]:\n        \"\"\"Create a build tag for the current commit.\n\n        It is tempting to use the config_version when creating a build tag for\n        pull requests or branches. This will only be annoying when testing.\n\n        Consider the following scenario. An application is being tested with\n        `1.0.1-pr99.b123`. When using docker you may want to refer to the\n        latest pr build by using `1.0.1-pr99`. Now lets say that a release\n        happened and now the config_version is at `1.1.0`. The application\n        build will not get the latest changes because the new changes are in\n        `1.1.0-pr99`.\n\n        There are two solutions, either always state the version that is\n        being used or make a tag to depend only on the pull request number.\n        This is the reason why for prs (constantly changing) we avoid\n        using the version in the configuration.\n\n        For release prs we use `rc` followed by the pull request. In this case\n        it is safe to use config_version given that there should only be\n        one release at a time. We treat hotfixes similar to releases.\n\n        Git flow will generate a special build tag: SKIP. This will happen when\n        we try to merge a release or hotfix branch to the develop branch.\n\n        Args:\n            config: The `m` configuration.\n            run_id: A unique identifier for the run/job.\n\n        Returns:\n            A unique identifier for the build. This tag is compatible with\n            both `npm` and `docker`.\n        \"\"\"\n        ver_input = _version_inputs(self, config, run_id)\n        if ver_input:\n            return Good(build_m_tag(ver_input, config))\n        return Good('SKIP')\n\n    def get_py_tag(self, config: Config, run_id: str) -&gt; Res[str]:\n        \"\"\"Create a python tag for the current commit.\n\n        Args:\n            config: The `m` configuration.\n            run_id: A unique identifier for the run/job.\n\n        Returns:\n            A unique identifier for the build. This tag is compatible with\n            python.\n        \"\"\"\n        ver_input = _version_inputs(self, config, run_id)\n        if ver_input:\n            return Good(build_py_tag(ver_input, config))\n        return Good('SKIP')\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.get_build_tag","title":"<code>get_build_tag(config, run_id)</code>","text":"<p>Create a build tag for the current commit.</p> <p>It is tempting to use the config_version when creating a build tag for pull requests or branches. This will only be annoying when testing.</p> <p>Consider the following scenario. An application is being tested with <code>1.0.1-pr99.b123</code>. When using docker you may want to refer to the latest pr build by using <code>1.0.1-pr99</code>. Now lets say that a release happened and now the config_version is at <code>1.1.0</code>. The application build will not get the latest changes because the new changes are in <code>1.1.0-pr99</code>.</p> <p>There are two solutions, either always state the version that is being used or make a tag to depend only on the pull request number. This is the reason why for prs (constantly changing) we avoid using the version in the configuration.</p> <p>For release prs we use <code>rc</code> followed by the pull request. In this case it is safe to use config_version given that there should only be one release at a time. We treat hotfixes similar to releases.</p> <p>Git flow will generate a special build tag: SKIP. This will happen when we try to merge a release or hotfix branch to the develop branch.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The <code>m</code> configuration.</p> required <code>run_id</code> <code>str</code> <p>A unique identifier for the run/job.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A unique identifier for the build. This tag is compatible with</p> <code>Res[str]</code> <p>both <code>npm</code> and <code>docker</code>.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_build_tag(self, config: Config, run_id: str) -&gt; Res[str]:\n    \"\"\"Create a build tag for the current commit.\n\n    It is tempting to use the config_version when creating a build tag for\n    pull requests or branches. This will only be annoying when testing.\n\n    Consider the following scenario. An application is being tested with\n    `1.0.1-pr99.b123`. When using docker you may want to refer to the\n    latest pr build by using `1.0.1-pr99`. Now lets say that a release\n    happened and now the config_version is at `1.1.0`. The application\n    build will not get the latest changes because the new changes are in\n    `1.1.0-pr99`.\n\n    There are two solutions, either always state the version that is\n    being used or make a tag to depend only on the pull request number.\n    This is the reason why for prs (constantly changing) we avoid\n    using the version in the configuration.\n\n    For release prs we use `rc` followed by the pull request. In this case\n    it is safe to use config_version given that there should only be\n    one release at a time. We treat hotfixes similar to releases.\n\n    Git flow will generate a special build tag: SKIP. This will happen when\n    we try to merge a release or hotfix branch to the develop branch.\n\n    Args:\n        config: The `m` configuration.\n        run_id: A unique identifier for the run/job.\n\n    Returns:\n        A unique identifier for the build. This tag is compatible with\n        both `npm` and `docker`.\n    \"\"\"\n    ver_input = _version_inputs(self, config, run_id)\n    if ver_input:\n        return Good(build_m_tag(ver_input, config))\n    return Good('SKIP')\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.get_pr_branch","title":"<code>get_pr_branch()</code>","text":"<p>Get the pull request branch or empty string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the pull request branch or an empty string when not</p> <code>str</code> <p>dealing with a pull request.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_pr_branch(self) -&gt; str:\n    \"\"\"Get the pull request branch or empty string.\n\n    Returns:\n        The name of the pull request branch or an empty string when not\n        dealing with a pull request.\n    \"\"\"\n    return self.pull_request.pr_branch if self.pull_request else ''\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.get_pr_number","title":"<code>get_pr_number()</code>","text":"<p>Get the pull request number or 0 if not a pull request.</p> <p>Returns:</p> Type Description <code>int</code> <p>The pull request number or 0 if not a pull request.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_pr_number(self) -&gt; int:\n    \"\"\"Get the pull request number or 0 if not a pull request.\n\n    Returns:\n        The pull request number or 0 if not a pull request.\n    \"\"\"\n    return self.pull_request.pr_number if self.pull_request else 0\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.get_py_tag","title":"<code>get_py_tag(config, run_id)</code>","text":"<p>Create a python tag for the current commit.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The <code>m</code> configuration.</p> required <code>run_id</code> <code>str</code> <p>A unique identifier for the run/job.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A unique identifier for the build. This tag is compatible with</p> <code>Res[str]</code> <p>python.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_py_tag(self, config: Config, run_id: str) -&gt; Res[str]:\n    \"\"\"Create a python tag for the current commit.\n\n    Args:\n        config: The `m` configuration.\n        run_id: A unique identifier for the run/job.\n\n    Returns:\n        A unique identifier for the build. This tag is compatible with\n        python.\n    \"\"\"\n    ver_input = _version_inputs(self, config, run_id)\n    if ver_input:\n        return Good(build_py_tag(ver_input, config))\n    return Good('SKIP')\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.is_hotfix_pr","title":"<code>is_hotfix_pr(config)</code>","text":"<p>Determine if the the current pr is a hotfix pr.</p> <p>It is a release pr as far as the pull request should see it but from the context of the git environment we need to label it as a hotfix pr.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The m configuration object.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the we are dealing with hotfix pr.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def is_hotfix_pr(self, config: Config) -&gt; bool:\n    \"\"\"Determine if the the current pr is a hotfix pr.\n\n    It is a release pr as far as the pull request should see it but\n    from the context of the git environment we need to label it as a\n    hotfix pr.\n\n    Args:\n        config: The m configuration object.\n\n    Returns:\n        True if the we are dealing with hotfix pr.\n    \"\"\"\n    if not self.pull_request:\n        return False\n    hotfix_prefix = get_hotfix_prefix(config)\n    return self.pull_request.is_release_pr(hotfix_prefix)\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.is_release","title":"<code>is_release(config)</code>","text":"<p>Determine if the current commit should create a release.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The <code>m</code> configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if we are dealing with a release.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def is_release(self, config: Config) -&gt; bool:\n    \"\"\"Determine if the current commit should create a release.\n\n    Args:\n        config: The `m` configuration.\n\n    Returns:\n        True if we are dealing with a release.\n    \"\"\"\n    if not self.commit:\n        return False\n    release_prefix = get_release_prefix(config)\n    hotfix_prefix = get_hotfix_prefix(config)\n    if config.uses_m_flow() and self.branch != config.m_flow.master_branch:\n        return False\n    if config.uses_git_flow():\n        if self.branch != config.git_flow.master_branch:\n            return False\n    return (\n        self.commit.is_release(release_prefix)\n        or self.commit.is_release(hotfix_prefix)\n    )\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.GitEnv.is_release_pr","title":"<code>is_release_pr(config)</code>","text":"<p>Determine if the the current pr is a release pr.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The <code>m</code> configuration.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if we are dealing with a release pr.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def is_release_pr(self, config: Config) -&gt; bool:\n    \"\"\"Determine if the the current pr is a release pr.\n\n    Args:\n        config: The `m` configuration.\n\n    Returns:\n        True if we are dealing with a release pr.\n    \"\"\"\n    if not self.pull_request:\n        return False\n    release_prefix = get_release_prefix(config)\n    return self.pull_request.is_release_pr(release_prefix)\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.get_git_env","title":"<code>get_git_env(config, env_vars)</code>","text":"<p>Obtain the git environment by asking Github's API.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The m configuration object.</p> required <code>env_vars</code> <code>EnvVars</code> <p>The environment variables.</p> required <p>Returns:</p> Type Description <code>Res[GitEnv]</code> <p>The git environment object or an issue.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_git_env(config: Config, env_vars: EnvVars) -&gt; Res[GitEnv]:\n    \"\"\"Obtain the git environment by asking Github's API.\n\n    Args:\n        config: The m configuration object.\n        env_vars: The environment variables.\n\n    Returns:\n        The git environment object or an issue.\n    \"\"\"\n    branch = _remove_strings(env_vars.git_branch, ['refs/heads/', 'heads/'])\n    sha = env_vars.git_sha\n    git_env = GitEnv(sha=sha, branch=branch, target_branch=branch)\n\n    # quick exit for local environment\n    if not env_vars.ci_env:\n        return Good(git_env)\n\n    pr_number = get_pr_number(branch)\n    git_env_box = get_ci_run_info(\n        token=env_vars.github_token,\n        commit_info=CommitInfo(\n            owner=config.owner,\n            repo=config.repo,\n            sha=env_vars.git_sha,\n        ),\n        pr_number=pr_number,\n        file_count=0,\n        include_release=True,\n    )\n    if isinstance(git_env_box, Bad):\n        return issue('git_env failure', cause=git_env_box.value)\n\n    res = git_env_box.value\n    pr = res.pull_request\n    git_env.sha = res.commit.sha\n    git_env.target_branch = pr.target_branch if pr else branch\n    git_env.commit = res.commit\n    git_env.pull_request = res.pull_request\n    git_env.release = res.release\n    return Good(git_env)\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.get_hotfix_prefix","title":"<code>get_hotfix_prefix(config)</code>","text":"<p>Find out the hotfix prefix.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The m configuration. Its workflow is used to determine the prefix.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The hofix prefix or None if not using a supported workflow.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_hotfix_prefix(config: Config) -&gt; str | None:\n    \"\"\"Find out the hotfix prefix.\n\n    Args:\n        config:\n            The m configuration. Its workflow is used to determine the prefix.\n\n    Returns:\n        The hofix prefix or None if not using a supported workflow.\n    \"\"\"\n    if config.uses_git_flow():\n        return config.git_flow.hotfix_prefix\n    if config.uses_m_flow():\n        return config.m_flow.hotfix_prefix\n    return None\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.get_pr_number","title":"<code>get_pr_number(branch)</code>","text":"<p>Retrieve the pull request number from the branch name.</p> <p>Parameters:</p> Name Type Description Default <code>branch</code> <code>str</code> <p>The branch name from where the pr number is extracted.py</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>The pr number if the branch is a pull request otherwise <code>None</code>.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_pr_number(branch: str) -&gt; int | None:\n    \"\"\"Retrieve the pull request number from the branch name.\n\n    Args:\n        branch: The branch name from where the pr number is extracted.py\n\n    Returns:\n        The pr number if the branch is a pull request otherwise `None`.\n    \"\"\"\n    if 'pull/' in branch:\n        parts = branch.split('/')\n        return int(parts[parts.index('pull') + 1])\n    return None\n</code></pre>"},{"location":"api/m/ci/git_env/#m.ci.git_env.get_release_prefix","title":"<code>get_release_prefix(config)</code>","text":"<p>Find out the release prefix.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The m configuration. Its workflow is used to determine the prefix.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The release prefix or None if not using a supported workflow.</p> Source code in <code>m/ci/git_env.py</code> <pre><code>def get_release_prefix(config: Config) -&gt; str | None:\n    \"\"\"Find out the release prefix.\n\n    Args:\n        config:\n            The m configuration. Its workflow is used to determine the prefix.\n\n    Returns:\n        The release prefix or None if not using a supported workflow.\n    \"\"\"\n    if config.uses_git_flow():\n        return config.git_flow.release_prefix\n    if config.uses_m_flow():\n        return config.m_flow.release_prefix\n    return None\n</code></pre>"},{"location":"api/m/ci/init/","title":"init","text":""},{"location":"api/m/ci/init/#m.ci.init.create_changelog","title":"<code>create_changelog()</code>","text":"<p>Create the changelog file.</p> <p>Returns:</p> Type Description <code>Res[str | None]</code> <p>A <code>OneOf</code> containing 0 if successful or an <code>Issue</code>.</p> Source code in <code>m/ci/init.py</code> <pre><code>def create_changelog() -&gt; Res[str | None]:\n    \"\"\"Create the changelog file.\n\n    Returns:\n        A `OneOf` containing 0 if successful or an `Issue`.\n    \"\"\"\n    body = \"\"\"\\\n        # Changelog\n\n        The format of this changelog is based on\n        [Keep a Changelog](http://keepachangelog.com/en/1.0.0/). The project adheres to\n        [Semantic Versioning](http://semver.org/spec/v2.0.0.html)\n\n        &gt; Major version zero (0.y.z) is for initial development. Anything may change at\n        &gt; any time. The public API should not be considered stable.\n\n        ## [Unreleased]\n    \"\"\"\n    file_name = 'CHANGELOG.md'\n    if Path.exists(Path(file_name)):\n        logger.warning(f'{file_name} already exists')\n        return Good(None)\n    return one_of(lambda: [\n        file_name\n        for _ in mio.write_file('CHANGELOG.md', dedent(body))\n        for _ in logger.info(f'created {file_name}')\n    ])\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.create_m_config","title":"<code>create_m_config()</code>","text":"<p>Create the m configuration file.</p> <p>Returns:</p> Type Description <code>Res[str | None]</code> <p>The name of the m file or none if successful. Otherwise an <code>Issue</code>.</p> Source code in <code>m/ci/init.py</code> <pre><code>def create_m_config() -&gt; Res[str | None]:\n    \"\"\"Create the m configuration file.\n\n    Returns:\n        The name of the m file or none if successful. Otherwise an `Issue`.\n    \"\"\"\n    file_name = 'm/m.yaml'\n    if Path.exists(Path(file_name)):\n        logger.warning(f'{file_name} already exists')\n        return Good(None)\n    m_dir = Path('m')\n    if not Path.exists(m_dir):\n        Path.mkdir(m_dir, parents=True)\n    return one_of(lambda: [\n        file_name\n        for owner, repo in get_repo_info()\n        for _ in mio.write_file(file_name, m_config_body(owner, repo))\n        for _ in logger.info(f'created {file_name}', {\n            'owner': owner,\n            'repo': repo,\n        })\n    ])\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.get_repo_info","title":"<code>get_repo_info()</code>","text":"<p>Get the owner and repo name from the current repository.</p> <p>Returns:</p> Type Description <code>Res[Tuple[str, str]]</code> <p>A tuple with the owner and repo (or an Issue).</p> Source code in <code>m/ci/init.py</code> <pre><code>def get_repo_info() -&gt; Res[Tuple[str, str]]:\n    \"\"\"Get the owner and repo name from the current repository.\n\n    Returns:\n        A tuple with the owner and repo (or an Issue).\n    \"\"\"\n    return one_of(lambda: [\n        owner_repo\n        for ssh_url in get_remote_url()\n        for owner_repo in parse_ssh_url(ssh_url)\n    ])\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.init_repo","title":"<code>init_repo()</code>","text":"<p>Initialize a repository with the basic project configurations.</p> <p>Returns:</p> Type Description <code>Res[None]</code> <p>A <code>OneOf</code> containing 0 if successful or an <code>Issue</code>.</p> Source code in <code>m/ci/init.py</code> <pre><code>def init_repo() -&gt; Res[None]:\n    \"\"\"Initialize a repository with the basic project configurations.\n\n    Returns:\n        A `OneOf` containing 0 if successful or an `Issue`.\n    \"\"\"\n    return one_of(lambda: [\n        None\n        for m_file in create_m_config()\n        for gitignore in update_gitignore()\n        for changelog in create_changelog()\n        for _ in logger.info('setup complete', {\n            'modified_files': [x for x in (m_file, gitignore, changelog) if x],\n        })\n    ])\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.m_config_body","title":"<code>m_config_body(owner, repo)</code>","text":"<p>Create the basic contents of a m configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The repo owner.</p> required <code>repo</code> <code>str</code> <p>The repo name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A yaml string to be the content of the <code>m.yaml</code> file.</p> Source code in <code>m/ci/init.py</code> <pre><code>def m_config_body(owner: str, repo: str) -&gt; str:\n    \"\"\"Create the basic contents of a m configuration file.\n\n    Args:\n        owner: The repo owner.\n        repo: The repo name.\n\n    Returns:\n        A yaml string to be the content of the `m.yaml` file.\n    \"\"\"\n    body = f\"\"\"\\\n        owner: {owner}\n        repo: {repo}\n        version: 0.0.0\n        workflow: m_flow\n    \"\"\"\n    return dedent(body)\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.parse_ssh_url","title":"<code>parse_ssh_url(ssh_url)</code>","text":"<p>Find the owner and repo from an ssh url.</p> <p>Parameters:</p> Name Type Description Default <code>ssh_url</code> <code>str</code> <p>The url of the repo</p> required <p>Returns:</p> Type Description <code>Res[Tuple[str, str]]</code> <p>A tuple with the owner and repo (or an Issue).</p> Source code in <code>m/ci/init.py</code> <pre><code>def parse_ssh_url(ssh_url: str) -&gt; Res[Tuple[str, str]]:\n    \"\"\"Find the owner and repo from an ssh url.\n\n    Args:\n        ssh_url: The url of the repo\n\n    Returns:\n        A tuple with the owner and repo (or an Issue).\n    \"\"\"\n    match = re.findall('.*:(.*)/(.*).git', ssh_url)\n    if match and match[0] and match[0][0] and match[0][1]:\n        return Good(match[0])\n    return issue(\n        'unable to obtain owner and repo',\n        context={'ssh_url': ssh_url},\n    )\n</code></pre>"},{"location":"api/m/ci/init/#m.ci.init.update_gitignore","title":"<code>update_gitignore()</code>","text":"<p>Update the gitignore file.</p> <p>Adds the m/.m directory to the list.</p> <p>Returns:</p> Type Description <code>Res[str | None]</code> <p>A <code>OneOf</code> containing file name or an Issue if it was unable to update</p> <code>Res[str | None]</code> <p>the file.</p> Source code in <code>m/ci/init.py</code> <pre><code>def update_gitignore() -&gt; Res[str | None]:\n    \"\"\"Update the gitignore file.\n\n    Adds the m/.m directory to the list.\n\n    Returns:\n        A `OneOf` containing file name or an Issue if it was unable to update\n        the file.\n    \"\"\"\n    file_name = '.gitignore'\n    return one_of(lambda: [\n        fname\n        for _ in subprocess.eval_cmd(f'touch {file_name}')\n        for body in mio.read_file(file_name)\n        for fname in _update_gitignore(file_name, body)\n    ])\n</code></pre>"},{"location":"api/m/ci/m_blueprints/","title":"m_blueprints","text":""},{"location":"api/m/ci/m_blueprints/#m.ci.m_blueprints.write_blueprints","title":"<code>write_blueprints(m_dir, *, m_tag, cache_from_pr, update_makefile=False, update_workflow=False)</code>","text":"<p>Write a file with the M environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory with the m configuration.</p> required <code>m_tag</code> <code>str</code> <p>The unique identifier for the build.</p> required <code>cache_from_pr</code> <code>str</code> <p>The pr number to attempt to pull cache from.</p> required <code>update_makefile</code> <code>bool</code> <p>If true, updates the <code>Makefile</code>.</p> <code>False</code> <code>update_workflow</code> <code>bool</code> <p>If true, updates the github workflow.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue or the m environment instance.</p> Source code in <code>m/ci/m_blueprints.py</code> <pre><code>def write_blueprints(\n    m_dir: str,\n    *,\n    m_tag: str,\n    cache_from_pr: str,\n    update_makefile: bool = False,\n    update_workflow: bool = False,\n) -&gt; Res[None]:\n    \"\"\"Write a file with the M environment variables.\n\n    Args:\n        m_dir: The directory with the m configuration.\n        m_tag: The unique identifier for the build.\n        cache_from_pr: The pr number to attempt to pull cache from.\n        update_makefile: If true, updates the `Makefile`.\n        update_workflow: If true, updates the github workflow.\n\n    Returns:\n        An issue or the m environment instance.\n    \"\"\"\n    blueprints_dir = Path(f'{m_dir}/.m/blueprints')\n    if not blueprints_dir.exists():\n        Path(f'{m_dir}/.m/blueprints/local').mkdir(parents=True)\n        Path(f'{m_dir}/.m/blueprints/ci').mkdir(parents=True)\n    return one_of(lambda: [\n        None\n        for config in read_config(m_dir)\n        for _ in _write_blueprints(\n            config,\n            m_tag=m_tag,\n            cache_from_pr=cache_from_pr,\n            update_makefile=update_makefile,\n            update_workflow=update_workflow,\n        )\n    ])\n</code></pre>"},{"location":"api/m/ci/m_env/","title":"m_env","text":""},{"location":"api/m/ci/m_env/#m.ci.m_env.MEnv","title":"<code>MEnv</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Contains all the information required for a CI run.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>Config</code> <p>...</p> <code>env_vars</code> <code>EnvVars</code> <p>...</p> <code>git_env</code> <code>GitEnv</code> <p>...</p> <code>release_env</code> <code>ReleaseEnv</code> <p>...</p> Source code in <code>m/ci/m_env.py</code> <pre><code>class MEnv(BaseModel):\n    \"\"\"Contains all the information required for a CI run.\"\"\"\n\n    config: Config\n    env_vars: EnvVars\n    git_env: GitEnv\n    release_env: ReleaseEnv\n</code></pre>"},{"location":"api/m/ci/m_env/#m.ci.m_env.bashrc_snippet","title":"<code>bashrc_snippet(m_dir)</code>","text":"<p>Create a bash snippet that exports the M environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory with the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>An issue or a bash snippet.</p> Source code in <code>m/ci/m_env.py</code> <pre><code>def bashrc_snippet(m_dir: str) -&gt; Res[str]:\n    \"\"\"Create a bash snippet that exports the M environment variables.\n\n    Args:\n        m_dir: The directory with the m configuration.\n\n    Returns:\n        An issue or a bash snippet.\n    \"\"\"\n    return one_of(lambda: [\n        '\\n'.join([\n            f'export {assignment}'\n            for line in env_list\n            for assignment in fp.Good(_lower_bool(line))\n        ])\n        for m_env in get_m_env(m_dir)\n        for env_list in _m_env_vars(m_env)\n    ])\n</code></pre>"},{"location":"api/m/ci/m_env/#m.ci.m_env.get_m_env","title":"<code>get_m_env(m_dir)</code>","text":"<p>Obtain the M Environment object.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory containing the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[MEnv]</code> <p>The M Environment if it exists otherwise an issue.</p> Source code in <code>m/ci/m_env.py</code> <pre><code>def get_m_env(m_dir: str) -&gt; Res[MEnv]:\n    \"\"\"Obtain the M Environment object.\n\n    Args:\n        m_dir: The directory containing the m configuration.\n\n    Returns:\n        The M Environment if it exists otherwise an issue.\n    \"\"\"\n    ci_tool = get_ci_tool()\n    return one_of(lambda: [\n        MEnv(\n            config=config,\n            env_vars=env_vars,\n            git_env=git_env,\n            release_env=release_env,\n        )\n        for config in read_config(m_dir)\n        for env_vars in ci_tool.env_vars()\n        for git_env in get_git_env(config, env_vars)\n        for release_env in get_release_env(config, env_vars, git_env)\n    ]).flat_map_bad(hone('get_m_env failure'))\n</code></pre>"},{"location":"api/m/ci/m_env/#m.ci.m_env.write_m_env_vars","title":"<code>write_m_env_vars(m_dir)</code>","text":"<p>Write a file with the M environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory with the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[Any]</code> <p>An issue or the m environment instance.</p> Source code in <code>m/ci/m_env.py</code> <pre><code>def write_m_env_vars(m_dir: str) -&gt; Res[Any]:\n    \"\"\"Write a file with the M environment variables.\n\n    Args:\n        m_dir: The directory with the m configuration.\n\n    Returns:\n        An issue or the m environment instance.\n    \"\"\"\n    target_dir = Path(f'{m_dir}/.m')\n\n    if not Path.exists(target_dir):\n        Path.mkdir(target_dir, parents=True)\n    return one_of(lambda: [\n        json.loads(m_env.model_dump_json())\n        for m_env in get_m_env(m_dir)\n        for env_list in _m_env_vars(m_env)\n        for _ in mio.write_file(f'{m_dir}/.m/env.list', '\\n'.join(env_list))\n    ])\n</code></pre>"},{"location":"api/m/ci/release_env/","title":"release_env","text":""},{"location":"api/m/ci/release_env/#m.ci.release_env.ReleaseEnv","title":"<code>ReleaseEnv</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Object to store the release configuration.</p> <p>Attributes:</p> Name Type Description <code>build_tag</code> <code>str</code> <p>...</p> <code>python_tag</code> <code>str</code> <p>...</p> <code>is_release</code> <code>bool</code> <p>...</p> <code>is_release_pr</code> <code>bool</code> <p>...</p> <code>is_hotfix_pr</code> <code>bool</code> <p>...</p> <code>workflow</code> <code>Workflow</code> <p>...</p> Source code in <code>m/ci/release_env.py</code> <pre><code>class ReleaseEnv(BaseModel):\n    \"\"\"Object to store the release configuration.\"\"\"\n\n    build_tag: str\n    python_tag: str\n    is_release: bool\n    is_release_pr: bool\n    is_hotfix_pr: bool\n    workflow: Workflow\n</code></pre>"},{"location":"api/m/ci/release_env/#m.ci.release_env.get_release_env","title":"<code>get_release_env(config, env_vars, git_env)</code>","text":"<p>Provide the release environment information.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The m configuration.</p> required <code>env_vars</code> <code>EnvVars</code> <p>The environment variables.</p> required <code>git_env</code> <code>GitEnv</code> <p>The git environment.</p> required <p>Returns:</p> Type Description <code>Res[ReleaseEnv]</code> <p>A <code>ReleaseEnv</code> instance.</p> Source code in <code>m/ci/release_env.py</code> <pre><code>def get_release_env(\n    config: Config,\n    env_vars: EnvVars,\n    git_env: GitEnv,\n) -&gt; Res[ReleaseEnv]:\n    \"\"\"Provide the release environment information.\n\n    Args:\n        config: The m configuration.\n        env_vars: The environment variables.\n        git_env: The git environment.\n\n    Returns:\n        A `ReleaseEnv` instance.\n    \"\"\"\n    is_release = git_env.is_release(config)\n    is_release_pr = git_env.is_release_pr(config)\n    is_hotfix_pr = git_env.is_hotfix_pr(config)\n    gh_latest = git_env.release.tag_name if git_env.release else ''\n    if not config.uses_free_flow():\n        check_result = _extra_checks(\n            config,\n            git_env,\n            is_release_pr=is_release_pr,\n            is_hotfix_pr=is_hotfix_pr,\n        )\n        if isinstance(check_result, Bad):\n            return check_result\n    return one_of(lambda: [\n        ReleaseEnv(\n            build_tag=build_tag,\n            python_tag=python_tag,\n            is_release=is_release,\n            is_release_pr=is_release_pr,\n            is_hotfix_pr=is_hotfix_pr,\n            workflow=config.workflow,\n        )\n        for _ in _verify_version(\n            config,\n            git_env,\n            gh_latest,\n            is_release_pr=is_release_pr or is_hotfix_pr,\n            is_release=is_release,\n        )\n        for build_tag in git_env.get_build_tag(config, env_vars.run_id)\n        for python_tag in git_env.get_py_tag(config, env_vars.run_id)\n    ])\n</code></pre>"},{"location":"api/m/ci/release_setup/","title":"release_setup","text":""},{"location":"api/m/ci/release_setup/#m.ci.release_setup.new_changelog","title":"<code>new_changelog(changelog_contents, owner, repo, new_ver, first_sha)</code>","text":"<p>Modify the contents of a CHANGELOG.</p> <p>It adds a new entry with the new version the new changelog contents.</p> <p>Parameters:</p> Name Type Description Default <code>changelog_contents</code> <code>str</code> <p>The current contents of the CHANGELOG file.</p> required <code>owner</code> <code>str</code> <p>The repo owner.</p> required <code>repo</code> <code>str</code> <p>The repo name.</p> required <code>new_ver</code> <code>str</code> <p>The new version.</p> required <code>first_sha</code> <code>str</code> <p>The very first commit sha of the repo.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>The new contents of the CHANGELOG.</p> Source code in <code>m/ci/release_setup.py</code> <pre><code>def new_changelog(\n    changelog_contents: str,\n    owner: str,\n    repo: str,\n    new_ver: str,\n    first_sha: str,\n) -&gt; Res[str]:\n    \"\"\"Modify the contents of a CHANGELOG.\n\n    It adds a new entry with the new version the new changelog contents.\n\n    Args:\n        changelog_contents: The current contents of the CHANGELOG file.\n        owner: The repo owner.\n        repo: The repo name.\n        new_ver: The new version.\n        first_sha: The very first commit sha of the repo.\n\n    Returns:\n        The new contents of the CHANGELOG.\n    \"\"\"\n    parts = changelog_contents.split('## [Unreleased]')\n    if len(parts) != 2:\n        return issue('missing \"Unreleased\" link')\n\n    header, main = parts\n    entries = main.split('[unreleased]:')[0]\n    versions = _get_versions(entries.split('\\n'), new_ver, first_sha)\n\n    compare_url = compare_sha_url(owner, repo, new_ver, 'HEAD')\n    links = [f'[unreleased]: {compare_url}']\n    for i in range(len(versions) - 1):\n        link = compare_sha_url(owner, repo, versions[i + 1], versions[i])\n        links.append(f'[{versions[i]}]: {link}')\n\n    date = datetime.now().strftime('%B %d, %Y')\n    ver_anchor = _version_anchor(new_ver)\n    return Good(''.join([\n        header,\n        '## [Unreleased]\\n\\n',\n        f'## [{new_ver}] {ver_anchor} {date}\\n\\n',\n        entries,\n        '\\n'.join(links),\n        '\\n',\n    ]))\n</code></pre>"},{"location":"api/m/ci/release_setup/#m.ci.release_setup.release_setup","title":"<code>release_setup(m_dir, config_inst, new_ver, changelog='CHANGELOG.md')</code>","text":"<p>Modify all the necessary files to create a release.</p> <p>These include: CHANGELOG.md and the m configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The directory with the m configuration.</p> required <code>config_inst</code> <code>Config | None</code> <p>If provided it skips reading the configuration.</p> required <code>new_ver</code> <code>str</code> <p>The new version to write in the m configuration.</p> required <code>changelog</code> <code>str</code> <p>The name of the changelog file (defaults to CHANGELOG.md)</p> <code>'CHANGELOG.md'</code> <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, otherwise an issue.</p> Source code in <code>m/ci/release_setup.py</code> <pre><code>def release_setup(\n    m_dir: str,\n    config_inst: Config | None,\n    new_ver: str,\n    changelog: str = 'CHANGELOG.md',\n) -&gt; Res[None]:\n    \"\"\"Modify all the necessary files to create a release.\n\n    These include: CHANGELOG.md and the m configuration file.\n\n    Args:\n        m_dir: The directory with the m configuration.\n        config_inst: If provided it skips reading the configuration.\n        new_ver: The new version to write in the m configuration.\n        changelog: The name of the changelog file (defaults to CHANGELOG.md)\n\n    Returns:\n        None if successful, otherwise an issue.\n    \"\"\"\n    return one_of(lambda: [\n        None\n        for config in _read_config(m_dir, config_inst)\n        for first_sha in get_first_commit_sha()\n        for _ in update_version(m_dir, new_ver)\n        for _ in update_changelog_file(\n            config.owner,\n            config.repo,\n            new_ver,\n            first_sha,\n            changelog,\n        )\n        for _ in _success_release_setup(config, new_ver)\n    ])\n</code></pre>"},{"location":"api/m/ci/release_setup/#m.ci.release_setup.update_changelog_file","title":"<code>update_changelog_file(owner, repo, new_ver, first_sha, filename='CHANGELOG.md')</code>","text":"<p>Add the new version entry to be released to the CHANGELOG.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The repo owner.</p> required <code>repo</code> <code>str</code> <p>The repo name.</p> required <code>new_ver</code> <code>str</code> <p>The version that is being released.</p> required <code>first_sha</code> <code>str</code> <p>The first sha ever committed on the repo.</p> required <code>filename</code> <code>str</code> <p>Specify the CHANGELOG file (defaults to CHANGELOG.md)</p> <code>'CHANGELOG.md'</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>0 if successful, an issue otherwise.</p> Source code in <code>m/ci/release_setup.py</code> <pre><code>def update_changelog_file(\n    owner: str,\n    repo: str,\n    new_ver: str,\n    first_sha: str,\n    filename: str = 'CHANGELOG.md',\n) -&gt; Res[int]:\n    \"\"\"Add the new version entry to be released to the CHANGELOG.\n\n    Args:\n        owner: The repo owner.\n        repo: The repo name.\n        new_ver: The version that is being released.\n        first_sha: The first sha ever committed on the repo.\n        filename: Specify the CHANGELOG file (defaults to CHANGELOG.md)\n\n    Returns:\n        0 if successful, an issue otherwise.\n    \"\"\"\n    return one_of(lambda: [\n        0\n        for text in rw.read_file(filename)\n        for new_data in new_changelog(text, owner, repo, new_ver, first_sha)\n        for _ in rw.write_file(filename, new_data)\n        for _ in logger.info(f'updated {filename}')\n    ])\n</code></pre>"},{"location":"api/m/ci/release_setup/#m.ci.release_setup.update_version","title":"<code>update_version(root, version)</code>","text":"<p>Update the version property in m configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>The directory with the m configuration file.</p> required <code>version</code> <code>str</code> <p>The new version to write in the m configuration.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>0 if successful or an issue.</p> Source code in <code>m/ci/release_setup.py</code> <pre><code>def update_version(\n    root: str,\n    version: str,\n) -&gt; Res[int]:\n    \"\"\"Update the version property in m configuration file.\n\n    Args:\n        root: The directory with the m configuration file.\n        version: The new version to write in the m configuration.\n\n    Returns:\n        0 if successful or an issue.\n    \"\"\"\n    return one_of(lambda: [\n        0\n        for filename in get_m_filename(root)\n        for config_contents in rw.read_file(filename)\n        for new_data in _update_config_version(config_contents, version)\n        for _ in rw.write_file(filename, new_data)\n        for _ in logger.info(f'bumped version in {filename}')\n    ])\n</code></pre>"},{"location":"api/m/ci/release_utils/","title":"release_utils","text":""},{"location":"api/m/ci/release_utils/#m.ci.release_utils.assert_branch","title":"<code>assert_branch(branch, step)</code>","text":"<p>Assert that a release step is done in the proper branch.</p> <p>This can only happen in <code>release/x.y.z</code> or <code>hotfix/x.y.z</code>.</p> <p>Parameters:</p> Name Type Description Default <code>branch</code> <code>str</code> <p>branch name to verify.</p> required <code>step</code> <code>str</code> <p>the release step name.</p> required <p>Returns:</p> Type Description <code>Res[tuple[str, str]]</code> <p>An Issue if the current branch is not a release/hotfix else the</p> <code>Res[tuple[str, str]]</code> <p>release type and version to release/hotfix.</p> Source code in <code>m/ci/release_utils.py</code> <pre><code>def assert_branch(branch: str, step: str) -&gt; Res[tuple[str, str]]:\n    \"\"\"Assert that a release step is done in the proper branch.\n\n    This can only happen in `release/x.y.z` or `hotfix/x.y.z`.\n\n    Args:\n        branch: branch name to verify.\n        step: the release step name.\n\n    Returns:\n        An Issue if the current branch is not a release/hotfix else the\n        release type and version to release/hotfix.\n    \"\"\"\n    valid_prefix = ('release/', 'hotfix/')\n    if branch.startswith(valid_prefix):\n        parts = branch.split('/')\n        return Good((parts[0], parts[1]))\n    return issue(\n        f'{step}_release can only be done from a release/hotfix branch',\n        context={\n            'current_branch': branch,\n            'expected': 'release/x.y.z or hotfix/x.y.z',\n        },\n    )\n</code></pre>"},{"location":"api/m/ci/release_utils/#m.ci.release_utils.is_yes","title":"<code>is_yes(user_response)</code>","text":"<p>Assert the user response is \"yes\".</p> <p>Parameters:</p> Name Type Description Default <code>user_response</code> <code>str</code> <p>user's response</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the string is \"yes\".</p> Source code in <code>m/ci/release_utils.py</code> <pre><code>def is_yes(user_response: str) -&gt; bool:\n    \"\"\"Assert the user response is \"yes\".\n\n    Args:\n        user_response: user's response\n\n    Returns:\n        True if the string is \"yes\".\n    \"\"\"\n    return user_response == 'yes'\n</code></pre>"},{"location":"api/m/ci/review_release/","title":"review_release","text":""},{"location":"api/m/ci/review_release/#m.ci.review_release.acknowledge_git_status","title":"<code>acknowledge_git_status(status)</code>","text":"<p>Display the current git status and ask developer to confirm.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>The raw output of <code>git status</code>.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue to stop the operation, otherwise None.</p> Source code in <code>m/ci/review_release.py</code> <pre><code>def acknowledge_git_status(status: str) -&gt; Res[None]:\n    \"\"\"Display the current git status and ask developer to confirm.\n\n    Args:\n        status: The raw output of `git status`.\n\n    Returns:\n        An issue to stop the operation, otherwise None.\n    \"\"\"\n    logger.info('The following changes will be committed', {'git': status})\n    response = io.prompt_choices(\n        'proceed creating the pull request(s)?',\n        YES_NO,\n        as_list=False,\n    )\n    if is_yes(response):\n        return Good(None)\n    return issue('operation cancelled by user')\n</code></pre>"},{"location":"api/m/ci/review_release/#m.ci.review_release.create_prs","title":"<code>create_prs(gh_token, config, release_type, target_ver, gh_ver)</code>","text":"<p>Create release pull request(s).</p> <p>Parameters:</p> Name Type Description Default <code>gh_token</code> <code>str</code> <p>The GITHUB_TOKEN to use to make api calls to Github.</p> required <code>config</code> <code>Config</code> <p>The m configuration.</p> required <code>release_type</code> <code>str</code> <p>'hotfix' or 'release'.</p> required <code>target_ver</code> <code>str</code> <p>The version to release.</p> required <code>gh_ver</code> <code>str</code> <p>The current version in Github.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue if there is a problem while creating or None if successful.</p> Source code in <code>m/ci/review_release.py</code> <pre><code>def create_prs(\n    gh_token: str,\n    config: Config,\n    release_type: str,\n    target_ver: str,\n    gh_ver: str,\n) -&gt; Res[None]:\n    \"\"\"Create release pull request(s).\n\n    Args:\n        gh_token: The GITHUB_TOKEN to use to make api calls to Github.\n        config: The m configuration.\n        release_type: 'hotfix' or 'release'.\n        target_ver: The version to release.\n        gh_ver: The current version in Github.\n\n    Returns:\n        An issue if there is a problem while creating or None if successful.\n    \"\"\"\n    all_prs: dict[str, str] = {}\n    git_branch = f'{release_type}/{target_ver}'\n    develop_branch = config.get_develop_branch()\n    if config.uses_git_flow():\n        title = f'({release_type} to {develop_branch}) {target_ver}'\n        backport_pr = create_pr(\n            gh_token,\n            config.owner,\n            config.repo,\n            GithubPullRequest(\n                title=title,\n                body=_git_flow_pr_body(config, git_branch, gh_ver),\n                head=git_branch,\n                base=develop_branch,\n            ),\n        ).map(lambda res: cast(str, res.get('html_url', '')))\n        if isinstance(backport_pr, Bad):\n            logger.warning(\n                'unable to create backport pull request',\n                backport_pr.value,\n            )\n        else:\n            all_prs[title] = backport_pr.value\n    title = f'({release_type}) {target_ver}'\n    release_pr = create_pr(\n        gh_token,\n        config.owner,\n        config.repo,\n        GithubPullRequest(\n            title=title,\n            body=release_pr_body(config, gh_ver),\n            head=git_branch,\n            base=config.get_master_branch(),\n        ),\n    ).map(lambda res: cast(str, res.get('html_url', '')))\n    if isinstance(release_pr, Bad):\n        logger.warning(\n            'unable to create release pull request',\n            release_pr.value,\n        )\n    else:\n        all_prs[title] = release_pr.value\n    if all_prs:\n        logger.info('pull requests created', context=all_prs)\n        return Good(None)\n    return issue('no prs were created, inspect logs for hints')\n</code></pre>"},{"location":"api/m/ci/review_release/#m.ci.review_release.inspect_prs","title":"<code>inspect_prs(all_prs)</code>","text":"<p>Inspect the release pull requests.</p> <p>There should not be any pull requests when calling <code>review_release</code>. This is a one time operation.</p> <p>Parameters:</p> Name Type Description Default <code>all_prs</code> <code>list[PullRequest]</code> <p>The list of pull requests.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>An issue if prs already exist, None otherwise.</p> Source code in <code>m/ci/review_release.py</code> <pre><code>def inspect_prs(all_prs: list[PullRequest]) -&gt; Res[None]:\n    \"\"\"Inspect the release pull requests.\n\n    There should not be any pull requests when calling `review_release`.\n    This is a one time operation.\n\n    Args:\n        all_prs: The list of pull requests.\n\n    Returns:\n        An issue if prs already exist, None otherwise.\n    \"\"\"\n    prs = [pr for pr in all_prs if pr.closed is False]\n    if prs:\n        return issue('release is already in review', context={\n            'prs': {pr.number: pr.url for pr in prs},\n        })\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/review_release/#m.ci.review_release.release_pr_body","title":"<code>release_pr_body(config, gh_ver)</code>","text":"<p>Generate the pull request body.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>The <code>m</code> configuration.</p> required <code>gh_ver</code> <code>str</code> <p>The current version in Github.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The text to add to the pull request.</p> Source code in <code>m/ci/review_release.py</code> <pre><code>def release_pr_body(config: Config, gh_ver: str) -&gt; str:\n    \"\"\"Generate the pull request body.\n\n    Args:\n        config: The `m` configuration.\n        gh_ver: The current version in Github.\n\n    Returns:\n        The text to add to the pull request.\n    \"\"\"\n    link = compare_sha_url(config.owner, config.repo, gh_ver, 'HEAD')\n    instructions = (\n        '**DO NOT** use the merge button. Instead run `m end_release`.'\n        if config.uses_git_flow()\n        else 'either push the merge button or run `m end_release`'\n    )\n    return dedent(f\"\"\"\\\n        ## Reviewer directions\n\n        Verify `CHANGELOG.md` contains a summary of the unreleased changes.\n\n        {link}\n\n        ## Author directions\n\n        - Wait for reviewers to approve\n        - When approved, {instructions}\n    \"\"\")\n</code></pre>"},{"location":"api/m/ci/review_release/#m.ci.review_release.review_release","title":"<code>review_release(token)</code>","text":"<p>Create release prs.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The GITHUB_TOKEN to use to make api calls to Github.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, otherwise an issue.</p> Source code in <code>m/ci/review_release.py</code> <pre><code>def review_release(token: str) -&gt; Res[None]:\n    \"\"\"Create release prs.\n\n    Args:\n        token: The GITHUB_TOKEN to use to make api calls to Github.\n\n    Returns:\n        None if successful, otherwise an issue.\n    \"\"\"\n    return one_of(lambda: [\n        None\n        for branch in git.get_branch()\n        for release_type, target_ver in assert_branch(branch, 'review')\n        for config in read_config('m')\n        for prs in fetch_branch_prs(token, config.owner, config.repo, branch)\n        for _ in inspect_prs(prs)\n        for _ in git.stage_all()\n        for git_status in git.raw_status()\n        for _ in acknowledge_git_status(git_status)\n        for _ in _commit_changes(f'({release_type}) {target_ver}')\n        for _ in git.push_branch(branch)\n        for gh_ver in get_latest_release(token, config.owner, config.repo)\n        for _ in create_prs(token, config, release_type, target_ver, gh_ver)\n    ])\n</code></pre>"},{"location":"api/m/ci/start_release/","title":"start_release","text":""},{"location":"api/m/ci/start_release/#m.ci.start_release.after_checkout","title":"<code>after_checkout(branch_checkout, stashed)</code>","text":"<p>Notify the user that the branch has switched.</p> <p>Optionally if there are stashed changes they will be popped.</p> <p>Parameters:</p> Name Type Description Default <code>branch_checkout</code> <code>str</code> <p>output from git checkout.</p> required <code>stashed</code> <code>bool</code> <p>If True, it will run git stash pop.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>A OneOf with None. There should be no issues. A warning may show up.</p> Source code in <code>m/ci/start_release.py</code> <pre><code>def after_checkout(branch_checkout: str, stashed: bool) -&gt; Res[None]:\n    \"\"\"Notify the user that the branch has switched.\n\n    Optionally if there are stashed changes they will be popped.\n\n    Args:\n        branch_checkout: output from git checkout.\n        stashed: If True, it will run git stash pop.\n\n    Returns:\n        A OneOf with None. There should be no issues. A warning may show up.\n    \"\"\"\n    logger.info('branch checkout successful', {\n        'git': f'{branch_checkout}\\n',\n    })\n    if stashed:\n        pop_result = git.stash_pop()\n        if isinstance(pop_result, Bad):\n            logger.warning('`git stash pop` issue', pop_result.value)\n        else:\n            logger.info('stashed files have been restored')\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/start_release/#m.ci.start_release.assert_git_status","title":"<code>assert_git_status(status, description)</code>","text":"<p>Assert that the current branch is in a clean state.</p> <p>This action may stash some changes. This happens when the developer works on a hotfix and starts making changes directly in the branch.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>short key describing the status</p> required <code>description</code> <code>str</code> <p>The text used to determine the status</p> required <p>Returns:</p> Type Description <code>Res[bool]</code> <p>An issue explaining why we cannot complete the release setup. If</p> <code>Res[bool]</code> <p>successful it will return a boolean value. A true value means that</p> <code>Res[bool]</code> <p>the process stashed changes and they will need to be popped.</p> Source code in <code>m/ci/start_release.py</code> <pre><code>def assert_git_status(status: str, description: str) -&gt; Res[bool]:\n    \"\"\"Assert that the current branch is in a clean state.\n\n    This action may stash some changes. This happens when the developer works\n    on a hotfix and starts making changes directly in the branch.\n\n    Args:\n        status: short key describing the status\n        description: The text used to determine the status\n\n    Returns:\n        An issue explaining why we cannot complete the release setup. If\n        successful it will return a boolean value. A true value means that\n        the process stashed changes and they will need to be popped.\n    \"\"\"\n    if status == 'clean':\n        logger.info('branch is in a clean state')\n        return Good(False)\n    if status in {'ahead', 'behind'}:\n        return issue(\n            'branch is not in sync with the remote branch',\n            context={\n                'git_status': description,\n                'suggestion': 'try running `git pull` and/or `git push`',\n            },\n        )\n    can_stash = {\n        'Untracked files',\n        'Changes to be committed',\n        'Changed but not updated',\n        'Changes not staged',\n    }\n    if description in can_stash:\n        logger.warning(f'git status: {description}')\n        response = io.prompt_choices(\n            'would you like to stash the changes and continue?',\n            YES_NO,\n            as_list=False,\n        )\n        if is_yes(response):\n            return one_of(lambda: [\n                True\n                for cmd_out in git.stash()\n                for _ in logger.info('ran `git stash`', {'git': cmd_out})\n            ]).flat_map_bad(hone('git stash failure'))\n    return issue(\n        'releases can only be done in a clean git state',\n        context={\n            'git_status': status,\n            'description': description,\n        },\n    )\n</code></pre>"},{"location":"api/m/ci/start_release/#m.ci.start_release.start_release","title":"<code>start_release(gh_token, hotfix=False)</code>","text":"<p>Start the release process.</p> <p>Parameters:</p> Name Type Description Default <code>gh_token</code> <code>str</code> <p>The GITHUB_TOKEN to use to make api calls to Github.</p> required <code>hotfix</code> <code>bool</code> <p>Set to true to start a hotfix.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, otherwise an issue.</p> Source code in <code>m/ci/start_release.py</code> <pre><code>def start_release(gh_token: str, hotfix: bool = False) -&gt; Res[None]:\n    \"\"\"Start the release process.\n\n    Args:\n        gh_token: The GITHUB_TOKEN to use to make api calls to Github.\n        hotfix: Set to true to start a hotfix.\n\n    Returns:\n        None if successful, otherwise an issue.\n    \"\"\"\n    release_type = 'hotfix' if hotfix else 'release'\n    return one_of(lambda: [\n        None\n        for config in assert_branch(release_type, 'm')\n        for status, description in git.get_status()\n        for stashed_changes in assert_git_status(status, description)\n        for gh_ver in get_latest_release(gh_token, config.owner, config.repo)\n        for commits in _get_commits(gh_ver)\n        for _ in verify_release(commits, hotfix=hotfix)\n        for new_ver in io.prompt_next_version(gh_ver, release_type)\n        for branch_checkout in git.checkout_branch(f'{release_type}/{new_ver}')\n        for _ in after_checkout(branch_checkout, stashed_changes)\n        for _ in release_setup('m', config, new_ver)\n    ])\n</code></pre>"},{"location":"api/m/ci/start_release/#m.ci.start_release.verify_release","title":"<code>verify_release(commits, hotfix)</code>","text":"<p>Compare the number of commits to verify if the release should proceed.</p> <p>In some cases we may start a hotfix without realizing that there are already some commits in the branch that have not been released. In this case it should have been a full release instead.</p> <p>This step can be skipped if <code>commits</code> is <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>commits</code> <code>list[str] | None</code> <p>List of unreleased commits.</p> required <code>hotfix</code> <code>bool</code> <p>flag to let us know if the release is a hotfix.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if everything is good, otherwise an issue.</p> Source code in <code>m/ci/start_release.py</code> <pre><code>def verify_release(\n    commits: list[str] | None,\n    hotfix: bool,\n) -&gt; Res[None]:\n    \"\"\"Compare the number of commits to verify if the release should proceed.\n\n    In some cases we may start a hotfix without realizing that there are\n    already some commits in the branch that have not been released. In this\n    case it should have been a full release instead.\n\n    This step can be skipped if `commits` is `None`.\n\n    Args:\n        commits: List of unreleased commits.\n        hotfix: flag to let us know if the release is a hotfix.\n\n    Returns:\n        None if everything is good, otherwise an issue.\n    \"\"\"\n    if commits is None:\n        return Good(None)\n    if hotfix and len(commits):\n        logger.warning('hotfix may contain unreleased features', {\n            'commits': commits,\n        })\n        response = io.prompt_choices(\n            'Disregard warning and proceed with hotfix?',\n            YES_NO,\n            as_list=False,\n        )\n        if is_yes(response):\n            return Good(None)\n        return issue('hotfix aborted by user', context={\n            'commits': commits,\n            'suggestion': 'consider creating a release',\n        })\n    if not commits and not hotfix:\n        logger.warning('there are no commits to release')\n        response = io.prompt_choices(\n            'Proceed with a release instead of a hotfix?',\n            YES_NO,\n            as_list=False,\n        )\n        if is_yes(response):\n            return Good(None)\n        return issue('release aborted by user', context={\n            'commits': 'no commits to release',\n            'suggestion': 'consider creating a hotfix',\n        })\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/types/","title":"types","text":""},{"location":"api/m/ci/types/#m.ci.types.Branches","title":"<code>Branches</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Default branches to use for the supported workflows.</p> Source code in <code>m/ci/types.py</code> <pre><code>class Branches(str, Enum):  # noqa: WPS600\n    \"\"\"Default branches to use for the supported workflows.\"\"\"\n\n    master = 'master'\n    develop = 'develop'\n    release = 'release'\n    hotfix = 'hotfix'\n</code></pre>"},{"location":"api/m/ci/types/#m.ci.types.GitFlowConfig","title":"<code>GitFlowConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object mapping branches for the git_flow workflow.</p> <p>Attributes:</p> Name Type Description <code>master_branch</code> <code>str | Branches</code> <p>...</p> <code>develop_branch</code> <code>str | Branches</code> <p>...</p> <code>release_prefix</code> <code>str | Branches</code> <p>...</p> <code>hotfix_prefix</code> <code>str | Branches</code> <p>...</p> Source code in <code>m/ci/types.py</code> <pre><code>class GitFlowConfig(BaseModel):\n    \"\"\"An object mapping branches for the git_flow workflow.\"\"\"\n\n    master_branch: str | Branches = Branches.master\n    develop_branch: str | Branches = Branches.develop\n    release_prefix: str | Branches = Branches.release\n    hotfix_prefix: str | Branches = Branches.hotfix\n</code></pre>"},{"location":"api/m/ci/types/#m.ci.types.MFlowConfig","title":"<code>MFlowConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object mapping branches for the m_flow workflow.</p> <p>Attributes:</p> Name Type Description <code>master_branch</code> <code>str | Branches</code> <p>...</p> <code>release_prefix</code> <code>str | Branches</code> <p>...</p> <code>hotfix_prefix</code> <code>str | Branches</code> <p>...</p> Source code in <code>m/ci/types.py</code> <pre><code>class MFlowConfig(BaseModel):\n    \"\"\"An object mapping branches for the m_flow workflow.\"\"\"\n\n    master_branch: str | Branches = Branches.master\n    release_prefix: str | Branches = Branches.release\n    hotfix_prefix: str | Branches = Branches.hotfix\n</code></pre>"},{"location":"api/m/ci/types/#m.ci.types.Workflow","title":"<code>Workflow</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Supported workflows.</p> Source code in <code>m/ci/types.py</code> <pre><code>class Workflow(str, Enum):  # noqa: WPS600\n    \"\"\"Supported workflows.\"\"\"\n\n    git_flow = 'git_flow'\n    m_flow = 'm_flow'\n    free_flow = 'free_flow'\n\n    def __str__(self: 'Workflow') -&gt; str:\n        \"\"\"Return the string representation of the workflow.\n\n        Returns:\n            The string representation of the workflow.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"api/m/ci/types/#m.ci.types.Workflow.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the workflow.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the workflow.</p> Source code in <code>m/ci/types.py</code> <pre><code>def __str__(self: 'Workflow') -&gt; str:\n    \"\"\"Return the string representation of the workflow.\n\n    Returns:\n        The string representation of the workflow.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"api/m/ci/versioning/","title":"versioning","text":""},{"location":"api/m/ci/versioning/#m.ci.versioning.VersionInputs","title":"<code>VersionInputs</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Container with information to generate a version.</p> <p>Attributes:</p> Name Type Description <code>version_prefix</code> <code>str</code> <p>...</p> <code>version</code> <code>str</code> <p>...</p> <code>run_id</code> <code>str | None</code> <p>...</p> <code>sha</code> <code>str</code> <p>...</p> <code>pr_number</code> <code>int | None</code> <p>...</p> <code>branch</code> <code>str</code> <p>...</p> <code>is_release</code> <code>bool</code> <p>...</p> <code>is_release_pr</code> <code>bool</code> <p>...</p> <code>is_hotfix_pr</code> <code>bool</code> <p>...</p> Source code in <code>m/ci/versioning.py</code> <pre><code>class VersionInputs(BaseModel):\n    \"\"\"Container with information to generate a version.\"\"\"\n\n    # '0.0.0-' or 'a.b.c-' or '': Necessary for pr builds\n    version_prefix: str\n\n    # the version in the configuration\n    version: str\n\n    # unique number for each run in CI environment\n    run_id: str | None\n\n    # current commit sha\n    sha: str\n\n    pr_number: int | None\n\n    # The build git branch\n    branch: str\n\n    is_release: bool\n    is_release_pr: bool\n    is_hotfix_pr: bool\n</code></pre>"},{"location":"api/m/ci/versioning/#m.ci.versioning.build_m_tag","title":"<code>build_m_tag(ver_input, config)</code>","text":"<p>Build an valid \"M_TAG\".</p> <p>Parameters:</p> Name Type Description Default <code>ver_input</code> <code>VersionInputs</code> <p>The inputs to create the tag.</p> required <code>config</code> <code>Config</code> <p>The m configuration.</p> required <p>Returns:</p> Type Description <code>str</code> <p>An m tag that can be used to version npm and docker packages.</p> Source code in <code>m/ci/versioning.py</code> <pre><code>def build_m_tag(ver_input: VersionInputs, config: Config) -&gt; str:\n    \"\"\"Build an valid \"M_TAG\".\n\n    Args:\n        ver_input: The inputs to create the tag.\n        config: The m configuration.\n\n    Returns:\n        An m tag that can be used to version npm and docker packages.\n    \"\"\"\n    prefix = '' if config.uses_free_flow() else f'{ver_input.version_prefix}-'\n    pr_number = ver_input.pr_number\n    run_id = ver_input.run_id\n    if not run_id:\n        return f'{prefix}local.{ver_input.sha}'\n    if ver_input.is_release:\n        return ver_input.version\n    if pr_number:\n        nprefix = ''\n        if ver_input.is_release_pr:\n            nprefix = 'rc'\n        elif ver_input.is_hotfix_pr:\n            nprefix = 'hotfix'\n        if nprefix:\n            return f'{ver_input.version}-{nprefix}{pr_number}.b{run_id}'\n        return f'{prefix}pr{pr_number}.b{run_id}'\n    return f'{prefix}{ver_input.branch}.b{run_id}'\n</code></pre>"},{"location":"api/m/ci/versioning/#m.ci.versioning.build_py_tag","title":"<code>build_py_tag(ver_input, config)</code>","text":"<p>Build a valid python version.</p> <p>The configuration object is provided since python does not accept using names of branches in the versions. For this reason we will map</p> <p>Parameters:</p> Name Type Description Default <code>ver_input</code> <code>VersionInputs</code> <p>The inputs to create the version.</p> required <code>config</code> <code>Config</code> <p>The m configuration.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A valid python tag.</p> Source code in <code>m/ci/versioning.py</code> <pre><code>def build_py_tag(ver_input: VersionInputs, config: Config) -&gt; str:\n    \"\"\"Build a valid python version.\n\n    The configuration object is provided since python does not accept using\n    names of branches in the versions. For this reason we will map\n\n    Args:\n        ver_input: The inputs to create the version.\n        config: The m configuration.\n\n    Returns:\n        A valid python tag.\n    \"\"\"\n    prefix = ver_input.version_prefix\n    pr_number = ver_input.pr_number\n    run_id = ver_input.run_id\n    now = int(time.time())\n    if not run_id:\n        return f'{prefix}a0+b{now}'\n    if ver_input.is_release:\n        return ver_input.version\n    if pr_number:\n        nprefix = ''\n        if ver_input.is_release_pr or ver_input.is_hotfix_pr:\n            nprefix = 'rc'\n        if nprefix:\n            return f'{ver_input.version}{nprefix}{pr_number}.dev{run_id}'\n        return f'{prefix}b{pr_number}.dev{run_id}'\n    nprefix = _get_py_branch_prefix(config, ver_input.branch)\n    return f'{prefix}{nprefix}.dev{run_id}'\n</code></pre>"},{"location":"api/m/ci/celt/","title":"celt","text":""},{"location":"api/m/ci/celt/post_processor/","title":"post_processor","text":""},{"location":"api/m/ci/celt/post_processor/#m.ci.celt.post_processor.get_post_processor","title":"<code>get_post_processor(name, celt_config)</code>","text":"<p>Find an available post processor based on the key provided.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the post processor</p> required <code>celt_config</code> <code>Configuration</code> <p>The configuration to use</p> required <p>Returns:</p> Type Description <code>Res[PostProcessor]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a post processor function.</p> Source code in <code>m/ci/celt/post_processor.py</code> <pre><code>def get_post_processor(\n    name: str,\n    celt_config: Configuration,\n) -&gt; Res[PostProcessor]:\n    \"\"\"Find an available post processor based on the key provided.\n\n    Args:\n        name: name of the post processor\n        celt_config: The configuration to use\n\n    Returns:\n        A `OneOf` containing an `Issue` or a post processor function.\n    \"\"\"\n    mapping: Dict[str, Transform] = {\n        'eslint': eslint.read_payload,\n        'pycodestyle': pycodestyle.read_payload,\n        'flake8': pycodestyle.read_payload,\n        'pylint': pylint.read_payload,\n        'typescript': typescript.read_payload,\n        'ruff': ruff.read_payload,\n    }\n    if name not in mapping:\n        return issue(f'{name} is not a supported post processor')\n\n    return Good(PostProcessor(name, celt_config, mapping[name]))\n</code></pre>"},{"location":"api/m/ci/celt/core/","title":"core","text":""},{"location":"api/m/ci/celt/core/io/","title":"io","text":""},{"location":"api/m/ci/celt/core/io/#m.ci.celt.core.io.format_row","title":"<code>format_row(tokens, widths, alignment)</code>","text":"<p>Format a row to be displayed in a table.</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>List[Any]</code> <p>A list of values to be displayed.</p> required <code>widths</code> <code>List[int]</code> <p>A list of integers of same size as tokens dictating the how many spaces to take for a token.</p> required <code>alignment</code> <code>str</code> <p>Either 'l' or 'r' so that the tokens may be aligned on the left or right.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A single string for a row of a table.</p> Source code in <code>m/ci/celt/core/io.py</code> <pre><code>def format_row(tokens: List[Any], widths: List[int], alignment: str) -&gt; str:\n    \"\"\"Format a row to be displayed in a table.\n\n    Args:\n        tokens:\n            A list of values to be displayed.\n        widths:\n            A list of integers of same size as tokens dictating the how many\n            spaces to take for a token.\n        alignment:\n            Either 'l' or 'r' so that the tokens may be aligned on the left\n            or right.\n\n    Returns:\n        A single string for a row of a table.\n    \"\"\"\n    return '  '.join([\n        token\n        for index, align in enumerate(alignment)\n        for token in (_align(tokens[index], align)(widths[index]),)\n    ])\n</code></pre>"},{"location":"api/m/ci/celt/core/io/#m.ci.celt.core.io.project_stats_json","title":"<code>project_stats_json(name, project)</code>","text":"<p>Stringify a <code>ProjectStatus</code> instance.</p> <p>Displays as json showing the current total of violations for each rule.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the compiler/linter.</p> required <code>project</code> <code>ProjectStatus</code> <p>The <code>ProjectStatus</code> instance.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string version of the project status.</p> Source code in <code>m/ci/celt/core/io.py</code> <pre><code>def project_stats_json(\n    name: str,\n    project: ProjectStatus,\n) -&gt; str:\n    \"\"\"Stringify a `ProjectStatus` instance.\n\n    Displays as json showing the current total of violations for each rule.\n\n    Args:\n        name: The name of the compiler/linter.\n        project: The `ProjectStatus` instance.\n\n    Returns:\n        The string version of the project status.\n    \"\"\"\n    cap_name = name.capitalize()\n    buffer = [\n        '{',\n        f'  \"allowed{cap_name}Rules\": {{',\n    ]\n\n    key_rule = sorted(\n        [\n            x\n            for x in project.rules.items()\n            if x[1].found &gt; 0 and not x[1].ignored\n        ],\n        key=cmp_to_key(_compare_rule_items),\n    )\n\n    if key_rule:\n        buffer.extend([\n            f'    \"{rule_id}\": {rule.found},'\n            for rule_id, rule in key_rule[:-1]\n        ])\n        rule_id, rule = key_rule[-1]\n        buffer.append(f'    \"{rule_id}\": {rule.found}')\n\n    buffer.extend([\n        '  }',\n        '}',\n    ])\n    return '\\n'.join(buffer)\n</code></pre>"},{"location":"api/m/ci/celt/core/io/#m.ci.celt.core.io.project_status_str","title":"<code>project_status_str(project, celt_config)</code>","text":"<p>Stringify a <code>ProjectStatus</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>ProjectStatus</code> <p>The <code>ProjectStatus</code> instance.</p> required <code>celt_config</code> <code>Configuration</code> <p>The post processor configuration.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string version of the project status.</p> Source code in <code>m/ci/celt/core/io.py</code> <pre><code>def project_status_str(\n    project: ProjectStatus,\n    celt_config: Configuration,\n) -&gt; str:\n    \"\"\"Stringify a `ProjectStatus` instance.\n\n    Args:\n        project: The `ProjectStatus` instance.\n        celt_config: The post processor configuration.\n\n    Returns:\n        The string version of the project status.\n    \"\"\"\n    keys = project.rules.keys()\n    rules = sorted(project.rules.values(), key=cmp_to_key(_compare_rules))\n\n    if project.status == ExitCode.ok:\n        buffer = [\n            rule_info_str(rule, celt_config)\n            for rule in rules\n            if rule.ignored\n        ]\n        if project.total_found &gt; 0:\n            buffer.append(\n                color(\n                    '{gray}project has ',\n                    f'{{red}}{project.total_found} errors',\n                    '{gray} to clear',\n                ),\n            )\n        else:\n            msg = 'no errors found'\n            buffer.append(color(f'{{bold_green}}{msg}'))\n        return '\\n'.join(buffer)\n\n    buffer = [\n        rule_info_str(rule, celt_config)\n        for rule in rules\n        if rule.found &gt; rule.allowed\n    ]\n\n    buffer.append(color('{bold}FILES:'))\n    by_file = sorted(project.files.items(), key=lambda t: len(t[1]))\n    buffer.extend([\n        color(f'  {{gray}}{file_name}:{{end}} found {total}')\n        for file_name, violations in by_file\n        for total in (len(violations), )\n    ])\n    buffer.append('')\n\n    c1_w = max((len(x) for x in keys))\n    c1_w = max([c1_w, len('rules')])\n    c2_w = max((len(str(s.found)) for s in rules))\n    c2_w = max([c2_w, len('found')])\n    c3_w = max((len(str(s.allowed)) for s in rules))\n    c3_w = max([c3_w, len('allowed')])\n    widths = [c1_w, c2_w, c3_w]\n\n    key_rule = sorted(\n        project.rules.items(),\n        key=cmp_to_key(_compare_rule_items),\n    )\n    buffer.append(format_row(['RULES', 'FOUND', 'ALLOWED'], widths, 'lll'))\n    buffer.extend([\n        (\n            color(\n                '{gray}',\n                format_row([rule_id, rule.found, rule.allowed], widths, 'lrr'),\n            )\n            if rule.found == rule.allowed\n            else format_row([rule_id, rule.found, rule.allowed], widths, 'lrr')\n        )\n        for rule_id, rule in key_rule\n        if not rule.ignored\n    ])\n    buffer.append('')\n    return '\\n'.join(buffer)\n</code></pre>"},{"location":"api/m/ci/celt/core/io/#m.ci.celt.core.io.rule_info_str","title":"<code>rule_info_str(rule, config)</code>","text":"<p>Format a single rule and its violations.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>RuleInfo</code> <p>The rule to display.</p> required <code>config</code> <code>Configuration</code> <p>The post processor configuration.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the rule info.</p> Source code in <code>m/ci/celt/core/io.py</code> <pre><code>def rule_info_str(\n    rule: RuleInfo,\n    config: Configuration,\n) -&gt; str:\n    \"\"\"Format a single rule and its violations.\n\n    Args:\n        rule: The rule to display.\n        config: The post processor configuration.\n\n    Returns:\n        A string representation of the rule info.\n    \"\"\"\n    allowed = 'IGNORED' if rule.ignored else f'allowed {rule.allowed}'\n    rule_id = color(f'{{red}}{rule.rule_id}{{end}}')\n    total_found = color(f'{{red}}{rule.found}{{end}}')\n    buffer = [f'{rule_id} (found {total_found}, {allowed}):']\n    violations = (\n        rule.violations\n        if config.max_lines == -1\n        else rule.violations[:config.max_lines]\n    )\n    for violation in violations:\n        file_path = violation.file_path\n        msg, *rest = violation.message.splitlines()\n        line = violation.line\n        column = violation.column\n        file_loc = color(f'{{gray}}{file_path}:{line}:{column}{{end}}')\n        buffer.append(f'  {file_loc} - {msg}')\n        if rest and config.full_message:\n            buffer.extend([f'    {x}' for x in rest])\n    if -1 &lt; config.max_lines &lt; len(rule.violations):\n        remaining = len(rule.violations) - config.max_lines\n        buffer.append(f'  ... and {remaining} more')\n    buffer.append('')\n    return '\\n'.join(buffer)\n</code></pre>"},{"location":"api/m/ci/celt/core/process/","title":"process","text":""},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.PostProcessor","title":"<code>PostProcessor</code>","text":"<p>A post processor to handle a compiler/linter ouput.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>class PostProcessor:\n    \"\"\"A post processor to handle a compiler/linter ouput.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        celt_config: Configuration,\n        transform: Transform,\n    ):\n        \"\"\"Instantiate a `PostProcessor`.\n\n        Args:\n            name: The name of the compiler/linter.\n            celt_config: The post processor configuration.\n            transform: Function to generate a list of `FileReport` objects.\n        \"\"\"\n        self.name = name\n        self.celt_config = celt_config\n        self.transform = transform\n\n    def run(\n        self,\n        payload: str,\n        config: Dict[str, Any],\n    ) -&gt; Res[ProjectStatus]:\n        \"\"\"Run the processor on the given payload.\n\n        Args:\n            payload: The payload from the compiler/linter.\n            config: A dictionary with rule allowance/ignores.\n\n        Returns:\n            A `OneOf` containing an `Issue` or the `ProjectStatus`.\n        \"\"\"\n        cap_name = self.name.capitalize()\n        allowed_rules = config.get(f'allowed{cap_name}Rules', {})\n        if self.celt_config.ignore_error_allowance:\n            allowed_rules = {}\n        ignored_rules = config.get(f'ignored{cap_name}Rules', {})\n        return process(\n            payload,\n            self.transform,\n            allowed_rules,\n            ignored_rules,\n            self.celt_config,\n        )\n\n    def to_str(self, project: ProjectStatus) -&gt; str:\n        \"\"\"Stringify a `ProjectStatus`.\n\n        Args:\n            project: The `ProjectStatus` obtained by running the `run` method.\n\n        Returns:\n            The string version of the project status.\n        \"\"\"\n        return project_status_str(project, self.celt_config)\n\n    def stats_json(self, project: ProjectStatus) -&gt; str:\n        \"\"\"Stringify a `ProjectStatus`.\n\n        Show a dictionary with the total number of violations. Useful when\n        writing an entry for the configuration file.\n\n        Args:\n            project: The `ProjectStatus` obtained by running the `run` method.\n\n        Returns:\n            The string version of the project status.\n        \"\"\"\n        return project_stats_json(self.name, project)\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.PostProcessor.__init__","title":"<code>__init__(name, celt_config, transform)</code>","text":"<p>Instantiate a <code>PostProcessor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the compiler/linter.</p> required <code>celt_config</code> <code>Configuration</code> <p>The post processor configuration.</p> required <code>transform</code> <code>Transform</code> <p>Function to generate a list of <code>FileReport</code> objects.</p> required Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    celt_config: Configuration,\n    transform: Transform,\n):\n    \"\"\"Instantiate a `PostProcessor`.\n\n    Args:\n        name: The name of the compiler/linter.\n        celt_config: The post processor configuration.\n        transform: Function to generate a list of `FileReport` objects.\n    \"\"\"\n    self.name = name\n    self.celt_config = celt_config\n    self.transform = transform\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.PostProcessor.run","title":"<code>run(payload, config)</code>","text":"<p>Run the processor on the given payload.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The payload from the compiler/linter.</p> required <code>config</code> <code>Dict[str, Any]</code> <p>A dictionary with rule allowance/ignores.</p> required <p>Returns:</p> Type Description <code>Res[ProjectStatus]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the <code>ProjectStatus</code>.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def run(\n    self,\n    payload: str,\n    config: Dict[str, Any],\n) -&gt; Res[ProjectStatus]:\n    \"\"\"Run the processor on the given payload.\n\n    Args:\n        payload: The payload from the compiler/linter.\n        config: A dictionary with rule allowance/ignores.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the `ProjectStatus`.\n    \"\"\"\n    cap_name = self.name.capitalize()\n    allowed_rules = config.get(f'allowed{cap_name}Rules', {})\n    if self.celt_config.ignore_error_allowance:\n        allowed_rules = {}\n    ignored_rules = config.get(f'ignored{cap_name}Rules', {})\n    return process(\n        payload,\n        self.transform,\n        allowed_rules,\n        ignored_rules,\n        self.celt_config,\n    )\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.PostProcessor.stats_json","title":"<code>stats_json(project)</code>","text":"<p>Stringify a <code>ProjectStatus</code>.</p> <p>Show a dictionary with the total number of violations. Useful when writing an entry for the configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>ProjectStatus</code> <p>The <code>ProjectStatus</code> obtained by running the <code>run</code> method.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string version of the project status.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def stats_json(self, project: ProjectStatus) -&gt; str:\n    \"\"\"Stringify a `ProjectStatus`.\n\n    Show a dictionary with the total number of violations. Useful when\n    writing an entry for the configuration file.\n\n    Args:\n        project: The `ProjectStatus` obtained by running the `run` method.\n\n    Returns:\n        The string version of the project status.\n    \"\"\"\n    return project_stats_json(self.name, project)\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.PostProcessor.to_str","title":"<code>to_str(project)</code>","text":"<p>Stringify a <code>ProjectStatus</code>.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>ProjectStatus</code> <p>The <code>ProjectStatus</code> obtained by running the <code>run</code> method.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string version of the project status.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def to_str(self, project: ProjectStatus) -&gt; str:\n    \"\"\"Stringify a `ProjectStatus`.\n\n    Args:\n        project: The `ProjectStatus` obtained by running the `run` method.\n\n    Returns:\n        The string version of the project status.\n    \"\"\"\n    return project_status_str(project, self.celt_config)\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.filter_reports","title":"<code>filter_reports(reports, regex=None)</code>","text":"<p>Filter the list of file reports based on the file path.</p> <p>It also removes any file report that does not have any violations.</p> <p>Parameters:</p> Name Type Description Default <code>reports</code> <code>List[FileReport]</code> <p>List of file reports.</p> required <code>regex</code> <code>Optional[str]</code> <p>The post processor configuration.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[FileReport]</code> <p>A list of file reports with at least one violation and file_path</p> <code>List[FileReport]</code> <p>matching the provided regex.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def filter_reports(\n    reports: List[FileReport],\n    regex: Optional[str] = None,\n) -&gt; List[FileReport]:\n    \"\"\"Filter the list of file reports based on the file path.\n\n    It also removes any file report that does not have any violations.\n\n    Args:\n        reports: List of file reports.\n        regex: The post processor configuration.\n\n    Returns:\n        A list of file reports with at least one violation and file_path\n        matching the provided regex.\n    \"\"\"\n    return [\n        rpt\n        for rpt in reports\n        if rpt.violations and (not regex or re.match(regex, rpt.file_path))\n    ]\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.get_project_status","title":"<code>get_project_status(payload, reports, rules_dict, allowed_rules, ignored_rules)</code>","text":"<p>Analyze the rules_dictionary with the allowed and ignored rules.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The original payload from the compiler/linter.</p> required <code>reports</code> <code>List[FileReport]</code> <p>List of file reports.</p> required <code>rules_dict</code> <code>Dict[str, List[Violation]]</code> <p>A map of rule ids to a list of violations.</p> required <code>allowed_rules</code> <code>Dict[str, int]</code> <p>A dictionary specifying the allowed violations.</p> required <code>ignored_rules</code> <code>Dict[str, str]</code> <p>A dictionary specifying the rules to ignore.</p> required <p>Returns:</p> Type Description <code>ProjectStatus</code> <p>A ProjectStatus object.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def get_project_status(\n    payload: str,\n    reports: List[FileReport],\n    rules_dict: Dict[str, List[Violation]],\n    allowed_rules: Dict[str, int],\n    ignored_rules: Dict[str, str],\n) -&gt; ProjectStatus:\n    \"\"\"Analyze the rules_dictionary with the allowed and ignored rules.\n\n    Args:\n        payload: The original payload from the compiler/linter.\n        reports: List of file reports.\n        rules_dict: A map of rule ids to a list of violations.\n        allowed_rules: A dictionary specifying the allowed violations.\n        ignored_rules: A dictionary specifying the rules to ignore.\n\n    Returns:\n        A ProjectStatus object.\n    \"\"\"\n    rules: Dict[str, RuleInfo] = {}\n    files: Dict[str, List[Violation]] = {\n        x.file_path: x.violations\n        for x in reports\n    }\n\n    failed, needs_readjustment = _process_rules_dict(\n        rules_dict, allowed_rules, ignored_rules, rules,\n    )\n\n    for rule_id, allowed in allowed_rules.items():\n        if rule_id not in rules:\n            rules[rule_id] = RuleInfo(rule_id, [], 0, allowed, ignored=False)\n            if allowed &gt; 0:\n                needs_readjustment = True\n\n    status = ExitCode.ok\n    if failed:\n        status = ExitCode.error\n    elif needs_readjustment:\n        status = ExitCode.needs_readjustment\n    return ProjectStatus(status, payload, rules, files)\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.process","title":"<code>process(raw_payload, transform, allowed_rules, ignored_rules, celt_config)</code>","text":"<p>Process the output of a compiler/linter.</p> <p>Parameters:</p> Name Type Description Default <code>raw_payload</code> <code>str</code> <p>The payload from the compiler/linter.</p> required <code>transform</code> <code>Transform</code> <p>Function to generate a list of <code>FileReport</code> objects.</p> required <code>allowed_rules</code> <code>Dict[str, int]</code> <p>A dictionary specifying the allowed violations.</p> required <code>ignored_rules</code> <code>Dict[str, str]</code> <p>A dictionary specifying the rules to ignore.</p> required <code>celt_config</code> <code>Configuration</code> <p>The post processor configuration.</p> required <p>Returns:</p> Type Description <code>Res[ProjectStatus]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a <code>ProjectStatus</code> object.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def process(\n    raw_payload: str,\n    transform: Transform,\n    allowed_rules: Dict[str, int],\n    ignored_rules: Dict[str, str],\n    celt_config: Configuration,\n) -&gt; Res[ProjectStatus]:\n    \"\"\"Process the output of a compiler/linter.\n\n    Args:\n        raw_payload: The payload from the compiler/linter.\n        transform: Function to generate a list of `FileReport` objects.\n        allowed_rules: A dictionary specifying the allowed violations.\n        ignored_rules: A dictionary specifying the rules to ignore.\n        celt_config: The post processor configuration.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a `ProjectStatus` object.\n    \"\"\"\n    return one_of(lambda: [\n        project_status\n        for payload in replace_filenames(raw_payload, celt_config.file_prefix)\n        for reports in transform(payload)\n        for filtered in (filter_reports(reports, celt_config.file_regex),)\n        for rules_dict in (to_rules_dict(filtered),)\n        for project_status in (\n            get_project_status(\n                payload, filtered, rules_dict, allowed_rules, ignored_rules,\n            ),\n        )\n    ])\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.replace_filenames","title":"<code>replace_filenames(payload, file_prefix)</code>","text":"<p>Replace the prefix of file names.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>str The payload from a compiler/linter.</p> required <code>file_prefix</code> <code>Optional[str]</code> <p>Optional[str] A string of the form <code>[old]:[new]</code>. The old prefix can be a <code>|</code> separated list of strings. For instance <code>path/to/foo|path/to:bar</code></p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A <code>OneOf</code> containing an Issue or the <code>payload</code> with all file path</p> <code>Res[str]</code> <p>replaced according to the file_prefix.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def replace_filenames(\n    payload: str,\n    file_prefix: Optional[str],\n) -&gt; Res[str]:\n    \"\"\"Replace the prefix of file names.\n\n    Args:\n        payload: str\n            The payload from a compiler/linter.\n        file_prefix: Optional[str]\n            A string of the form `[old]:[new]`. The old prefix can be\n            a `|` separated list of strings. For instance\n            `path/to/foo|path/to:bar`\n\n    Returns:\n        A `OneOf` containing an Issue or the `payload` with all file path\n        replaced according to the file_prefix.\n    \"\"\"\n    if not file_prefix:\n        return Good(payload)\n    try:\n        old, prefix = file_prefix.split(':')\n    except ValueError as ex:\n        return issue('file_prefix param missing `:`', cause=ex)\n    return Good(re.sub(\n        fr'({old})(.*?)\\.([a-z]+)',\n        lambda x: [\n            # Not sure how fix this mypy issue\n            f'{prefix}{filename}.{ext}'  # type: ignore\n            for _, filename, ext in (x.groups(),)\n        ][0],\n        payload,\n    ))\n</code></pre>"},{"location":"api/m/ci/celt/core/process/#m.ci.celt.core.process.to_rules_dict","title":"<code>to_rules_dict(reports)</code>","text":"<p>Convert a list of <code>FileReport</code> to a map of rules to <code>Violation</code>.</p> <p>Parameters:</p> Name Type Description Default <code>reports</code> <code>List[FileReport]</code> <p>A list of <code>FileReport</code> instances.</p> required <p>Returns:</p> Type Description <code>Dict[str, List[Violation]]</code> <p>A dictionary mapping rules to a list of <code>Violation</code>.</p> Source code in <code>m/ci/celt/core/process.py</code> <pre><code>def to_rules_dict(reports: List[FileReport]) -&gt; Dict[str, List[Violation]]:\n    \"\"\"Convert a list of `FileReport` to a map of rules to `Violation`.\n\n    Args:\n        reports: A list of `FileReport` instances.\n\n    Returns:\n        A dictionary mapping rules to a list of `Violation`.\n    \"\"\"\n    rules: Dict[str, List[Violation]] = {}\n    for report in reports:\n        for violation in report.violations:\n            if violation.rule_id not in rules:\n                rules[violation.rule_id] = []\n            rules[violation.rule_id].append(violation)\n    return rules\n</code></pre>"},{"location":"api/m/ci/celt/core/types/","title":"types","text":""},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>Options to control the output of the post processor.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>@dataclass\nclass Configuration:\n    \"\"\"Options to control the output of the post processor.\"\"\"\n\n    max_lines: int = 5\n    full_message: bool = False\n    ignore_error_allowance: bool = False\n    file_regex: Optional[str] = None\n    file_prefix: Optional[str] = None\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.ExitCode","title":"<code>ExitCode</code>","text":"<p>             Bases: <code>Enum</code></p> <p>One of the possible exit codes.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>class ExitCode(enum.Enum):\n    \"\"\"One of the possible exit codes.\"\"\"\n\n    ok = 0\n    error = 1\n    needs_readjustment = 2\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.FileReport","title":"<code>FileReport</code>  <code>dataclass</code>","text":"<p>Collection of violations triggered in a single file.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>@dataclass\nclass FileReport:\n    \"\"\"Collection of violations triggered in a single file.\"\"\"\n\n    file_path: str\n    violations: List[Violation]\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.ProjectStatus","title":"<code>ProjectStatus</code>  <code>dataclass</code>","text":"<p>Overview of a project.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>@dataclass\nclass ProjectStatus:\n    \"\"\"Overview of a project.\"\"\"\n\n    status: ExitCode\n    payload: str\n    rules: Dict[str, RuleInfo]\n    files: Dict[str, List[Violation]]\n    total_found: int = field(init=False)\n    total_allowed: int = field(init=False)\n    error_msg: str = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"Compute the rest of non initialized variables.\"\"\"\n        rules = self.rules.values()\n        total_found = sum((s.found for s in rules if not s.ignored))\n        total_allowed = sum((s.allowed for s in rules if not s.ignored))\n        error_msg = ''\n        if self.status == ExitCode.error:\n            diff = sum((\n                d\n                for s in rules\n                for d in (s.found - s.allowed,)\n                if d &gt; 0 and not s.ignored\n            ))\n            error_msg = f'{diff} extra errors were introduced'\n        elif self.status == ExitCode.needs_readjustment:\n            diff = total_allowed - total_found\n            error_msg = f'{diff} errors were removed - lower error allowance'\n\n        self.total_found = total_found  # noqa: WPS601\n        self.total_allowed = total_allowed  # noqa: WPS601\n        self.error_msg = error_msg  # noqa: WPS601\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.ProjectStatus.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Compute the rest of non initialized variables.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Compute the rest of non initialized variables.\"\"\"\n    rules = self.rules.values()\n    total_found = sum((s.found for s in rules if not s.ignored))\n    total_allowed = sum((s.allowed for s in rules if not s.ignored))\n    error_msg = ''\n    if self.status == ExitCode.error:\n        diff = sum((\n            d\n            for s in rules\n            for d in (s.found - s.allowed,)\n            if d &gt; 0 and not s.ignored\n        ))\n        error_msg = f'{diff} extra errors were introduced'\n    elif self.status == ExitCode.needs_readjustment:\n        diff = total_allowed - total_found\n        error_msg = f'{diff} errors were removed - lower error allowance'\n\n    self.total_found = total_found  # noqa: WPS601\n    self.total_allowed = total_allowed  # noqa: WPS601\n    self.error_msg = error_msg  # noqa: WPS601\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.RuleInfo","title":"<code>RuleInfo</code>  <code>dataclass</code>","text":"<p>Stats on a rule.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>@dataclass\nclass RuleInfo:\n    \"\"\"Stats on a rule.\"\"\"\n\n    rule_id: str\n    violations: List[Violation]\n    found: int\n    allowed: int = 0\n    ignored: bool = False\n</code></pre>"},{"location":"api/m/ci/celt/core/types/#m.ci.celt.core.types.Violation","title":"<code>Violation</code>  <code>dataclass</code>","text":"<p>An error/warning/message provided by a compiler or linter.</p> Source code in <code>m/ci/celt/core/types.py</code> <pre><code>@dataclass\nclass Violation:\n    \"\"\"An error/warning/message provided by a compiler or linter.\"\"\"\n\n    rule_id: str\n    message: str\n    line: int\n    column: int\n    file_path: str\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/","title":"post_processors","text":""},{"location":"api/m/ci/celt/post_processors/eslint/","title":"eslint","text":""},{"location":"api/m/ci/celt/post_processors/eslint/#m.ci.celt.post_processors.eslint.read_payload","title":"<code>read_payload(payload)</code>","text":"<p>Transform an eslint payload to a list of <code>FileReport</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The raw payload from eslint.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, List[FileReport]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of <code>FileReport</code> instances.</p> Source code in <code>m/ci/celt/post_processors/eslint.py</code> <pre><code>def read_payload(payload: str) -&gt; OneOf[Issue, List[FileReport]]:\n    \"\"\"Transform an eslint payload to a list of `FileReport` instances.\n\n    Args:\n        payload: The raw payload from eslint.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of `FileReport` instances.\n    \"\"\"\n    return one_of(lambda: [\n        [\n            FileReport(\n                file_path=error['filePath'],\n                violations=[\n                    Violation(\n                        msg['ruleId'],\n                        msg['message'],\n                        msg['line'],\n                        msg['column'],\n                        error['filePath'],\n                    )\n                    for msg in error['messages']\n                ],\n            )\n            for error in json_payload\n        ]\n        for json_payload in json.parse_json(payload)\n    ])\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/pycodestyle/","title":"pycodestyle","text":""},{"location":"api/m/ci/celt/post_processors/pycodestyle/#m.ci.celt.post_processors.pycodestyle.read_payload","title":"<code>read_payload(payload)</code>","text":"<p>Transform a pycodestyle payload to a list of <code>FileReport</code> instances.</p> <p>This function can be used with flake8 and other tools that emit similar output.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The raw payload from pycodestyle.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, List[FileReport]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of <code>FileReport</code> instances.</p> Source code in <code>m/ci/celt/post_processors/pycodestyle.py</code> <pre><code>def read_payload(payload: str) -&gt; OneOf[Issue, List[FileReport]]:\n    \"\"\"Transform a pycodestyle payload to a list of `FileReport` instances.\n\n    This function can be used with flake8 and other tools that emit similar\n    output.\n\n    Args:\n        payload: The raw payload from pycodestyle.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of `FileReport` instances.\n    \"\"\"\n    regex = r'(.*):(\\d+):(\\d+): (\\w+) (.*)'\n    report: Dict[str, List[Violation]] = {}\n    for line in payload.splitlines():\n        match = re.match(regex, line)\n        if match:\n            group = match.groups()\n            violation = Violation(\n                file_path=group[0],\n                line=int(group[1]),\n                column=int(group[2]),\n                rule_id=group[3],\n                message=group[4],\n            )\n            if violation.file_path not in report:\n                report[violation.file_path] = []\n            report[violation.file_path].append(violation)\n    return Good([\n        FileReport(file_path=name, violations=violations)\n        for name, violations in report.items()\n    ])\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/pylint/","title":"pylint","text":""},{"location":"api/m/ci/celt/post_processors/pylint/#m.ci.celt.post_processors.pylint.read_payload","title":"<code>read_payload(payload)</code>","text":"<p>Transform a pylint payload to a list of <code>FileReport</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The raw payload from pylint.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, List[FileReport]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of <code>FileReport</code> instances.</p> Source code in <code>m/ci/celt/post_processors/pylint.py</code> <pre><code>def read_payload(payload: str) -&gt; OneOf[Issue, List[FileReport]]:\n    \"\"\"Transform a pylint payload to a list of `FileReport` instances.\n\n    Args:\n        payload: The raw payload from pylint.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of `FileReport` instances.\n    \"\"\"\n    res = json.parse_json(payload)\n    if res.is_bad:\n        return res\n    violations = cast(List[Any], res.value)\n    report: Dict[str, List[Violation]] = {}\n    for v_item in violations:\n        violation = Violation(\n            rule_id=v_item['symbol'],\n            message=v_item['message'],\n            line=int(v_item['line']),\n            column=int(v_item['column']),\n            file_path=v_item['path'],\n        )\n        if violation.file_path not in report:\n            report[violation.file_path] = []\n        report[violation.file_path].append(violation)\n    return Good([\n        FileReport(file_path=name, violations=violations)\n        for name, violations in report.items()\n    ])\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/ruff/","title":"ruff","text":""},{"location":"api/m/ci/celt/post_processors/ruff/#m.ci.celt.post_processors.ruff.Location","title":"<code>Location</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A location in a file.</p> <p>Attributes:</p> Name Type Description <code>row</code> <code>int</code> <p>...</p> <code>column</code> <code>int</code> <p>...</p> Source code in <code>m/ci/celt/post_processors/ruff.py</code> <pre><code>class Location(BaseModel):\n    \"\"\"A location in a file.\"\"\"\n\n    row: int\n    column: int\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/ruff/#m.ci.celt.post_processors.ruff.RuffViolation","title":"<code>RuffViolation</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A violation from ruff.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str</code> <p>...</p> <code>filename</code> <code>str</code> <p>...</p> <code>location</code> <code>Location</code> <p>...</p> <code>message</code> <code>str</code> <p>...</p> Source code in <code>m/ci/celt/post_processors/ruff.py</code> <pre><code>class RuffViolation(BaseModel):\n    \"\"\"A violation from ruff.\"\"\"\n\n    code: str\n    filename: str\n    location: Location\n    message: str\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/ruff/#m.ci.celt.post_processors.ruff.read_payload","title":"<code>read_payload(payload)</code>","text":"<p>Transform a pylint payload to a list of <code>FileReport</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The raw payload from pylint.</p> required <p>Returns:</p> Type Description <code>Res[list[FileReport]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of <code>FileReport</code> instances.</p> Source code in <code>m/ci/celt/post_processors/ruff.py</code> <pre><code>def read_payload(payload: str) -&gt; Res[list[FileReport]]:\n    \"\"\"Transform a pylint payload to a list of `FileReport` instances.\n\n    Args:\n        payload: The raw payload from pylint.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of `FileReport` instances.\n    \"\"\"\n    context = {'suggestion': 'run ruff check --format json'}\n    return one_of(lambda: [\n        [\n            FileReport(file_path=name, violations=violations)\n            for name, violations in report.items()\n        ]\n        for json_payload in json.parse_json(payload)\n        for violations in parse_model(list[RuffViolation], json_payload)\n        for report in _index_violations(violations)\n    ]).flat_map_bad(hone('invalid_ruff_output_payload', context))\n</code></pre>"},{"location":"api/m/ci/celt/post_processors/typescript/","title":"typescript","text":""},{"location":"api/m/ci/celt/post_processors/typescript/#m.ci.celt.post_processors.typescript.read_payload","title":"<code>read_payload(payload)</code>","text":"<p>Transform a typescript payload to a list of <code>FileReport</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The raw payload from typescript when <code>--pretty false</code> option.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, list[FileReport]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or a list of <code>FileReport</code> instances.</p> Source code in <code>m/ci/celt/post_processors/typescript.py</code> <pre><code>def read_payload(payload: str) -&gt; OneOf[Issue, list[FileReport]]:\n    \"\"\"Transform a typescript payload to a list of `FileReport` instances.\n\n    Args:\n        payload: The raw payload from typescript when `--pretty false` option.\n\n    Returns:\n        A `OneOf` containing an `Issue` or a list of `FileReport` instances.\n    \"\"\"\n    regex = r'(.*)\\((\\d+),(\\d+)\\): error (\\w+): (.*)'\n    report: dict[str, list[Violation]] = {}\n    for line in payload.splitlines():\n        if line.startswith(' '):\n            continue\n        match = re.match(regex, line)\n        if match:\n            group = match.groups()\n            violation = Violation(\n                file_path=group[0],\n                line=int(group[1]),\n                column=int(group[2]),\n                rule_id=group[3],\n                message=group[4],\n            )\n            if violation.file_path not in report:\n                report[violation.file_path] = []\n            report[violation.file_path].append(violation)\n    return Good([\n        FileReport(file_path=name, violations=violations)\n        for name, violations in report.items()\n    ])\n</code></pre>"},{"location":"api/m/ci/docker/","title":"docker","text":""},{"location":"api/m/ci/docker/config/","title":"config","text":""},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig","title":"<code>DockerConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Contains information about the docker images to build.</p> <p>Attributes:</p> Name Type Description <code>global_env</code> <code>dict[str, str] | None</code> <p>...</p> <code>default_runner</code> <code>str</code> <p>...</p> <code>architectures</code> <code>dict[str, str | list[str]] | None</code> <p>...</p> <code>base_path</code> <code>str</code> <p>...</p> <code>docker_registry</code> <code>str</code> <p>...</p> <code>extra_build_steps</code> <code>list[dict[str, Any]] | None</code> <p>...</p> <code>max_parallel_manifests</code> <code>int | None</code> <p>...</p> <code>images</code> <code>list[DockerImage]</code> <p>...</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>class DockerConfig(BaseModel):\n    \"\"\"Contains information about the docker images to build.\"\"\"\n\n    # additional environment variables to inject globally.\n    global_env: dict[str, str] | None = None\n\n    # default runner to use when creating blueprints and manifests\n    default_runner: str = 'ubuntu-22.04'\n\n    # A map of the architectures to build. It maps say `amd64` to a Github\n    # runner that will build the image for that architecture.\n    #   amd64: Ubuntu 20.04\n    architectures: dict[str, str | list[str]] | None\n\n    # Base path used to locate docker files. Defaults to `.` (root of project)\n    # but may be changed a specific directory.\n    base_path: str = '.'\n\n    # Name of the docker registry to push the images to. For Github container\n    # registry make sure to also include the github owner. For instance:\n    # ghcr.io/owner\n    docker_registry: str\n\n    # When executing docker build commands we may need to obtain external tokens\n    # via other github actions. These can be injected here. We can see those\n    # steps in the github workflow file before the actual docker shell scripts\n    # are run.\n    extra_build_steps: list[dict[str, Any]] | None = None\n\n    # Maximum number of parallel manifests to build.\n    # https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs#defining-the-maximum-number-of-concurrent-jobs\n    max_parallel_manifests: int | None = None\n\n    # list of images to build\n    images: list[DockerImage]\n\n    def makefile_targets(self: 'DockerConfig', files: FileNames) -&gt; str:\n        \"\"\"Create the Makefile targets to trigger the local builds.\n\n        Args:\n            files: Instance of FileNames to obtain the names of the scripts.\n\n        Returns:\n            A string with the Makefile targets.\n        \"\"\"\n        m_dir = files.m_dir\n        lines: list[str] = [\n            'define m_env',\n            f'\\t$(eval include {m_dir}/.m/m_env.sh)',\n            f'\\t$(eval $(cut -d= -f1 {m_dir}/.m/m_env.sh))',\n            'endef',\n            '',\n            'm-env:',\n            f'\\tmkdir -p {m_dir}/.m &amp;&amp; m ci env --bashrc &gt; {m_dir}/.m/m_env.sh',\n            '',\n            'm-blueprints: m-env',\n            '\\t$(call m_env)',\n            f'\\tm blueprints --skip-makefile --skip-workflow {m_dir}',\n            f'\\tchmod +x {m_dir}/.m/blueprints/local/*.sh\\n',\n        ]\n        for index, img in enumerate(self.images):\n            name = img.image_name\n            img_file = files.local_file(f'{name}.build.sh')\n            previous_img = (\n                self.images[index - 1].image_name\n                if index &gt; 0\n                else None\n            )\n            dep = f' dev-{previous_img}' if previous_img else ' m-blueprints'\n            lines.append(f'dev-{name}:{dep}')\n            lines.append('\\t$(call m_env)')\n            lines.append(f'\\t{img_file}\\n')\n        return '\\n'.join(lines)\n\n    def update_makefile(self: 'DockerConfig', files: FileNames) -&gt; Res[int]:\n        \"\"\"Update the Makefile with the docker images targets.\n\n        Args:\n            files: Instance of FileNames to obtain the names of the scripts.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        return rw.insert_to_file(\n            files.makefile,\n            '\\n# START: M-DOCKER-IMAGES\\n',\n            self.makefile_targets(files),\n            '\\n# END: M-DOCKER-IMAGES\\n',\n        )\n\n    def update_github_workflow(\n        self: 'DockerConfig',\n        files: FileNames,\n    ) -&gt; Res[int]:\n        \"\"\"Update the github workflow with the docker images targets.\n\n        Args:\n            files: Instance of FileNames to obtain the names of the scripts.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        global_env: dict[str, str] = self.global_env or {}\n        multi_workflow = MultiWorkflow(\n            m_dir=files.m_dir,\n            ci_dir=files.ci_dir,\n            global_env=global_env,\n            default_runner=self.default_runner,\n            architectures=self.architectures or {},\n            images=self.images,\n            extra_build_steps=self.extra_build_steps,\n            docker_registry=self.docker_registry,\n            max_parallel_manifests=self.max_parallel_manifests,\n        )\n        single_workflow = SingleWorkflow(\n            m_dir=files.m_dir,\n            ci_dir=files.ci_dir,\n            global_env=global_env,\n            default_runner=self.default_runner,\n            images=self.images,\n            extra_build_steps=self.extra_build_steps,\n            docker_registry=self.docker_registry,\n        )\n        workflow = multi_workflow if self.architectures else single_workflow\n        return rw.write_file(files.gh_workflow, str(workflow))\n\n    def write_local_steps(\n        self: 'DockerConfig',\n        files: FileNames,\n        m_env: MEnvDocker,\n    ) -&gt; Res[None]:\n        \"\"\"Write local entry point files.\n\n        Args:\n            files: The FileNames instance with the file names.\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        issues: list[dict] = []\n        for img in self.images:\n            write_res = _write_local_step(files, img, m_env)\n            _append_issue(write_res, issues)\n        if issues:\n            return issue(\n                'write_local_steps_failure',\n                context={'issues': issues},\n            )\n        return Good(None)\n\n    def write_ci_steps(\n        self: 'DockerConfig',\n        files: FileNames,\n        m_env: MEnvDocker,\n    ) -&gt; Res[None]:\n        \"\"\"Write ci entry point files.\n\n        Args:\n            files: The FileNames instance with the file names.\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        issues: list[dict] = []\n        registry = self.docker_registry\n        cache_script = create_cache_script(m_env.cache_from_pr, registry)\n        push_script = (\n            create_push_script(registry)\n            if self.architectures\n            else create_push_script_tags(registry, m_env.m_tag)\n        )\n        script_results = [\n            rw.write_file(f'{files.ci_dir}/_find-cache.sh', cache_script),\n            rw.write_file(f'{files.ci_dir}/_push-image.sh', push_script),\n        ]\n        for script_res in script_results:\n            _append_issue(script_res, issues)\n        for img in self.images:\n            file_name = f'{files.ci_dir}/{img.image_name}.build.sh'\n            write_res = _write_build_script(file_name, img, m_env)\n            _append_issue(write_res, issues)\n        if issues:\n            return issue(\n                'write_ci_steps_failure',\n                context={'issues': issues},\n            )\n        return Good(None)\n\n    def write_ci_manifest_info(\n        self: 'DockerConfig',\n        files: FileNames,\n        m_env: MEnvDocker,\n    ) -&gt; Res[None]:\n        \"\"\"Write ci entry point files.\n\n        Args:\n            files: The FileNames instance with the file names.\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        if not self.architectures:\n            return Good(None)\n        m_tag = m_env.m_tag\n        if not m_tag and os.environ.get('CI') != 'true':\n            logger.warning('M_TAG not found in non-CI environment. Using 1.1.1')\n            m_tag = '1.1.1'\n        names = [img.image_name for img in self.images]\n        tags = [m_tag, *docker_tags(m_tag)]\n        names_json = json.dumps(names, separators=(',', ':'))\n        tags_json = json.dumps(tags, separators=(',', ':'))\n        files_res = [\n            rw.write_file(f'{files.ci_dir}/_image-names.json', names_json),\n            rw.write_file(f'{files.ci_dir}/_image-tags.json', tags_json),\n        ]\n        issues: list[dict] = []\n        for file_res in files_res:\n            _append_issue(file_res, issues)\n        if issues:\n            return issue(\n                'write_ci_manifest_info_failure',\n                context={'issues': issues},\n            )\n        return Good(None)\n\n    def write_blueprints(\n        self: 'DockerConfig',\n        m_dir: str,\n        m_env: MEnvDocker,\n    ) -&gt; Res[None]:\n        \"\"\"Write entry point files.\n\n        Writes shell files for both local and ci. Updates the Makefile and\n        github workflow file.\n\n        Args:\n            m_dir: The m directory.\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            None if successful, else an issue.\n        \"\"\"\n        files = FileNames.create_instance(m_dir)\n        return one_of(lambda: [\n            None\n            for _ in self.write_local_steps(files, m_env)\n            for _ in self.write_ci_steps(files, m_env)\n            for _ in self.write_ci_manifest_info(files, m_env)\n        ])\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.makefile_targets","title":"<code>makefile_targets(files)</code>","text":"<p>Create the Makefile targets to trigger the local builds.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>Instance of FileNames to obtain the names of the scripts.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string with the Makefile targets.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def makefile_targets(self: 'DockerConfig', files: FileNames) -&gt; str:\n    \"\"\"Create the Makefile targets to trigger the local builds.\n\n    Args:\n        files: Instance of FileNames to obtain the names of the scripts.\n\n    Returns:\n        A string with the Makefile targets.\n    \"\"\"\n    m_dir = files.m_dir\n    lines: list[str] = [\n        'define m_env',\n        f'\\t$(eval include {m_dir}/.m/m_env.sh)',\n        f'\\t$(eval $(cut -d= -f1 {m_dir}/.m/m_env.sh))',\n        'endef',\n        '',\n        'm-env:',\n        f'\\tmkdir -p {m_dir}/.m &amp;&amp; m ci env --bashrc &gt; {m_dir}/.m/m_env.sh',\n        '',\n        'm-blueprints: m-env',\n        '\\t$(call m_env)',\n        f'\\tm blueprints --skip-makefile --skip-workflow {m_dir}',\n        f'\\tchmod +x {m_dir}/.m/blueprints/local/*.sh\\n',\n    ]\n    for index, img in enumerate(self.images):\n        name = img.image_name\n        img_file = files.local_file(f'{name}.build.sh')\n        previous_img = (\n            self.images[index - 1].image_name\n            if index &gt; 0\n            else None\n        )\n        dep = f' dev-{previous_img}' if previous_img else ' m-blueprints'\n        lines.append(f'dev-{name}:{dep}')\n        lines.append('\\t$(call m_env)')\n        lines.append(f'\\t{img_file}\\n')\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.update_github_workflow","title":"<code>update_github_workflow(files)</code>","text":"<p>Update the github workflow with the docker images targets.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>Instance of FileNames to obtain the names of the scripts.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def update_github_workflow(\n    self: 'DockerConfig',\n    files: FileNames,\n) -&gt; Res[int]:\n    \"\"\"Update the github workflow with the docker images targets.\n\n    Args:\n        files: Instance of FileNames to obtain the names of the scripts.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    global_env: dict[str, str] = self.global_env or {}\n    multi_workflow = MultiWorkflow(\n        m_dir=files.m_dir,\n        ci_dir=files.ci_dir,\n        global_env=global_env,\n        default_runner=self.default_runner,\n        architectures=self.architectures or {},\n        images=self.images,\n        extra_build_steps=self.extra_build_steps,\n        docker_registry=self.docker_registry,\n        max_parallel_manifests=self.max_parallel_manifests,\n    )\n    single_workflow = SingleWorkflow(\n        m_dir=files.m_dir,\n        ci_dir=files.ci_dir,\n        global_env=global_env,\n        default_runner=self.default_runner,\n        images=self.images,\n        extra_build_steps=self.extra_build_steps,\n        docker_registry=self.docker_registry,\n    )\n    workflow = multi_workflow if self.architectures else single_workflow\n    return rw.write_file(files.gh_workflow, str(workflow))\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.update_makefile","title":"<code>update_makefile(files)</code>","text":"<p>Update the Makefile with the docker images targets.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>Instance of FileNames to obtain the names of the scripts.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def update_makefile(self: 'DockerConfig', files: FileNames) -&gt; Res[int]:\n    \"\"\"Update the Makefile with the docker images targets.\n\n    Args:\n        files: Instance of FileNames to obtain the names of the scripts.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    return rw.insert_to_file(\n        files.makefile,\n        '\\n# START: M-DOCKER-IMAGES\\n',\n        self.makefile_targets(files),\n        '\\n# END: M-DOCKER-IMAGES\\n',\n    )\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.write_blueprints","title":"<code>write_blueprints(m_dir, m_env)</code>","text":"<p>Write entry point files.</p> <p>Writes shell files for both local and ci. Updates the Makefile and github workflow file.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The m directory.</p> required <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def write_blueprints(\n    self: 'DockerConfig',\n    m_dir: str,\n    m_env: MEnvDocker,\n) -&gt; Res[None]:\n    \"\"\"Write entry point files.\n\n    Writes shell files for both local and ci. Updates the Makefile and\n    github workflow file.\n\n    Args:\n        m_dir: The m directory.\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    files = FileNames.create_instance(m_dir)\n    return one_of(lambda: [\n        None\n        for _ in self.write_local_steps(files, m_env)\n        for _ in self.write_ci_steps(files, m_env)\n        for _ in self.write_ci_manifest_info(files, m_env)\n    ])\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.write_ci_manifest_info","title":"<code>write_ci_manifest_info(files, m_env)</code>","text":"<p>Write ci entry point files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>The FileNames instance with the file names.</p> required <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def write_ci_manifest_info(\n    self: 'DockerConfig',\n    files: FileNames,\n    m_env: MEnvDocker,\n) -&gt; Res[None]:\n    \"\"\"Write ci entry point files.\n\n    Args:\n        files: The FileNames instance with the file names.\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    if not self.architectures:\n        return Good(None)\n    m_tag = m_env.m_tag\n    if not m_tag and os.environ.get('CI') != 'true':\n        logger.warning('M_TAG not found in non-CI environment. Using 1.1.1')\n        m_tag = '1.1.1'\n    names = [img.image_name for img in self.images]\n    tags = [m_tag, *docker_tags(m_tag)]\n    names_json = json.dumps(names, separators=(',', ':'))\n    tags_json = json.dumps(tags, separators=(',', ':'))\n    files_res = [\n        rw.write_file(f'{files.ci_dir}/_image-names.json', names_json),\n        rw.write_file(f'{files.ci_dir}/_image-tags.json', tags_json),\n    ]\n    issues: list[dict] = []\n    for file_res in files_res:\n        _append_issue(file_res, issues)\n    if issues:\n        return issue(\n            'write_ci_manifest_info_failure',\n            context={'issues': issues},\n        )\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.write_ci_steps","title":"<code>write_ci_steps(files, m_env)</code>","text":"<p>Write ci entry point files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>The FileNames instance with the file names.</p> required <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def write_ci_steps(\n    self: 'DockerConfig',\n    files: FileNames,\n    m_env: MEnvDocker,\n) -&gt; Res[None]:\n    \"\"\"Write ci entry point files.\n\n    Args:\n        files: The FileNames instance with the file names.\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    issues: list[dict] = []\n    registry = self.docker_registry\n    cache_script = create_cache_script(m_env.cache_from_pr, registry)\n    push_script = (\n        create_push_script(registry)\n        if self.architectures\n        else create_push_script_tags(registry, m_env.m_tag)\n    )\n    script_results = [\n        rw.write_file(f'{files.ci_dir}/_find-cache.sh', cache_script),\n        rw.write_file(f'{files.ci_dir}/_push-image.sh', push_script),\n    ]\n    for script_res in script_results:\n        _append_issue(script_res, issues)\n    for img in self.images:\n        file_name = f'{files.ci_dir}/{img.image_name}.build.sh'\n        write_res = _write_build_script(file_name, img, m_env)\n        _append_issue(write_res, issues)\n    if issues:\n        return issue(\n            'write_ci_steps_failure',\n            context={'issues': issues},\n        )\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/docker/config/#m.ci.docker.config.DockerConfig.write_local_steps","title":"<code>write_local_steps(files, m_env)</code>","text":"<p>Write local entry point files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>FileNames</code> <p>The FileNames instance with the file names.</p> required <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>None if successful, else an issue.</p> Source code in <code>m/ci/docker/config.py</code> <pre><code>def write_local_steps(\n    self: 'DockerConfig',\n    files: FileNames,\n    m_env: MEnvDocker,\n) -&gt; Res[None]:\n    \"\"\"Write local entry point files.\n\n    Args:\n        files: The FileNames instance with the file names.\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    issues: list[dict] = []\n    for img in self.images:\n        write_res = _write_local_step(files, img, m_env)\n        _append_issue(write_res, issues)\n    if issues:\n        return issue(\n            'write_local_steps_failure',\n            context={'issues': issues},\n        )\n    return Good(None)\n</code></pre>"},{"location":"api/m/ci/docker/docker_build/","title":"docker_build","text":""},{"location":"api/m/ci/docker/docker_build/#m.ci.docker.docker_build.DockerBuild","title":"<code>DockerBuild</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Representation of a <code>docker build</code> command.</p> <p>See https://docs.docker.com/engine/reference/commandline/build</p> <p>Attributes:</p> Name Type Description <code>add_host</code> <code>list[str] | None</code> <p>...</p> <code>build_arg</code> <code>list[str] | None</code> <p>...</p> <code>cache_from</code> <code>str | None</code> <p>...</p> <code>cgroup_parent</code> <code>str | None</code> <p>...</p> <code>compress</code> <code>bool | None</code> <p>...</p> <code>cpu_period</code> <code>int | None</code> <p>...</p> <code>cpu_quota</code> <code>int | None</code> <p>...</p> <code>cpu_shares</code> <code>int | None</code> <p>...</p> <code>cpuset_cpus</code> <code>str | None</code> <p>...</p> <code>cpuset_mems</code> <code>str | None</code> <p>...</p> <code>disable_content_trust</code> <code>bool | None</code> <p>...</p> <code>file</code> <code>str | None</code> <p>...</p> <code>force_rm</code> <code>bool | None</code> <p>...</p> <code>iidfile</code> <code>str | None</code> <p>...</p> <code>isolation</code> <code>str | None</code> <p>...</p> <code>label</code> <code>list[str] | None</code> <p>...</p> <code>memory</code> <code>str | None</code> <p>...</p> <code>memory_swap</code> <code>str | None</code> <p>...</p> <code>network</code> <code>str | None</code> <p>...</p> <code>no_cache</code> <code>bool | None</code> <p>...</p> <code>pull</code> <code>bool | None</code> <p>...</p> <code>quiet</code> <code>bool | None</code> <p>...</p> <code>rm</code> <code>bool | None</code> <p>...</p> <code>security_opt</code> <code>str | None</code> <p>...</p> <code>secret</code> <code>list[str] | None</code> <p>...</p> <code>progress</code> <code>str | None</code> <p>...</p> <code>shm_size</code> <code>str | None</code> <p>...</p> <code>tag</code> <code>list[str] | None</code> <p>...</p> <code>target</code> <code>str | None</code> <p>...</p> <code>ulimit</code> <code>str | None</code> <p>...</p> Source code in <code>m/ci/docker/docker_build.py</code> <pre><code>class DockerBuild(BaseModel):\n    \"\"\"Representation of a `docker build` command.\n\n    See https://docs.docker.com/engine/reference/commandline/build\n    \"\"\"\n\n    # Add a custom host-to-IP mapping (host:ip)\n    add_host: list[str] | None = None\n\n    # Set build-time variables\n    build_arg: list[str] | None = None\n\n    # Images to consider as cache sources\n    cache_from: str | None = None\n\n    # Optional parent cgroup for the container\n    cgroup_parent: str | None = None\n\n    # Compress the build context using gzip\n    compress: bool | None = None\n\n    # Limit the CPU CFS (Completely Fair Scheduler) period\n    cpu_period: int | None = None\n\n    # Limit the CPU CFS (Completely Fair Scheduler) quota\n    cpu_quota: int | None = None\n\n    # CPU shares (relative weight)\n    cpu_shares: int | None = None\n\n    # CPUs in which to allow execution (0-3, 0,1)\n    cpuset_cpus: str | None = None\n\n    # MEMs in which to allow execution (0-3, 0,1)\n    cpuset_mems: str | None = None\n\n    # Skip image verification (default true)\n    disable_content_trust: bool | None = None\n\n    # Name of the Dockerfile (Default is 'PATH/Dockerfile')\n    file: str | None = None  # noqa: WPS110 - docker build optional argument\n\n    # Always remove intermediate containers\n    force_rm: bool | None = None\n\n    # Write the image ID to the file\n    iidfile: str | None = None\n\n    # Container isolation technology\n    isolation: str | None = None\n\n    # Set metadata for an image\n    label: list[str] | None = None\n\n    # Memory limit\n    memory: str | None = None\n\n    # Swap limit equal to memory plus swap: '-1' to enable unlimited swap\n    memory_swap: str | None = None\n\n    # Set the networking mode for the RUN instructions during build (default \"default\")\n    network: str | None = None\n\n    # Do not use cache when building the image\n    no_cache: bool | None = None\n\n    # Always attempt to pull a newer version of the image\n    pull: bool | None = None\n\n    # Suppress the build output and print image ID on success\n    quiet: bool | None = None\n\n    # Remove intermediate containers after a successful build (default true)\n    rm: bool | None = None\n\n    # Security options\n    security_opt: str | None = None\n\n    # Available with DOCKER_BUILDKIT=1\n    #   see https://pythonspeed.com/articles/docker-build-secrets\n    # Use as `--secret id=ENVVAR` in the docker build command.\n    # Then in the `RUN` statement in the docker file do `RUN --mount=type=secret,id=ENVVAR`.\n    # Then you may access that value by doing `ENVVAR=$(cat /run/secrets/ENVVAR)`.\n    # Best to use that in a script that that executes inside the docker file.\n    secret: list[str] | None = None\n\n    # Available with DOCKER_BUILDKIT=1\n    progress: str | None = None\n\n    # Size of /dev/shm\n    shm_size: str | None = None\n\n    # Name and optionally a tag in the 'name:tag' format\n    tag: list[str] | None = None\n\n    # Set the target build stage to build\n    target: str | None = None\n\n    # Ulimit options (default [])\n    ulimit: str | None = None\n\n    def __str__(self) -&gt; str:\n        \"\"\"Convert the docker build command to a string.\n\n        Returns:\n            The docker build command.\n        \"\"\"\n        cmd = ShellCommand(\n            prog='docker build',\n            positional=['.'],\n            options=self.model_dump(exclude_none=True),\n        )\n        return str(cmd)\n</code></pre>"},{"location":"api/m/ci/docker/docker_build/#m.ci.docker.docker_build.DockerBuild.__str__","title":"<code>__str__()</code>","text":"<p>Convert the docker build command to a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The docker build command.</p> Source code in <code>m/ci/docker/docker_build.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Convert the docker build command to a string.\n\n    Returns:\n        The docker build command.\n    \"\"\"\n    cmd = ShellCommand(\n        prog='docker build',\n        positional=['.'],\n        options=self.model_dump(exclude_none=True),\n    )\n    return str(cmd)\n</code></pre>"},{"location":"api/m/ci/docker/env/","title":"env","text":""},{"location":"api/m/ci/docker/env/#m.ci.docker.env.MEnvDocker","title":"<code>MEnvDocker</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Values from <code>MEnv</code> needed by docker.</p> <p>Attributes:</p> Name Type Description <code>m_tag</code> <code>str</code> <p>...</p> <code>cache_from_pr</code> <code>str</code> <p>...</p> <code>base_path</code> <code>str</code> <p>...</p> <code>registry</code> <code>str</code> <p>...</p> <code>multi_arch</code> <code>bool</code> <p>...</p> Source code in <code>m/ci/docker/env.py</code> <pre><code>class MEnvDocker(BaseModel):\n    \"\"\"Values from `MEnv` needed by docker.\"\"\"\n\n    # The m tag to build the images.\n    m_tag: str\n\n    # The pull request number to attempt to use as cache.\n    cache_from_pr: str\n\n    # base path to locate docker file.\n    base_path: str\n\n    # docker registry\n    registry: str\n\n    # Flag to indicate if multi-arch is enabled.\n    multi_arch: bool\n</code></pre>"},{"location":"api/m/ci/docker/filenames/","title":"filenames","text":""},{"location":"api/m/ci/docker/filenames/#m.ci.docker.filenames.FileNames","title":"<code>FileNames</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Name of files that need to be written.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <code>str</code> <p>...</p> <code>local_dir</code> <code>str</code> <p>...</p> <code>ci_dir</code> <code>str</code> <p>...</p> <code>manifests_dir</code> <code>str</code> <p>...</p> <code>makefile</code> <code>str</code> <p>...</p> <code>gh_workflow</code> <code>str</code> <p>...</p> Source code in <code>m/ci/docker/filenames.py</code> <pre><code>class FileNames(BaseModel):\n    \"\"\"Name of files that need to be written.\"\"\"\n\n    m_dir: str\n    local_dir: str\n    ci_dir: str\n    manifests_dir: str\n    makefile: str\n    gh_workflow: str\n\n    @classmethod\n    def create_instance(cls: type['FileNames'], m_dir: str) -&gt; 'FileNames':\n        \"\"\"Create and instance of FileNames.\n\n        Args:\n            m_dir: The m directory.\n\n        Returns:\n            An instance of FileNames.\n        \"\"\"\n        gh_dir = Path(f'{m_dir}/../.github/workflows')\n        gh_dir.mkdir(parents=True, exist_ok=True)\n        return FileNames(\n            m_dir=m_dir,\n            local_dir=f'{m_dir}/.m/blueprints/local',\n            ci_dir=f'{m_dir}/.m/blueprints/ci',\n            manifests_dir=f'{m_dir}/.m/blueprints/ci/manifests',\n            makefile=f'{m_dir}/../Makefile',\n            gh_workflow=f'{m_dir}/../.github/workflows/m.yaml',\n        )\n\n    def local_file(self: 'FileNames', filename: str) -&gt; str:\n        \"\"\"Generate the name of a local script.\n\n        Args:\n            filename: The name of the file.\n\n        Returns:\n            The full name of the file.\n        \"\"\"\n        return f'{self.local_dir}/{filename}'\n</code></pre>"},{"location":"api/m/ci/docker/filenames/#m.ci.docker.filenames.FileNames.create_instance","title":"<code>create_instance(m_dir)</code>  <code>classmethod</code>","text":"<p>Create and instance of FileNames.</p> <p>Parameters:</p> Name Type Description Default <code>m_dir</code> <code>str</code> <p>The m directory.</p> required <p>Returns:</p> Type Description <code>FileNames</code> <p>An instance of FileNames.</p> Source code in <code>m/ci/docker/filenames.py</code> <pre><code>@classmethod\ndef create_instance(cls: type['FileNames'], m_dir: str) -&gt; 'FileNames':\n    \"\"\"Create and instance of FileNames.\n\n    Args:\n        m_dir: The m directory.\n\n    Returns:\n        An instance of FileNames.\n    \"\"\"\n    gh_dir = Path(f'{m_dir}/../.github/workflows')\n    gh_dir.mkdir(parents=True, exist_ok=True)\n    return FileNames(\n        m_dir=m_dir,\n        local_dir=f'{m_dir}/.m/blueprints/local',\n        ci_dir=f'{m_dir}/.m/blueprints/ci',\n        manifests_dir=f'{m_dir}/.m/blueprints/ci/manifests',\n        makefile=f'{m_dir}/../Makefile',\n        gh_workflow=f'{m_dir}/../.github/workflows/m.yaml',\n    )\n</code></pre>"},{"location":"api/m/ci/docker/filenames/#m.ci.docker.filenames.FileNames.local_file","title":"<code>local_file(filename)</code>","text":"<p>Generate the name of a local script.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The full name of the file.</p> Source code in <code>m/ci/docker/filenames.py</code> <pre><code>def local_file(self: 'FileNames', filename: str) -&gt; str:\n    \"\"\"Generate the name of a local script.\n\n    Args:\n        filename: The name of the file.\n\n    Returns:\n        The full name of the file.\n    \"\"\"\n    return f'{self.local_dir}/{filename}'\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/","title":"gh_workflow_multi","text":""},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.TemplateVars","title":"<code>TemplateVars</code>","text":"<p>             Bases: <code>TemplateVars</code></p> <p>Template variables.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <p>...</p> <code>ci_dir</code> <p>...</p> <code>default_runner</code> <p>...</p> <code>global_env</code> <p>...</p> <code>docker_login</code> <p>...</p> <code>build_steps</code> <p>...</p> <code>build_architectures</code> <code>str</code> <p>...</p> <code>create_manifest</code> <code>str</code> <p>...</p> <code>push_manifest</code> <code>str</code> <p>...</p> <code>manifest_strategy_options</code> <code>str</code> <p>...</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>class TemplateVars(DefaultTemplateVars):\n    \"\"\"Template variables.\"\"\"\n\n    build_architectures: str\n\n    create_manifest: str\n\n    push_manifest: str\n\n    manifest_strategy_options: str\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow","title":"<code>Workflow</code>","text":"<p>             Bases: <code>Workflow</code></p> <p>Helper class to write the <code>m</code> workflow.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <p>...</p> <code>ci_dir</code> <p>...</p> <code>global_env</code> <p>...</p> <code>default_runner</code> <p>...</p> <code>docker_registry</code> <p>...</p> <code>extra_build_steps</code> <p>...</p> <code>images</code> <p>...</p> <code>architectures</code> <code>dict[str, str | list[str]]</code> <p>...</p> <code>max_parallel_manifests</code> <code>int | None</code> <p>...</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>class Workflow(DefaultWorkflow):\n    \"\"\"Helper class to write the `m` workflow.\"\"\"\n\n    architectures: dict[str, str | list[str]]\n\n    max_parallel_manifests: int | None\n\n    def build_architectures(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a github action str with the build architectures.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        arch_strs = '\\n'.join([\n            f'- arch: {arch}\\n  os: {os}'\n            for arch, os in self.architectures.items()\n        ])\n        return _indent(f'\\n{arch_strs}', 5)\n\n    def create_manifest_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate the script to create the manifest.\n\n        Returns:\n            The manifest create script.\n        \"\"\"\n        cmd = 'docker manifest create'\n        registry = self.docker_registry\n        image = '${{ matrix.image-name }}'\n        tag = '${{ matrix.image-tag }}'\n        m_tag = '${{ inputs.m-tag }}'\n        lines = [f'{cmd} {registry}/{image}:{tag}']\n        for arch in self.architectures:\n            lines.append(f'  {registry}/{arch}-{image}:{m_tag}')\n        # wants it be a raw string but i need a new line after `\\`\n        full_cmd = ' \\\\\\n'.join(lines)   # noqa: WPS342\n        return _indent(f'|-\\n{full_cmd}', 5)\n\n    def push_manifest_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate the script to run to push the manifest.\n\n        Returns:\n            The command to push.\n        \"\"\"\n        cmd = 'docker manifest push'\n        registry = self.docker_registry\n        image = '${{ matrix.image-name }}'\n        tag = '${{ matrix.image-tag }}'\n        full_cmd = f'|-\\n{cmd} {registry}/{image}:{tag}'\n        return _indent(full_cmd, 5)\n\n    def manifest_strategy_options_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate the strategy options for the manifest job.\n\n        Returns:\n            The strategy options.\n        \"\"\"\n        options = ''\n        if self.max_parallel_manifests:\n            options = f'\\n      max-parallel: {self.max_parallel_manifests}'\n        return options\n\n    def __str__(self: 'Workflow') -&gt; str:\n        \"\"\"Stringify the workflow file.\n\n        Returns:\n            The github workflow.\n        \"\"\"\n        template_vars = TemplateVars(\n            m_dir=self.m_dir,\n            default_runner=self.default_runner,\n            global_env=self.global_env_str(),\n            ci_dir=self.ci_dir,\n            build_architectures=self.build_architectures(),\n            docker_login=self.docker_login_str(),\n            build_steps=self.build_steps_str(),\n            create_manifest=self.create_manifest_str(),\n            push_manifest=self.push_manifest_str(),\n            manifest_strategy_options=self.manifest_strategy_options_str(),\n        )\n        return TEMPLATE.format(**template_vars.model_dump())\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.__str__","title":"<code>__str__()</code>","text":"<p>Stringify the workflow file.</p> <p>Returns:</p> Type Description <code>str</code> <p>The github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def __str__(self: 'Workflow') -&gt; str:\n    \"\"\"Stringify the workflow file.\n\n    Returns:\n        The github workflow.\n    \"\"\"\n    template_vars = TemplateVars(\n        m_dir=self.m_dir,\n        default_runner=self.default_runner,\n        global_env=self.global_env_str(),\n        ci_dir=self.ci_dir,\n        build_architectures=self.build_architectures(),\n        docker_login=self.docker_login_str(),\n        build_steps=self.build_steps_str(),\n        create_manifest=self.create_manifest_str(),\n        push_manifest=self.push_manifest_str(),\n        manifest_strategy_options=self.manifest_strategy_options_str(),\n    )\n    return TEMPLATE.format(**template_vars.model_dump())\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.build_architectures","title":"<code>build_architectures()</code>","text":"<p>Generate a github action str with the build architectures.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def build_architectures(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a github action str with the build architectures.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    arch_strs = '\\n'.join([\n        f'- arch: {arch}\\n  os: {os}'\n        for arch, os in self.architectures.items()\n    ])\n    return _indent(f'\\n{arch_strs}', 5)\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.create_manifest_str","title":"<code>create_manifest_str()</code>","text":"<p>Generate the script to create the manifest.</p> <p>Returns:</p> Type Description <code>str</code> <p>The manifest create script.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def create_manifest_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate the script to create the manifest.\n\n    Returns:\n        The manifest create script.\n    \"\"\"\n    cmd = 'docker manifest create'\n    registry = self.docker_registry\n    image = '${{ matrix.image-name }}'\n    tag = '${{ matrix.image-tag }}'\n    m_tag = '${{ inputs.m-tag }}'\n    lines = [f'{cmd} {registry}/{image}:{tag}']\n    for arch in self.architectures:\n        lines.append(f'  {registry}/{arch}-{image}:{m_tag}')\n    # wants it be a raw string but i need a new line after `\\`\n    full_cmd = ' \\\\\\n'.join(lines)   # noqa: WPS342\n    return _indent(f'|-\\n{full_cmd}', 5)\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.manifest_strategy_options_str","title":"<code>manifest_strategy_options_str()</code>","text":"<p>Generate the strategy options for the manifest job.</p> <p>Returns:</p> Type Description <code>str</code> <p>The strategy options.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def manifest_strategy_options_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate the strategy options for the manifest job.\n\n    Returns:\n        The strategy options.\n    \"\"\"\n    options = ''\n    if self.max_parallel_manifests:\n        options = f'\\n      max-parallel: {self.max_parallel_manifests}'\n    return options\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_multi/#m.ci.docker.gh_workflow_multi.Workflow.push_manifest_str","title":"<code>push_manifest_str()</code>","text":"<p>Generate the script to run to push the manifest.</p> <p>Returns:</p> Type Description <code>str</code> <p>The command to push.</p> Source code in <code>m/ci/docker/gh_workflow_multi.py</code> <pre><code>def push_manifest_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate the script to run to push the manifest.\n\n    Returns:\n        The command to push.\n    \"\"\"\n    cmd = 'docker manifest push'\n    registry = self.docker_registry\n    image = '${{ matrix.image-name }}'\n    tag = '${{ matrix.image-tag }}'\n    full_cmd = f'|-\\n{cmd} {registry}/{image}:{tag}'\n    return _indent(full_cmd, 5)\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/","title":"gh_workflow_single","text":""},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.TemplateVars","title":"<code>TemplateVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Template variables.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <code>str</code> <p>...</p> <code>ci_dir</code> <code>str</code> <p>...</p> <code>default_runner</code> <code>str</code> <p>...</p> <code>global_env</code> <code>str</code> <p>...</p> <code>docker_login</code> <code>str</code> <p>...</p> <code>build_steps</code> <code>str</code> <p>...</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>class TemplateVars(BaseModel):\n    \"\"\"Template variables.\"\"\"\n\n    m_dir: str\n\n    ci_dir: str\n\n    default_runner: str\n\n    global_env: str\n\n    docker_login: str\n\n    build_steps: str\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow","title":"<code>Workflow</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Helper class to write the <code>m</code> workflow.</p> <p>Attributes:</p> Name Type Description <code>m_dir</code> <code>str</code> <p>...</p> <code>ci_dir</code> <code>str</code> <p>...</p> <code>global_env</code> <code>dict[str, str] | None</code> <p>...</p> <code>default_runner</code> <code>str</code> <p>...</p> <code>docker_registry</code> <code>str</code> <p>...</p> <code>extra_build_steps</code> <code>list[dict[str, Any]] | None</code> <p>...</p> <code>images</code> <code>list[DockerImage]</code> <p>...</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>class Workflow(BaseModel):\n    \"\"\"Helper class to write the `m` workflow.\"\"\"\n\n    m_dir: str\n\n    ci_dir: str\n\n    global_env: dict[str, str] | None\n\n    default_runner: str\n\n    docker_registry: str\n\n    extra_build_steps: list[dict[str, Any]] | None\n\n    images: list[DockerImage]\n\n    def docker_login_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a github action str to login to docker.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        login_obj = \"\"\"\\\n            name: docker-login\n            uses: docker/login-action@v3\n            with:\n              registry: ghcr.io\n              username: ${{ github.actor }}\n              password: ${{ secrets.GITHUB_TOKEN }}\"\"\"\n        return _indent(dedent(login_obj), 4)\n\n    def global_env_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a github action str with the global environment variables.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        all_vars = {\n            'GITHUB_TOKEN': '${{ secrets.GITHUB_TOKEN }}',\n            'M_TAG': '${{ inputs.m-tag }}',\n            'M_CACHE_FROM_PR': '${{ inputs.cache-from-pr }}',\n            **(self.global_env or {}),\n        }\n        vars_str = '\\n'.join([\n            f'  {env_var}: {env_val}'\n            for env_var, env_val in all_vars.items()\n        ])\n        return f'\\n{vars_str}'\n\n    def build_steps_str(self: 'Workflow') -&gt; str:\n        \"\"\"Generate a github action str for the build steps.\n\n        Returns:\n            A string to add to the Github workflow.\n        \"\"\"\n        lines: list[str] = []\n        for step in self.extra_build_steps or []:\n            step_str = _indent(yaml.dumps(step)[:-1], 1)\n            lines.append(f'- {step_str}')\n        for img in self.images:\n            cache_sh = f'{self.ci_dir}/_find-cache.sh'\n            build_sh = f'{self.ci_dir}/{img.image_name}.build.sh'\n            push_sh = f'{self.ci_dir}/_push-image.sh'\n            image_steps = [\n                f'- name: {img.image_name} - cache',\n                f'  run: {cache_sh} {img.image_name}',\n                f'- name: {img.image_name} - build',\n                f'  run: {build_sh}',\n                f'- name: {img.image_name} - push',\n                f'  run: {push_sh} {img.image_name}',\n            ]\n            lines.extend(image_steps)\n        return _indent('\\n'.join(lines), 3)\n\n    def __str__(self: 'Workflow') -&gt; str:\n        \"\"\"Stringify the workflow file.\n\n        Returns:\n            The github workflow.\n        \"\"\"\n        template_vars = TemplateVars(\n            m_dir=self.m_dir,\n            default_runner=self.default_runner,\n            global_env=self.global_env_str(),\n            ci_dir=self.ci_dir,\n            docker_login=self.docker_login_str(),\n            build_steps=self.build_steps_str(),\n        )\n        return TEMPLATE.format(**template_vars.model_dump())\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow.__str__","title":"<code>__str__()</code>","text":"<p>Stringify the workflow file.</p> <p>Returns:</p> Type Description <code>str</code> <p>The github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>def __str__(self: 'Workflow') -&gt; str:\n    \"\"\"Stringify the workflow file.\n\n    Returns:\n        The github workflow.\n    \"\"\"\n    template_vars = TemplateVars(\n        m_dir=self.m_dir,\n        default_runner=self.default_runner,\n        global_env=self.global_env_str(),\n        ci_dir=self.ci_dir,\n        docker_login=self.docker_login_str(),\n        build_steps=self.build_steps_str(),\n    )\n    return TEMPLATE.format(**template_vars.model_dump())\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow.build_steps_str","title":"<code>build_steps_str()</code>","text":"<p>Generate a github action str for the build steps.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>def build_steps_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a github action str for the build steps.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    lines: list[str] = []\n    for step in self.extra_build_steps or []:\n        step_str = _indent(yaml.dumps(step)[:-1], 1)\n        lines.append(f'- {step_str}')\n    for img in self.images:\n        cache_sh = f'{self.ci_dir}/_find-cache.sh'\n        build_sh = f'{self.ci_dir}/{img.image_name}.build.sh'\n        push_sh = f'{self.ci_dir}/_push-image.sh'\n        image_steps = [\n            f'- name: {img.image_name} - cache',\n            f'  run: {cache_sh} {img.image_name}',\n            f'- name: {img.image_name} - build',\n            f'  run: {build_sh}',\n            f'- name: {img.image_name} - push',\n            f'  run: {push_sh} {img.image_name}',\n        ]\n        lines.extend(image_steps)\n    return _indent('\\n'.join(lines), 3)\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow.docker_login_str","title":"<code>docker_login_str()</code>","text":"<p>Generate a github action str to login to docker.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>def docker_login_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a github action str to login to docker.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    login_obj = \"\"\"\\\n        name: docker-login\n        uses: docker/login-action@v3\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\"\"\"\n    return _indent(dedent(login_obj), 4)\n</code></pre>"},{"location":"api/m/ci/docker/gh_workflow_single/#m.ci.docker.gh_workflow_single.Workflow.global_env_str","title":"<code>global_env_str()</code>","text":"<p>Generate a github action str with the global environment variables.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string to add to the Github workflow.</p> Source code in <code>m/ci/docker/gh_workflow_single.py</code> <pre><code>def global_env_str(self: 'Workflow') -&gt; str:\n    \"\"\"Generate a github action str with the global environment variables.\n\n    Returns:\n        A string to add to the Github workflow.\n    \"\"\"\n    all_vars = {\n        'GITHUB_TOKEN': '${{ secrets.GITHUB_TOKEN }}',\n        'M_TAG': '${{ inputs.m-tag }}',\n        'M_CACHE_FROM_PR': '${{ inputs.cache-from-pr }}',\n        **(self.global_env or {}),\n    }\n    vars_str = '\\n'.join([\n        f'  {env_var}: {env_val}'\n        for env_var, env_val in all_vars.items()\n    ])\n    return f'\\n{vars_str}'\n</code></pre>"},{"location":"api/m/ci/docker/image/","title":"image","text":""},{"location":"api/m/ci/docker/image/#m.ci.docker.image.DockerImage","title":"<code>DockerImage</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Information describing how to a docker image.</p> <p>Attributes:</p> Name Type Description <code>step_name</code> <code>str</code> <p>...</p> <code>image_name</code> <code>str</code> <p>...</p> <code>docker_file</code> <code>str</code> <p>...</p> <code>target_stage</code> <code>str | None</code> <p>...</p> <code>build_args</code> <code>dict[str, str]</code> <p>...</p> <code>env_secrets</code> <code>list[str] | None</code> <p>...</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>class DockerImage(BaseModel):\n    \"\"\"Information describing how to a docker image.\"\"\"\n\n    # String used to describe the step in the workflow.\n    step_name: str\n\n    # The name of the image - usually prefixed with the name of the repo.\n    image_name: str\n\n    # Name of the docker file to use for the build step.\n    docker_file: str\n\n    # Name of a target stage to build. Leave empty to build the whole file.\n    target_stage: str | None = None\n\n    # Arguments to pass to the docker build command, they will only be injected\n    # if they appear within the docker file.\n    build_args: dict[str, str] = {}\n\n    # name of envvars to be treated as secrets.\n    env_secrets: list[str] | None = None\n\n    def format_build_args(\n        self: 'DockerImage',\n        m_env: MEnvDocker,\n        arch: str,\n        extras: dict[str, str] | None = None,\n    ) -&gt; Res[list[str]]:\n        \"\"\"Format the arguments to pass to the docker build command.\n\n        Docker will only inject build args if they appear in the docker file.\n\n        Args:\n            m_env: The MEnvDocker instance with the environment variables.\n            arch: The architecture to build for.\n            extras: Extra build arguments.\n\n        Returns:\n            A list with the build arguments.\n        \"\"\"\n        docker_file = f'{m_env.base_path}/{self.docker_file}'\n        docker_file_res = read_file(docker_file)\n        if isinstance(docker_file_res, Bad):\n            return Bad(docker_file_res.value)\n        docker_file_contents = docker_file_res.value\n        all_args = {\n            'M_TAG': m_env.m_tag,\n            **(extras or {}),\n            **self.build_args,\n        }\n        # Only add the arch if multi-arch is enabled.\n        if m_env.multi_arch:\n            all_args['ARCH'] = arch\n        return Good([\n            f'{key}={arg_value}'\n            for key, arg_value in all_args.items()\n            if f'ARG {key}' in docker_file_contents\n        ])\n\n    def format_env_secrets(self: 'DockerImage') -&gt; list[str] | None:\n        \"\"\"Format the environment secrets to pass to the docker build command.\n\n        Returns:\n            A list of valid `secret` arguments.\n        \"\"\"\n        env_sec = self.env_secrets or []\n        return [f'id={env}' for env in env_sec] if env_sec else None\n\n    def ci_build(self: 'DockerImage', m_env: MEnvDocker) -&gt; Res[str]:\n        \"\"\"Generate a shell script to build an image in the CI pipelines.\n\n        Args:\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            A shell snippet with a docker build command.\n        \"\"\"\n        build_args = self.format_build_args(m_env, '\"$ARCH\"')\n        if isinstance(build_args, Bad):\n            return Bad(build_args.value)\n        build_args.value.append('BUILDKIT_INLINE_CACHE=1')\n\n        docker_file = f'{m_env.base_path}/{self.docker_file}'\n        img_name = f'{m_env.registry}/{self.image_name}'\n        build_cmd = DockerBuild(\n            progress='plain',\n            cache_from='staged-image:cache',\n            secret=self.format_env_secrets(),\n            tag=[\n                'staged-image:latest',\n                f'{img_name}:{m_env.m_tag}',\n            ],\n            build_arg=build_args.value,\n            target=self.target_stage,\n            file=docker_file,\n        )\n        script = [\n            BASH_SHEBANG,\n            'export DOCKER_BUILDKIT=1',\n            SET_STRICT_BASH,\n            '',\n            str(build_cmd),\n            '',\n        ]\n        return Good('\\n'.join(script))\n\n    def local_build(self: 'DockerImage', m_env: MEnvDocker) -&gt; Res[str]:\n        \"\"\"Generate a shell script to build an image.\n\n        Args:\n            m_env: The MEnvDocker instance with the environment variables.\n\n        Returns:\n            A shell snippet with a docker build command.\n        \"\"\"\n        arch = get_arch()\n        build_args = self.format_build_args(m_env, arch)\n        if isinstance(build_args, Bad):\n            return Bad(build_args.value)\n\n        docker_file = f'{m_env.base_path}/{self.docker_file}'\n        img_name = f'{m_env.registry}/{self.image_name}'\n        build_cmd = DockerBuild(\n            progress='plain',\n            secret=self.format_env_secrets(),\n            tag=[\n                'staged-image:latest',\n                f'{img_name}:{m_env.m_tag}',\n            ],\n            build_arg=build_args.value,\n            target=self.target_stage,\n            file=docker_file,\n        )\n        script = [\n            BASH_SHEBANG,\n            'export DOCKER_BUILDKIT=1',\n            SET_STRICT_BASH,\n            '',\n            str(build_cmd),\n            '',\n        ]\n        return Good('\\n'.join(script))\n</code></pre>"},{"location":"api/m/ci/docker/image/#m.ci.docker.image.DockerImage.ci_build","title":"<code>ci_build(m_env)</code>","text":"<p>Generate a shell script to build an image in the CI pipelines.</p> <p>Parameters:</p> Name Type Description Default <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A shell snippet with a docker build command.</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>def ci_build(self: 'DockerImage', m_env: MEnvDocker) -&gt; Res[str]:\n    \"\"\"Generate a shell script to build an image in the CI pipelines.\n\n    Args:\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        A shell snippet with a docker build command.\n    \"\"\"\n    build_args = self.format_build_args(m_env, '\"$ARCH\"')\n    if isinstance(build_args, Bad):\n        return Bad(build_args.value)\n    build_args.value.append('BUILDKIT_INLINE_CACHE=1')\n\n    docker_file = f'{m_env.base_path}/{self.docker_file}'\n    img_name = f'{m_env.registry}/{self.image_name}'\n    build_cmd = DockerBuild(\n        progress='plain',\n        cache_from='staged-image:cache',\n        secret=self.format_env_secrets(),\n        tag=[\n            'staged-image:latest',\n            f'{img_name}:{m_env.m_tag}',\n        ],\n        build_arg=build_args.value,\n        target=self.target_stage,\n        file=docker_file,\n    )\n    script = [\n        BASH_SHEBANG,\n        'export DOCKER_BUILDKIT=1',\n        SET_STRICT_BASH,\n        '',\n        str(build_cmd),\n        '',\n    ]\n    return Good('\\n'.join(script))\n</code></pre>"},{"location":"api/m/ci/docker/image/#m.ci.docker.image.DockerImage.format_build_args","title":"<code>format_build_args(m_env, arch, extras=None)</code>","text":"<p>Format the arguments to pass to the docker build command.</p> <p>Docker will only inject build args if they appear in the docker file.</p> <p>Parameters:</p> Name Type Description Default <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <code>arch</code> <code>str</code> <p>The architecture to build for.</p> required <code>extras</code> <code>dict[str, str] | None</code> <p>Extra build arguments.</p> <code>None</code> <p>Returns:</p> Type Description <code>Res[list[str]]</code> <p>A list with the build arguments.</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>def format_build_args(\n    self: 'DockerImage',\n    m_env: MEnvDocker,\n    arch: str,\n    extras: dict[str, str] | None = None,\n) -&gt; Res[list[str]]:\n    \"\"\"Format the arguments to pass to the docker build command.\n\n    Docker will only inject build args if they appear in the docker file.\n\n    Args:\n        m_env: The MEnvDocker instance with the environment variables.\n        arch: The architecture to build for.\n        extras: Extra build arguments.\n\n    Returns:\n        A list with the build arguments.\n    \"\"\"\n    docker_file = f'{m_env.base_path}/{self.docker_file}'\n    docker_file_res = read_file(docker_file)\n    if isinstance(docker_file_res, Bad):\n        return Bad(docker_file_res.value)\n    docker_file_contents = docker_file_res.value\n    all_args = {\n        'M_TAG': m_env.m_tag,\n        **(extras or {}),\n        **self.build_args,\n    }\n    # Only add the arch if multi-arch is enabled.\n    if m_env.multi_arch:\n        all_args['ARCH'] = arch\n    return Good([\n        f'{key}={arg_value}'\n        for key, arg_value in all_args.items()\n        if f'ARG {key}' in docker_file_contents\n    ])\n</code></pre>"},{"location":"api/m/ci/docker/image/#m.ci.docker.image.DockerImage.format_env_secrets","title":"<code>format_env_secrets()</code>","text":"<p>Format the environment secrets to pass to the docker build command.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>A list of valid <code>secret</code> arguments.</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>def format_env_secrets(self: 'DockerImage') -&gt; list[str] | None:\n    \"\"\"Format the environment secrets to pass to the docker build command.\n\n    Returns:\n        A list of valid `secret` arguments.\n    \"\"\"\n    env_sec = self.env_secrets or []\n    return [f'id={env}' for env in env_sec] if env_sec else None\n</code></pre>"},{"location":"api/m/ci/docker/image/#m.ci.docker.image.DockerImage.local_build","title":"<code>local_build(m_env)</code>","text":"<p>Generate a shell script to build an image.</p> <p>Parameters:</p> Name Type Description Default <code>m_env</code> <code>MEnvDocker</code> <p>The MEnvDocker instance with the environment variables.</p> required <p>Returns:</p> Type Description <code>Res[str]</code> <p>A shell snippet with a docker build command.</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>def local_build(self: 'DockerImage', m_env: MEnvDocker) -&gt; Res[str]:\n    \"\"\"Generate a shell script to build an image.\n\n    Args:\n        m_env: The MEnvDocker instance with the environment variables.\n\n    Returns:\n        A shell snippet with a docker build command.\n    \"\"\"\n    arch = get_arch()\n    build_args = self.format_build_args(m_env, arch)\n    if isinstance(build_args, Bad):\n        return Bad(build_args.value)\n\n    docker_file = f'{m_env.base_path}/{self.docker_file}'\n    img_name = f'{m_env.registry}/{self.image_name}'\n    build_cmd = DockerBuild(\n        progress='plain',\n        secret=self.format_env_secrets(),\n        tag=[\n            'staged-image:latest',\n            f'{img_name}:{m_env.m_tag}',\n        ],\n        build_arg=build_args.value,\n        target=self.target_stage,\n        file=docker_file,\n    )\n    script = [\n        BASH_SHEBANG,\n        'export DOCKER_BUILDKIT=1',\n        SET_STRICT_BASH,\n        '',\n        str(build_cmd),\n        '',\n    ]\n    return Good('\\n'.join(script))\n</code></pre>"},{"location":"api/m/ci/docker/image/#m.ci.docker.image.get_arch","title":"<code>get_arch()</code>","text":"<p>Get the architecture of the current machine.</p> <p>Returns:</p> Type Description <code>str</code> <p>The architecture of the current machine.</p> Source code in <code>m/ci/docker/image.py</code> <pre><code>def get_arch() -&gt; str:\n    \"\"\"Get the architecture of the current machine.\n\n    Returns:\n        The architecture of the current machine.\n    \"\"\"\n    mapping = {\n        # amd\n        'i386': AMD64,\n        'x86_64': AMD64,\n        # arm\n        'aarch64': ARM64,\n    }\n    arch = platform.machine()\n    return mapping.get(arch, arch)\n</code></pre>"},{"location":"api/m/ci/docker/shell_command/","title":"shell_command","text":""},{"location":"api/m/ci/docker/shell_command/#m.ci.docker.shell_command.ShellCommand","title":"<code>ShellCommand</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Representation of a shell command.</p> <p>Attributes:</p> Name Type Description <code>prog</code> <code>str</code> <p>...</p> <code>options</code> <code>dict[str, str | list[str] | bool]</code> <p>...</p> <code>positional</code> <code>list[str]</code> <p>...</p> Source code in <code>m/ci/docker/shell_command.py</code> <pre><code>class ShellCommand(BaseModel):\n    \"\"\"Representation of a shell command.\"\"\"\n\n    # Name of the program to run. May contain spaces if the program is a subcommand.\n    prog: str\n\n    # Arguments to pass to the program.\n    # If the key starts with `--` it will be passed as is. Otherwise it will be\n    # considered as a python property and will be passed as `--key`.\n    options: dict[str, str | list[str] | bool] = {}\n\n    # Positional arguments to pass to the program.\n    positional: list[str] = []\n\n    def __str__(self) -&gt; str:\n        \"\"\"Render the command as a string.\n\n        A new line is not added to the end of the string in case the command\n        needs to be piped to another command.\n\n        Returns:\n            A string representation of the command.\n        \"\"\"\n        lines = [self.prog, *_to_list(self.options), *self.positional]\n        # We need to join with a backslash and a new line.\n        return' \\\\\\n  '.join(lines)  # noqa: WPS342\n</code></pre>"},{"location":"api/m/ci/docker/shell_command/#m.ci.docker.shell_command.ShellCommand.__str__","title":"<code>__str__()</code>","text":"<p>Render the command as a string.</p> <p>A new line is not added to the end of the string in case the command needs to be piped to another command.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the command.</p> Source code in <code>m/ci/docker/shell_command.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Render the command as a string.\n\n    A new line is not added to the end of the string in case the command\n    needs to be piped to another command.\n\n    Returns:\n        A string representation of the command.\n    \"\"\"\n    lines = [self.prog, *_to_list(self.options), *self.positional]\n    # We need to join with a backslash and a new line.\n    return' \\\\\\n  '.join(lines)  # noqa: WPS342\n</code></pre>"},{"location":"api/m/ci/docker/shell_scripts/","title":"shell_scripts","text":""},{"location":"api/m/ci/docker/shell_scripts/#m.ci.docker.shell_scripts.create_cache_script","title":"<code>create_cache_script(pr_num, docker_registry)</code>","text":"<p>Create a script to retrieve cache for an image.</p> <p>Parameters:</p> Name Type Description Default <code>pr_num</code> <code>str</code> <p>The pull request number where to pull the cache from.</p> required <code>docker_registry</code> <code>str</code> <p>The docker registry where the images are located.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A script to find the cache.</p> Source code in <code>m/ci/docker/shell_scripts.py</code> <pre><code>def create_cache_script(pr_num: str, docker_registry: str) -&gt; str:\n    \"\"\"Create a script to retrieve cache for an image.\n\n    Args:\n        pr_num: The pull request number where to pull the cache from.\n        docker_registry: The docker registry where the images are located.\n\n    Returns:\n        A script to find the cache.\n    \"\"\"\n    pulls = ['pullCache \"$1\" master', 'echo \"NO CACHE FOUND\"']\n    if pr_num:\n        pulls.insert(0, f'pullCache \"$1\" \"pr{pr_num}\"')\n    find_cache_implementation = ' || '.join(pulls)\n    replacements = {\n        'docker_registry': docker_registry,\n        'find_cache_implementation': find_cache_implementation,\n    }\n    return FIND_CACHE_SCRIPT.format(**replacements)\n</code></pre>"},{"location":"api/m/ci/docker/shell_scripts/#m.ci.docker.shell_scripts.create_push_script","title":"<code>create_push_script(docker_registry)</code>","text":"<p>Create a script to push an image.</p> <p>Parameters:</p> Name Type Description Default <code>docker_registry</code> <code>str</code> <p>The docker registry where the images will be pushed.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A script to push an image.</p> Source code in <code>m/ci/docker/shell_scripts.py</code> <pre><code>def create_push_script(docker_registry: str) -&gt; str:\n    \"\"\"Create a script to push an image.\n\n    Args:\n        docker_registry: The docker registry where the images will be pushed.\n\n    Returns:\n        A script to push an image.\n    \"\"\"\n    return PUSH_SCRIPT.format(docker_registry=docker_registry)\n</code></pre>"},{"location":"api/m/ci/docker/shell_scripts/#m.ci.docker.shell_scripts.create_push_script_tags","title":"<code>create_push_script_tags(docker_registry, m_tag)</code>","text":"<p>Create a script to push an image.</p> <p>This is meant to be used when building for a single architecture.</p> <p>Parameters:</p> Name Type Description Default <code>docker_registry</code> <code>str</code> <p>The docker registry where the images will be pushed.</p> required <code>m_tag</code> <code>str</code> <p>The unique tag for the image.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A script to push an image.</p> Source code in <code>m/ci/docker/shell_scripts.py</code> <pre><code>def create_push_script_tags(docker_registry: str, m_tag: str) -&gt; str:\n    \"\"\"Create a script to push an image.\n\n    This is meant to be used when building for a single architecture.\n\n    Args:\n        docker_registry: The docker registry where the images will be pushed.\n        m_tag: The unique tag for the image.\n\n    Returns:\n        A script to push an image.\n    \"\"\"\n    if not m_tag and os.environ.get('CI') != 'true':\n        logger.warning('M_TAG not found in non-CI environment. Using 1.1.1')\n        m_tag = '1.1.1'\n    tags = [m_tag, *docker_tags(m_tag)]\n    tagged_images = '\\n'.join([\n        f'docker tag staged-image:latest \"{docker_registry}/$imageName:{tag}\"'\n        for tag in tags\n    ])\n    return PUSH_SCRIPT_TAGS.format(\n        docker_registry=docker_registry,\n        tag_images=tagged_images,\n    )\n</code></pre>"},{"location":"api/m/ci/docker/tags/","title":"tags","text":""},{"location":"api/m/ci/docker/tags/#m.ci.docker.tags.docker_tags","title":"<code>docker_tags(m_tag, *, skip_floating=False)</code>","text":"<p>Convert an m_tag to docker tags.</p> <p>Floating tags include <code>latest</code> and any <code>vX</code> or <code>vX.Y</code> tags. The <code>skip_floating</code> argument is intended for use when building packages that have already been published in the past.</p> <p>Parameters:</p> Name Type Description Default <code>m_tag</code> <code>str</code> <p>A tag/version provided by m.</p> required <code>skip_floating</code> <code>bool</code> <p>If true, do not include floating tags.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A tag that can be used by docker during the publishing step.</p> Source code in <code>m/ci/docker/tags.py</code> <pre><code>def docker_tags(m_tag: str, *, skip_floating: bool = False) -&gt; list[str]:\n    \"\"\"Convert an m_tag to docker tags.\n\n    Floating tags include `latest` and any `vX` or `vX.Y` tags.\n    The `skip_floating` argument is intended for use when building packages\n    that have already been published in the past.\n\n    Args:\n        m_tag: A tag/version provided by m.\n        skip_floating: If true, do not include floating tags.\n\n    Returns:\n        A tag that can be used by docker during the publishing step.\n    \"\"\"\n    tags = []\n    regex = r'\\d+.\\d+.\\d+-(.*)\\.(.*)'\n    matches = re.match(regex, m_tag)\n    if matches:\n        tag, _ = matches.groups()\n        if tag.startswith('rc') or tag.startswith('hotfix'):\n            tags.append('next')\n            index = 2 if tag.startswith('rc') else 6\n            pr_num = tag[index:]\n            tags.append(f'pr{pr_num}')\n        else:\n            tags.append(tag)\n    else:\n        x, y, _ = m_tag.split('.')\n        if not skip_floating:\n            tags.append('latest')\n            tags.append(f'v{x}')\n            tags.append(f'v{x}.{y}')\n\n    return tags\n</code></pre>"},{"location":"api/m/cli/","title":"cli","text":""},{"location":"api/m/cli/#m.cli.CliCommands","title":"<code>CliCommands</code>  <code>dataclass</code>","text":"<p>Container to store the commands and subcommands for the cli.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CliCommands:\n    \"\"\"Container to store the commands and subcommands for the cli.\"\"\"\n\n    commands: dict[str, CommandModule | CliSubcommands]\n\n    # Optional root meta data to provide information about the cli.\n    meta: MetaModule | None\n</code></pre>"},{"location":"api/m/cli/#m.cli.CommandModule","title":"<code>CommandModule</code>  <code>dataclass</code>","text":"<p>Container to store the run function from a \"command\" module.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CommandModule:\n    \"\"\"Container to store the run function from a \"command\" module.\"\"\"\n\n    run: DecoratedRunFunction\n</code></pre>"},{"location":"api/m/cli/#m.cli.FuncArgs","title":"<code>FuncArgs</code>  <code>dataclass</code>","text":"<p>Stores function arguments.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass FuncArgs:\n    \"\"\"Stores function arguments.\"\"\"\n\n    args: list[Any]\n    kwargs: dict[str, Any]\n</code></pre>"},{"location":"api/m/cli/#m.cli.MetaModule","title":"<code>MetaModule</code>  <code>dataclass</code>","text":"<p>Container to store a metadata dictionary from a \"meta\" module.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass MetaModule:\n    \"\"\"Container to store a metadata dictionary from a \"meta\" module.\"\"\"\n\n    meta: dict[str, str]\n    add_arguments: Callable[[ap.ArgumentParser], None] | None = None\n</code></pre>"},{"location":"api/m/cli/#m.cli.Arg","title":"<code>Arg(default=PydanticUndefined, *, help, positional=None, required=None, aliases=None, nargs=None, validator=None)</code>","text":"<p>Create a pydantic <code>Field</code>.</p> <p>Field docs: https://docs.pydantic.dev/2.2/usage/fields</p> <p>Defines properties used to create an argparse argument. This function should work for most cases. If we need something that is not covered we can use <code>ArgProxy</code> instead which is untyped but provides all the arguments and keyword arguments to argparse.</p> <p>See https://docs.python.org/3/library/argparse.html.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any</code> <p>Default value if the field is not set.</p> <code>PydanticUndefined</code> <code>help</code> <code>str</code> <p>Human-readable description.</p> required <code>positional</code> <code>bool | None</code> <p>Whether the argument is positional or not.</p> <code>None</code> <code>required</code> <code>bool | None</code> <p>Indicate whether an argument is required or optional.</p> <code>None</code> <code>aliases</code> <code>list[str] | None</code> <p>Alternative names for the argument.</p> <code>None</code> <code>nargs</code> <code>int | Literal['?', '*', '+'] | None</code> <p>Number of times the argument can be used.</p> <code>None</code> <code>validator</code> <code>Callable[[str], str] | None</code> <p>Function to validate the argument.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>. The return annotation is <code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def Arg(  # noqa: N802, WPS211\n    default: Any = PydanticUndefined,\n    *,\n    help: str,  # noqa: WPS125\n    positional: bool | None = None,\n    required: bool | None = None,\n    aliases: list[str] | None = None,\n    nargs: int | Literal['?', '*', '+'] | None = None,\n    validator: Callable[[str], str] | None = None,\n) -&gt; Any:\n    \"\"\"Create a pydantic `Field`.\n\n    Field docs: https://docs.pydantic.dev/2.2/usage/fields\n\n    Defines properties used to create an argparse argument. This function\n    should work for most cases. If we need something that is not covered\n    we can use `ArgProxy` instead which is untyped but provides all the arguments\n    and keyword arguments to argparse.\n\n    See https://docs.python.org/3/library/argparse.html.\n\n    Args:\n        default: Default value if the field is not set.\n        help: Human-readable description.\n        positional: Whether the argument is positional or not.\n        required: Indicate whether an argument is required or optional.\n        aliases: Alternative names for the argument.\n        nargs: Number of times the argument can be used.\n        validator: Function to validate the argument.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is\n            `Any` so `Arg` can be used on type annotated fields without causing\n            a typing error.\n    \"\"\"\n    extras = {\n        'positional': positional,\n        'validator': validator,\n        'aliases': aliases,\n        'nargs': nargs,\n        'required': required,\n    }\n    return FieldInfo.from_field(\n        default,\n        description=cleandoc(help),\n        json_schema_extra={k: v for k, v in extras.items() if v is not None},\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.ArgProxy","title":"<code>ArgProxy(*args, **kwargs)</code>","text":"<p>Wrap function to provide all argparse inputs.</p> <p>This is a escape hatch and does not provide any typings. See https://docs.python.org/3/library/argparse.html.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The arguments to argparse add_arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to argparse add arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>. The return annotation is <code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def ArgProxy(*args: Any, **kwargs: Any) -&gt; Any:  # noqa: N802\n    \"\"\"Wrap function to provide all argparse inputs.\n\n    This is a escape hatch and does not provide any typings.\n    See https://docs.python.org/3/library/argparse.html.\n\n    Args:\n        args: The arguments to argparse add_arguments.\n        kwargs: The keyword arguments to argparse add arguments.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is\n            `Any` so `Arg` can be used on type annotated fields without causing\n            a typing error.\n    \"\"\"\n    return FieldInfo.from_field(\n        json_schema_extra={\n            'proxy': FuncArgs(args=list(args), kwargs=kwargs),\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.Meta","title":"<code>Meta(*, help, description)</code>","text":"<p>Create the meta dictionary for a subcommand description.</p> <p>In the case of the root command the <code>help</code> may be set to empty since it is not used.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>The help message for the subcommand.</p> required <code>description</code> <code>str</code> <p>The description for the command/subcommand.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary with the help and description.</p> Source code in <code>m/cli/args.py</code> <pre><code>def Meta(  # noqa: N802\n    *,\n    help: str,  # noqa: WPS125\n    description: str,\n) -&gt; dict[str, str]:\n    \"\"\"Create the meta dictionary for a subcommand description.\n\n    In the case of the root command the `help` may be set to empty since it\n    is not used.\n\n    Args:\n        help: The help message for the subcommand.\n        description: The description for the command/subcommand.\n\n    Returns:\n        A dictionary with the help and description.\n    \"\"\"\n    return {\n        'help': help,\n        'description': cleandoc(description),\n    }\n</code></pre>"},{"location":"api/m/cli/#m.cli.RemainderArgs","title":"<code>RemainderArgs(*, help=_Unset)</code>","text":"<p>Provide a list of unrecognized arguments.</p> <p>This is a escape hatch and does not provide any typings. May be useful for commands that need to pass arguments to other commands.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str | None</code> <p>Human-readable description.</p> <code>_Unset</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>, the return annotation is</p> <code>Any</code> <p><code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def RemainderArgs(  # noqa: N802\n    *,\n    help: str | None = _Unset,  # noqa: WPS125\n) -&gt; Any:\n    \"\"\"Provide a list of unrecognized arguments.\n\n    This is a escape hatch and does not provide any typings. May be\n    useful for commands that need to pass arguments to other commands.\n\n    Args:\n        help: Human-readable description.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo], the return annotation is\n        `Any` so `Arg` can be used on type annotated fields without causing a typing error.\n    \"\"\"\n    return FieldInfo.from_field(\n        [],\n        description=help,\n        json_schema_extra={'__remainder_args': True},\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.add_arg","title":"<code>add_arg(*args, **kwargs)</code>","text":"<p>Wrap FuncArgs arguments in a function.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The arguments to argparse add_arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to argparse add arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FuncArgs</code> <p>A FuncArgs instance.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `add_arg` method is deprecated; use `m.cli.ArgProxy` instead.',\n)\ndef add_arg(*args: Any, **kwargs: Any) -&gt; FuncArgs:\n    \"\"\"Wrap FuncArgs arguments in a function.\n\n    Args:\n        args: The arguments to argparse add_arguments.\n        kwargs: The keyword arguments to argparse add arguments.\n\n    Returns:\n        A FuncArgs instance.\n    \"\"\"\n    # `m` does not reference this function anymore, excluding from coverage\n    return FuncArgs(args=list(args), kwargs=kwargs)  # pragma: no cover\n</code></pre>"},{"location":"api/m/cli/#m.cli.cli_commands","title":"<code>cli_commands(root_meta=None, **commands)</code>","text":"<p>Create a CliCommands instance.</p> <p>Parameters:</p> Name Type Description Default <code>root_meta</code> <code>MetaModule | None</code> <p>The meta for the root command.</p> <code>None</code> <code>commands</code> <code>DecoratedRunFunction | CliSubcommands</code> <p>The commands and subcommands for the cli.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliCommands</code> <p>An instance of CliCommands.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def cli_commands(\n    root_meta: MetaModule | None = None,\n    **commands: DecoratedRunFunction | CliSubcommands,\n) -&gt; CliCommands:\n    \"\"\"Create a CliCommands instance.\n\n    Args:\n        root_meta: The meta for the root command.\n        commands: The commands and subcommands for the cli.\n\n    Returns:\n        An instance of CliCommands.\n    \"\"\"\n    root_meta = root_meta or default_root_meta\n    return CliCommands(\n        meta=root_meta,\n        commands={\n            cmd_name: (\n                cmd_item\n                if isinstance(cmd_item, CliSubcommands)\n                else CommandModule(run=cmd_item)\n            )\n            for cmd_name, cmd_item in commands.items()\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.cli_integration_token","title":"<code>cli_integration_token(integration, env_var)</code>","text":"<p>Return a function that takes in a parser.</p> <p>This generated function registers a token argument in the parser which looks for its value in the environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>integration</code> <code>str</code> <p>The name of the integration.</p> required <code>env_var</code> <code>str</code> <p>The environment variable name.</p> required <p>Returns:</p> Type Description <code>cli_global_option</code> <p>A function to add arguments to an argparse parser.</p> Source code in <code>m/cli/cli.py</code> <pre><code>def cli_integration_token(\n    integration: str,\n    env_var: str,\n) -&gt; cli_global_option:\n    \"\"\"Return a function that takes in a parser.\n\n    This generated function registers a token argument in the parser\n    which looks for its value in the environment variables.\n\n    Args:\n        integration: The name of the integration.\n        env_var: The environment variable name.\n\n    Returns:\n        A function to add arguments to an argparse parser.\n    \"\"\"\n    return lambda parser: parser.add_argument(\n        '-t',\n        '--token',\n        type=validate_non_empty_str,\n        default=env(env_var),\n        help=f'{integration} access token (default: env.{env_var})',\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.command","title":"<code>command(*, help, model, name=None)</code>","text":"<p>Apply a decorator to the <code>run</code> function to make it into a command.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The command name.</p> <code>None</code> <code>help</code> <code>str</code> <p>A short description of the command.</p> required <code>model</code> <code>type[BaseModel]</code> <p>A pydantic model to describe the cli arguments.</p> required <p>Returns:</p> Type Description <code>partial[partial[int]]</code> <p>A transformed run function aware of the arguments model.</p> Source code in <code>m/cli/engine/argparse.py</code> <pre><code>def command(\n    *,\n    help: str,  # noqa: WPS125\n    model: type[BaseModel],\n    name: str | None = None,\n) -&gt; partial[partial[int]]:\n    \"\"\"Apply a decorator to the `run` function to make it into a command.\n\n    Args:\n        name: The command name.\n        help: A short description of the command.\n        model: A pydantic model to describe the cli arguments.\n\n    Returns:\n        A transformed run function aware of the arguments model.\n    \"\"\"\n    # m no longer uses the name argument but we keep it for now\n    if name:  # pragma: no cover\n        warn('`name` is no longer needed, please remove it', DeprecationWarning)\n    return partial(_handle_decorated_func, CommandInputs(help, model))\n</code></pre>"},{"location":"api/m/cli/#m.cli.command_group","title":"<code>command_group(*, help, description, add_arguments=None)</code>","text":"<p>Create an instance of a MetaModule.</p> <p>Named <code>cmd_group</code> since it is used to describe the group of commands.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>quick help describing the module.</p> required <code>description</code> <code>str</code> <p>Detailed description about the module.</p> required <code>add_arguments</code> <code>Callable[[ArgumentParser], None] | None</code> <p>Optional function to handle the argparse instance.</p> <code>None</code> <p>Returns:</p> Type Description <code>MetaModule</code> <p>An instance of a MetaModule.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def command_group(\n    *,\n    help: str,   # noqa: WPS125\n    description: str,\n    add_arguments: Callable[[ap.ArgumentParser], None] | None = None,\n) -&gt; MetaModule:\n    \"\"\"Create an instance of a MetaModule.\n\n    Named `cmd_group` since it is used to describe the group of commands.\n\n    Args:\n        help: quick help describing the module.\n        description: Detailed description about the module.\n        add_arguments: Optional function to handle the argparse instance.\n\n    Returns:\n        An instance of a MetaModule.\n    \"\"\"\n    return MetaModule(\n        meta=Meta(help=help, description=description),\n        add_arguments=add_arguments,\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.create_issue_handler","title":"<code>create_issue_handler(use_warning)</code>","text":"<p>Generate a function to log an issue.</p> <p>Parameters:</p> Name Type Description Default <code>use_warning</code> <code>bool</code> <p>Uses a warning log instead of an error.</p> required <p>Returns:</p> Type Description <code>Callable[[Issue], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_issue_handler(use_warning: bool) -&gt; Callable[[Issue], None]:\n    \"\"\"Generate a function to log an issue.\n\n    Args:\n        use_warning: Uses a warning log instead of an error.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_issue_handler, use_warning)\n</code></pre>"},{"location":"api/m/cli/#m.cli.create_json_handler","title":"<code>create_json_handler(pretty)</code>","text":"<p>Generate a function to display a value to stdout as json.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>If true, it formats with indentation of 2 spaces.</p> required <p>Returns:</p> Type Description <code>Callable[[Any], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_json_handler(pretty: bool) -&gt; Callable[[Any], None]:\n    \"\"\"Generate a function to display a value to stdout as json.\n\n    Args:\n        pretty: If true, it formats with indentation of 2 spaces.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_json_handler, pretty)\n</code></pre>"},{"location":"api/m/cli/#m.cli.create_yaml_handler","title":"<code>create_yaml_handler(pretty)</code>","text":"<p>Generate a function to display a value to stdout as yaml.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>If true, it highlights the output.</p> required <p>Returns:</p> Type Description <code>Callable[[Any], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_yaml_handler(pretty: bool) -&gt; Callable[[Any], None]:\n    \"\"\"Generate a function to display a value to stdout as yaml.\n\n    Args:\n        pretty: If true, it highlights the output.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_yaml_handler, pretty)\n</code></pre>"},{"location":"api/m/cli/#m.cli.env_var","title":"<code>env_var(arg_value)</code>","text":"<p>Read a value from the environment.</p> <p>Parameters:</p> Name Type Description Default <code>arg_value</code> <code>str</code> <p>The input provided by argparse.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The environment variable value if it exists. Otherwise, the input.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def env_var(arg_value: str) -&gt; str:\n    \"\"\"Read a value from the environment.\n\n    Args:\n        arg_value: The input provided by argparse.\n\n    Returns:\n        The environment variable value if it exists. Otherwise, the input.\n    \"\"\"\n    return os.environ.get(arg_value, arg_value)\n</code></pre>"},{"location":"api/m/cli/#m.cli.env_var_or_empty","title":"<code>env_var_or_empty(arg_value)</code>","text":"<p>Read a value from the environment.</p> <p>Unlike the env_var validator, this will only allow the <code>arg_value</code> to pass through if is not in the form of an environment variable. That is, if the value is all uppercase letters and underscores it will attempt to read from the environment and return an empty string if not defined.</p> <p>Parameters:</p> Name Type Description Default <code>arg_value</code> <code>str</code> <p>The input provided by argparse.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The environment variable value if it exists. Otherwise, empty string.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def env_var_or_empty(arg_value: str) -&gt; str:\n    \"\"\"Read a value from the environment.\n\n    Unlike the [env_var][m.cli.validators.env_var] validator, this will only\n    allow the `arg_value` to pass through if is not in the form of an\n    environment variable. That is, if the value is all uppercase letters and\n    underscores it will attempt to read from the environment and return an empty\n    string if not defined.\n\n    Args:\n        arg_value: The input provided by argparse.\n\n    Returns:\n        The environment variable value if it exists. Otherwise, empty string.\n    \"\"\"\n    env_form = arg_value.upper().replace('-', '_', -1)\n    if arg_value == env_form:\n        return os.environ.get(arg_value, '')\n    return arg_value\n</code></pre>"},{"location":"api/m/cli/#m.cli.exec_cli","title":"<code>exec_cli(cli_commands)</code>","text":"<p>Execute the cli application.</p> <p>usage::</p> <pre><code>def create_cli_commands() -&gt; CliCommands:\n    # We may import CliCommand objects from other projects and create\n    # a new one with them.\n    return import_cli_commands('cli.command.module')\n\ndef main():\n    cli_commands = create_cli_commands()\n    exec_cli(cli_commands)\n</code></pre> <p>This is the preferred way to execute the cli application as it will allow other potential applications to use the cli commands.</p> <p>Parameters:</p> Name Type Description Default <code>cli_commands</code> <code>CliCommands</code> <p>The cli commands to execute.</p> required Source code in <code>m/cli/cli.py</code> <pre><code>def exec_cli(cli_commands: CliCommands) -&gt; None:\n    \"\"\"Execute the cli application.\n\n    usage::\n\n        def create_cli_commands() -&gt; CliCommands:\n            # We may import CliCommand objects from other projects and create\n            # a new one with them.\n            return import_cli_commands('cli.command.module')\n\n        def main():\n            cli_commands = create_cli_commands()\n            exec_cli(cli_commands)\n\n    This is the preferred way to execute the cli application as it will allow\n    other potential applications to use the cli commands.\n\n    Args:\n        cli_commands: The cli commands to execute.\n    \"\"\"\n    arg = _main_parser(cli_commands)\n\n    run_func = None\n    command_name = ''\n\n    commands = cli_commands.commands\n    # WPS421 encourages to use try/except instead of hasattr but in this\n    # case we want explicitly before using it.\n    if hasattr(arg, 'subcommand_name'):  # noqa: WPS421\n        command_name = arg.subcommand_name\n        sub_mod = cast(CliSubcommands, commands[arg.command_name])\n        run_func = sub_mod.subcommands[command_name].run\n    else:\n        command_name = arg.command_name\n        run_func = cast(CommandModule, commands[command_name]).run\n\n    len_run_args = params_count(run_func)\n    run_args = [command_name, arg, None][:len_run_args]\n    exit_code = 0\n    try:\n        # mypy is having a hard time figuring out the type of run_args\n        exit_code = run_func(*run_args)  # type:ignore[arg-type]\n    except Exception as ex:\n        default_issue_handler(\n            Issue('unknown cli run function exception', cause=ex),\n        )\n        exit_code = 5\n    sys.exit(exit_code)\n</code></pre>"},{"location":"api/m/cli/#m.cli.import_cli_commands","title":"<code>import_cli_commands(commands_module)</code>","text":"<p>Gather the commands and subcommands for the cli.</p> <p>Parameters:</p> Name Type Description Default <code>commands_module</code> <code>str</code> <p>module containing all the commands.</p> required <p>Returns:</p> Type Description <code>CliCommands</code> <p>An instance of CliCommands gathered from the commands_module.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def import_cli_commands(commands_module: str) -&gt; CliCommands:\n    \"\"\"Gather the commands and subcommands for the cli.\n\n    Args:\n        commands_module: module containing all the commands.\n\n    Returns:\n        An instance of CliCommands gathered from the commands_module.\n    \"\"\"\n    cmd_module = import_module(commands_module)\n    if hasattr(cmd_module, 'create_cli_commands'):\n        # No extra checks for now, if a module has this we assume that\n        # it has the right signature.\n        return cast(CliCommands, cmd_module.create_cli_commands())\n\n    commands: dict[str, CommandModule | CliSubcommands] = {}\n    root_cmd = get_command_modules(commands_module)\n\n    for key, cmd_mod in root_cmd.items():\n        commands[key] = cmd_mod\n\n    root = pth.split(cmd_module.__file__ or '')[0]\n    for cmd_name in iglob(f'{root}/*'):\n        if cmd_name.endswith('.py') or cmd_name.endswith('__'):\n            continue\n        name = pth.split(cmd_name)[1]\n        commands[name] = CliSubcommands(\n            meta=_get_meta_module(f'{commands_module}.{name}', default_meta),\n            subcommands=get_command_modules(f'{commands_module}.{name}'),\n        )\n\n    return CliCommands(\n        meta=_get_meta_module(commands_module, default_root_meta),\n        commands=commands,\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.merge_cli_commands","title":"<code>merge_cli_commands(base, overrides, **resolutions)</code>","text":"<p>Merge two CliCommands instances.</p> <p>Resolutions may be provided to resolve merge conflicts between two subcommands.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>CliCommands</code> <p>The base CliCommands instance.</p> required <code>overrides</code> <code>CliCommands</code> <p>The overrides CliCommands instance.</p> required <code>resolutions</code> <code>SubCmdResolution</code> <p>A dictionary of resolutions for subcommands.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliCommands</code> <p>A new CliCommands instance.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def merge_cli_commands(\n    base: CliCommands,\n    overrides: CliCommands,\n    **resolutions: SubCmdResolution,\n) -&gt; CliCommands:\n    \"\"\"Merge two CliCommands instances.\n\n    Resolutions may be provided to resolve merge conflicts between two\n    subcommands.\n\n    Args:\n        base: The base CliCommands instance.\n        overrides: The overrides CliCommands instance.\n        resolutions: A dictionary of resolutions for subcommands.\n\n    Returns:\n        A new CliCommands instance.\n    \"\"\"\n    commands: dict[str, CommandModule | CliSubcommands] = {**base.commands}\n    for cmd_name, cmd_item in overrides.commands.items():\n        resolution = resolutions.get(cmd_name)\n        commands[cmd_name] = _get_new_command(cmd_name, commands, cmd_item, resolution)\n\n    return CliCommands(\n        meta=base.meta or overrides.meta,\n        commands=commands,\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.run_cli","title":"<code>run_cli(commands_module, add_args=None)</code>","text":"<p>Run the cli application.</p> <p>Deprecated, use <code>exec_cli</code> instead.</p> <p>usage::</p> <pre><code>def add_args(argp):\n    argp.add_argument(...)\ndef main():\n    run_cli('m.cli.commands', add_args)\n</code></pre> <p>We only need <code>add_args</code> if we need to gain access to the <code>argparse.ArgumentParser</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>commands_module</code> <code>str | None</code> <p>The full name of the module containing the commands.</p> required <code>add_args</code> <code>Callable[[ArgumentParser], None] | None</code> <p>Optional callback to gain access to the ArgumentParser.</p> <code>None</code> Source code in <code>m/cli/cli.py</code> <pre><code>@typing_extensions.deprecated(\n    '`run_cli` deprecated; use `exec_cli` instead.',\n)\ndef run_cli(\n    commands_module: str | None,\n    add_args: Callable[[argparse.ArgumentParser], None] | None = None,\n) -&gt; None:  # pragma: no cover\n    \"\"\"Run the cli application.\n\n    Deprecated, use `exec_cli` instead.\n\n    usage::\n\n        def add_args(argp):\n            argp.add_argument(...)\n        def main():\n            run_cli('m.cli.commands', add_args)\n\n    We only need `add_args` if we need to gain access to the\n    `argparse.ArgumentParser` instance.\n\n    Args:\n        commands_module: The full name of the module containing the commands.\n        add_args: Optional callback to gain access to the ArgumentParser.\n    \"\"\"\n    # NOTE: This is a deprecated feature and will be removed in the future.\n    if commands_module and '/' in commands_module:\n        warn(\n            '`run_cli(__file__)` is deprecated, use `run_cli(\"commands.module\") instead',\n            DeprecationWarning,\n        )\n        root = pth.split(pth.split(commands_module)[0])[1]\n        commands_module = f'{root}.cli.commands'\n    cli_commands: CliCommands = CliCommands(commands={}, meta=default_root_meta)\n    if commands_module:\n        cli_commands = import_cli_commands(commands_module)\n    if add_args:\n        warn('run_cli add_args is deprecated, use meta.add_arguments instead', DeprecationWarning)\n        if not cli_commands.meta:\n            cli_commands.meta = MetaModule(\n                meta=default_root_meta.meta,\n                add_arguments=add_args,\n            )\n        cli_commands.meta.add_arguments = add_args\n    exec_cli(cli_commands)\n</code></pre>"},{"location":"api/m/cli/#m.cli.run_main","title":"<code>run_main(callback, result_handler=default_result_handler, issue_handler=default_issue_handler)</code>","text":"<p>Run the callback and print the returned value.</p> <p>To change how the result or an issue should be display provide the optional arguments <code>handle_result</code> and <code>handle_issue</code>. For instance, to display the raw value provide the <code>print</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[], OneOf[Issue, Any]]</code> <p>A function that returns a <code>OneOf</code>.</p> required <code>result_handler</code> <code>Callable[[Any], None]</code> <p>A function that takes in the Good result.</p> <code>default_result_handler</code> <code>issue_handler</code> <code>Callable[[Issue], None]</code> <p>A function that takes in the Issue.</p> <code>default_issue_handler</code> <p>Returns:</p> Type Description <code>int</code> <p>0 if the callback is a <code>Good</code> result otherwise return 1.</p> Source code in <code>m/cli/cli.py</code> <pre><code>def run_main(\n    callback: Callable[[], OneOf[Issue, Any]],\n    result_handler: Callable[[Any], None] = default_result_handler,\n    issue_handler: Callable[[Issue], None] = default_issue_handler,\n) -&gt; int:\n    \"\"\"Run the callback and print the returned value.\n\n    To change how the result or an issue should be display provide the optional\n    arguments `handle_result` and `handle_issue`. For instance, to display the\n    raw value provide the `print` function.\n\n    Args:\n        callback: A function that returns a `OneOf`.\n        result_handler: A function that takes in the Good result.\n        issue_handler: A function that takes in the Issue.\n\n    Returns:\n        0 if the callback is a `Good` result otherwise return 1.\n    \"\"\"\n    res = None\n    try:\n        res = callback()\n    except Exception as ex:\n        issue_handler(Issue('unknown caught exception', cause=ex))\n        return 2\n    if isinstance(res, Bad):\n        problem = res.value\n        if isinstance(problem, Issue):\n            issue_handler(problem)\n        else:\n            issue_handler(Issue('non-issue exception', cause=problem))\n        return 1\n    result_handler(res.value)\n    return 0\n</code></pre>"},{"location":"api/m/cli/#m.cli.subcommands","title":"<code>subcommands(meta=None, **commands)</code>","text":"<p>Create a CliSubcommands instance.</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>MetaModule | None</code> <p>The meta for the command group.</p> <code>None</code> <code>commands</code> <code>DecoratedRunFunction</code> <p>The commands the group.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliSubcommands</code> <p>An instance of CliSubcommands.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def subcommands(\n    meta: MetaModule | None = None,\n    **commands: DecoratedRunFunction,\n) -&gt; CliSubcommands:\n    \"\"\"Create a CliSubcommands instance.\n\n    Args:\n        meta: The meta for the command group.\n        commands: The commands the group.\n\n    Returns:\n        An instance of CliSubcommands.\n    \"\"\"\n    return CliSubcommands(\n        meta=meta,\n        subcommands={\n            cmd_name: CommandModule(run=cmd_item)\n            for cmd_name, cmd_item in commands.items()\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/#m.cli.validate_json_payload","title":"<code>validate_json_payload(file_path)</code>","text":"<p>Return a dictionary from the contents of file_path.</p> <p>This is a string that tell us to read from a file, stdin or just plain json data.</p> <p>It can be used parse <code>yaml</code> files as well. The extension should be <code>.yaml</code> or <code>.yml</code>.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A string with the json payload. If it starts with <code>@</code> then the name of a valid json file from where the payload will be read.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the file_path is meant to be a valid path and it does not exist.</p> <p>Returns:</p> Type Description <code>Any</code> <p>A parsed json payload</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_json_payload(file_path: str) -&gt; Any:\n    \"\"\"Return a dictionary from the contents of file_path.\n\n    This is a string that tell us to read from a file, stdin or just\n    plain json data.\n\n    It can be used parse `yaml` files as well. The extension should be\n    `.yaml` or `.yml`.\n\n    Args:\n        file_path: A string with the json payload. If it starts with `@` then\n            the name of a valid json file from where the payload will be read.\n\n    Raises:\n        ArgumentTypeError: If the file_path is meant to be a valid path and it\n            does not exist.\n\n    Returns:\n        A parsed json payload\n    \"\"\"\n    if file_path == '@-':\n        res = read_json(None)\n        if res.is_bad:\n            msg = f'invalid json payload in SYS.STDIN\\n{res.value}'\n            raise ArgumentTypeError(msg)\n        return res.value\n    if file_path.startswith('@'):\n        err = ''\n        filename = file_path[1:]\n        if Path.exists(Path(filename)):\n            res = read_yson(filename)\n            if not res.is_bad:\n                return res.value\n            err = f'invalid json payload in {filename}\\n{res.value}'\n        else:\n            err = f'file \"{filename}\" does not exist'\n        if err:\n            raise ArgumentTypeError(err)\n    res = parse_json(file_path)\n    if res.is_bad:\n        raise ArgumentTypeError(f'invalid json payload\\n{res.value}')\n    return res.value\n</code></pre>"},{"location":"api/m/cli/#m.cli.validate_payload","title":"<code>validate_payload(file_path)</code>","text":"<p>Return the raw payload.</p> <p>This allows us to read from a file or the stdin stream.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A string with the payload. If it starts with <code>@</code> then the name of a valid file from where the payload will be read.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the file_path is meant to be a valid path and it does not exist.</p> <p>Returns:</p> Type Description <code>str</code> <p>The payload found in the file.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_payload(file_path: str) -&gt; str:\n    \"\"\"Return the raw payload.\n\n    This allows us to read from a file or the stdin stream.\n\n    Args:\n        file_path: A string with the payload. If it starts with `@` then the\n            name of a valid file from where the payload will be read.\n\n    Raises:\n        ArgumentTypeError: If the file_path is meant to be a valid path and it\n            does not exist.\n\n    Returns:\n        The payload found in the file.\n    \"\"\"\n    if file_path.startswith(r'\\@'):\n        # escape @ with \\ to let the cli know that the payload starts with @\n        return file_path[1:]\n    if file_path == '@-':\n        return sys.stdin.read()\n    if file_path.startswith('@'):\n        filename = file_path[1:]\n        path_handle = Path(filename)\n        if not Path.exists(path_handle):\n            raise ArgumentTypeError(f'file \"{filename}\" does not exist')\n        with Path.open(path_handle, encoding='UTF-8') as fp:\n            return fp.read()\n    return file_path\n</code></pre>"},{"location":"api/m/cli/args/","title":"args","text":""},{"location":"api/m/cli/args/#m.cli.args.Arg","title":"<code>Arg(default=PydanticUndefined, *, help, positional=None, required=None, aliases=None, nargs=None, validator=None)</code>","text":"<p>Create a pydantic <code>Field</code>.</p> <p>Field docs: https://docs.pydantic.dev/2.2/usage/fields</p> <p>Defines properties used to create an argparse argument. This function should work for most cases. If we need something that is not covered we can use <code>ArgProxy</code> instead which is untyped but provides all the arguments and keyword arguments to argparse.</p> <p>See https://docs.python.org/3/library/argparse.html.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any</code> <p>Default value if the field is not set.</p> <code>PydanticUndefined</code> <code>help</code> <code>str</code> <p>Human-readable description.</p> required <code>positional</code> <code>bool | None</code> <p>Whether the argument is positional or not.</p> <code>None</code> <code>required</code> <code>bool | None</code> <p>Indicate whether an argument is required or optional.</p> <code>None</code> <code>aliases</code> <code>list[str] | None</code> <p>Alternative names for the argument.</p> <code>None</code> <code>nargs</code> <code>int | Literal['?', '*', '+'] | None</code> <p>Number of times the argument can be used.</p> <code>None</code> <code>validator</code> <code>Callable[[str], str] | None</code> <p>Function to validate the argument.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>. The return annotation is <code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def Arg(  # noqa: N802, WPS211\n    default: Any = PydanticUndefined,\n    *,\n    help: str,  # noqa: WPS125\n    positional: bool | None = None,\n    required: bool | None = None,\n    aliases: list[str] | None = None,\n    nargs: int | Literal['?', '*', '+'] | None = None,\n    validator: Callable[[str], str] | None = None,\n) -&gt; Any:\n    \"\"\"Create a pydantic `Field`.\n\n    Field docs: https://docs.pydantic.dev/2.2/usage/fields\n\n    Defines properties used to create an argparse argument. This function\n    should work for most cases. If we need something that is not covered\n    we can use `ArgProxy` instead which is untyped but provides all the arguments\n    and keyword arguments to argparse.\n\n    See https://docs.python.org/3/library/argparse.html.\n\n    Args:\n        default: Default value if the field is not set.\n        help: Human-readable description.\n        positional: Whether the argument is positional or not.\n        required: Indicate whether an argument is required or optional.\n        aliases: Alternative names for the argument.\n        nargs: Number of times the argument can be used.\n        validator: Function to validate the argument.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is\n            `Any` so `Arg` can be used on type annotated fields without causing\n            a typing error.\n    \"\"\"\n    extras = {\n        'positional': positional,\n        'validator': validator,\n        'aliases': aliases,\n        'nargs': nargs,\n        'required': required,\n    }\n    return FieldInfo.from_field(\n        default,\n        description=cleandoc(help),\n        json_schema_extra={k: v for k, v in extras.items() if v is not None},\n    )\n</code></pre>"},{"location":"api/m/cli/args/#m.cli.args.ArgProxy","title":"<code>ArgProxy(*args, **kwargs)</code>","text":"<p>Wrap function to provide all argparse inputs.</p> <p>This is a escape hatch and does not provide any typings. See https://docs.python.org/3/library/argparse.html.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The arguments to argparse add_arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to argparse add arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>. The return annotation is <code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def ArgProxy(*args: Any, **kwargs: Any) -&gt; Any:  # noqa: N802\n    \"\"\"Wrap function to provide all argparse inputs.\n\n    This is a escape hatch and does not provide any typings.\n    See https://docs.python.org/3/library/argparse.html.\n\n    Args:\n        args: The arguments to argparse add_arguments.\n        kwargs: The keyword arguments to argparse add arguments.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is\n            `Any` so `Arg` can be used on type annotated fields without causing\n            a typing error.\n    \"\"\"\n    return FieldInfo.from_field(\n        json_schema_extra={\n            'proxy': FuncArgs(args=list(args), kwargs=kwargs),\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/args/#m.cli.args.Meta","title":"<code>Meta(*, help, description)</code>","text":"<p>Create the meta dictionary for a subcommand description.</p> <p>In the case of the root command the <code>help</code> may be set to empty since it is not used.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>The help message for the subcommand.</p> required <code>description</code> <code>str</code> <p>The description for the command/subcommand.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary with the help and description.</p> Source code in <code>m/cli/args.py</code> <pre><code>def Meta(  # noqa: N802\n    *,\n    help: str,  # noqa: WPS125\n    description: str,\n) -&gt; dict[str, str]:\n    \"\"\"Create the meta dictionary for a subcommand description.\n\n    In the case of the root command the `help` may be set to empty since it\n    is not used.\n\n    Args:\n        help: The help message for the subcommand.\n        description: The description for the command/subcommand.\n\n    Returns:\n        A dictionary with the help and description.\n    \"\"\"\n    return {\n        'help': help,\n        'description': cleandoc(description),\n    }\n</code></pre>"},{"location":"api/m/cli/args/#m.cli.args.RemainderArgs","title":"<code>RemainderArgs(*, help=_Unset)</code>","text":"<p>Provide a list of unrecognized arguments.</p> <p>This is a escape hatch and does not provide any typings. May be useful for commands that need to pass arguments to other commands.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str | None</code> <p>Human-readable description.</p> <code>_Unset</code> <p>Returns:</p> Type Description <code>Any</code> <p>A new <code>FieldInfo</code>, the return annotation is</p> <code>Any</code> <p><code>Any</code> so <code>Arg</code> can be used on type annotated fields without causing a typing error.</p> Source code in <code>m/cli/args.py</code> <pre><code>def RemainderArgs(  # noqa: N802\n    *,\n    help: str | None = _Unset,  # noqa: WPS125\n) -&gt; Any:\n    \"\"\"Provide a list of unrecognized arguments.\n\n    This is a escape hatch and does not provide any typings. May be\n    useful for commands that need to pass arguments to other commands.\n\n    Args:\n        help: Human-readable description.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo], the return annotation is\n        `Any` so `Arg` can be used on type annotated fields without causing a typing error.\n    \"\"\"\n    return FieldInfo.from_field(\n        [],\n        description=help,\n        json_schema_extra={'__remainder_args': True},\n    )\n</code></pre>"},{"location":"api/m/cli/cli/","title":"cli","text":""},{"location":"api/m/cli/cli/#m.cli.cli.cli_integration_token","title":"<code>cli_integration_token(integration, env_var)</code>","text":"<p>Return a function that takes in a parser.</p> <p>This generated function registers a token argument in the parser which looks for its value in the environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>integration</code> <code>str</code> <p>The name of the integration.</p> required <code>env_var</code> <code>str</code> <p>The environment variable name.</p> required <p>Returns:</p> Type Description <code>cli_global_option</code> <p>A function to add arguments to an argparse parser.</p> Source code in <code>m/cli/cli.py</code> <pre><code>def cli_integration_token(\n    integration: str,\n    env_var: str,\n) -&gt; cli_global_option:\n    \"\"\"Return a function that takes in a parser.\n\n    This generated function registers a token argument in the parser\n    which looks for its value in the environment variables.\n\n    Args:\n        integration: The name of the integration.\n        env_var: The environment variable name.\n\n    Returns:\n        A function to add arguments to an argparse parser.\n    \"\"\"\n    return lambda parser: parser.add_argument(\n        '-t',\n        '--token',\n        type=validate_non_empty_str,\n        default=env(env_var),\n        help=f'{integration} access token (default: env.{env_var})',\n    )\n</code></pre>"},{"location":"api/m/cli/cli/#m.cli.cli.exec_cli","title":"<code>exec_cli(cli_commands)</code>","text":"<p>Execute the cli application.</p> <p>usage::</p> <pre><code>def create_cli_commands() -&gt; CliCommands:\n    # We may import CliCommand objects from other projects and create\n    # a new one with them.\n    return import_cli_commands('cli.command.module')\n\ndef main():\n    cli_commands = create_cli_commands()\n    exec_cli(cli_commands)\n</code></pre> <p>This is the preferred way to execute the cli application as it will allow other potential applications to use the cli commands.</p> <p>Parameters:</p> Name Type Description Default <code>cli_commands</code> <code>CliCommands</code> <p>The cli commands to execute.</p> required Source code in <code>m/cli/cli.py</code> <pre><code>def exec_cli(cli_commands: CliCommands) -&gt; None:\n    \"\"\"Execute the cli application.\n\n    usage::\n\n        def create_cli_commands() -&gt; CliCommands:\n            # We may import CliCommand objects from other projects and create\n            # a new one with them.\n            return import_cli_commands('cli.command.module')\n\n        def main():\n            cli_commands = create_cli_commands()\n            exec_cli(cli_commands)\n\n    This is the preferred way to execute the cli application as it will allow\n    other potential applications to use the cli commands.\n\n    Args:\n        cli_commands: The cli commands to execute.\n    \"\"\"\n    arg = _main_parser(cli_commands)\n\n    run_func = None\n    command_name = ''\n\n    commands = cli_commands.commands\n    # WPS421 encourages to use try/except instead of hasattr but in this\n    # case we want explicitly before using it.\n    if hasattr(arg, 'subcommand_name'):  # noqa: WPS421\n        command_name = arg.subcommand_name\n        sub_mod = cast(CliSubcommands, commands[arg.command_name])\n        run_func = sub_mod.subcommands[command_name].run\n    else:\n        command_name = arg.command_name\n        run_func = cast(CommandModule, commands[command_name]).run\n\n    len_run_args = params_count(run_func)\n    run_args = [command_name, arg, None][:len_run_args]\n    exit_code = 0\n    try:\n        # mypy is having a hard time figuring out the type of run_args\n        exit_code = run_func(*run_args)  # type:ignore[arg-type]\n    except Exception as ex:\n        default_issue_handler(\n            Issue('unknown cli run function exception', cause=ex),\n        )\n        exit_code = 5\n    sys.exit(exit_code)\n</code></pre>"},{"location":"api/m/cli/cli/#m.cli.cli.run_cli","title":"<code>run_cli(commands_module, add_args=None)</code>","text":"<p>Run the cli application.</p> <p>Deprecated, use <code>exec_cli</code> instead.</p> <p>usage::</p> <pre><code>def add_args(argp):\n    argp.add_argument(...)\ndef main():\n    run_cli('m.cli.commands', add_args)\n</code></pre> <p>We only need <code>add_args</code> if we need to gain access to the <code>argparse.ArgumentParser</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>commands_module</code> <code>str | None</code> <p>The full name of the module containing the commands.</p> required <code>add_args</code> <code>Callable[[ArgumentParser], None] | None</code> <p>Optional callback to gain access to the ArgumentParser.</p> <code>None</code> Source code in <code>m/cli/cli.py</code> <pre><code>@typing_extensions.deprecated(\n    '`run_cli` deprecated; use `exec_cli` instead.',\n)\ndef run_cli(\n    commands_module: str | None,\n    add_args: Callable[[argparse.ArgumentParser], None] | None = None,\n) -&gt; None:  # pragma: no cover\n    \"\"\"Run the cli application.\n\n    Deprecated, use `exec_cli` instead.\n\n    usage::\n\n        def add_args(argp):\n            argp.add_argument(...)\n        def main():\n            run_cli('m.cli.commands', add_args)\n\n    We only need `add_args` if we need to gain access to the\n    `argparse.ArgumentParser` instance.\n\n    Args:\n        commands_module: The full name of the module containing the commands.\n        add_args: Optional callback to gain access to the ArgumentParser.\n    \"\"\"\n    # NOTE: This is a deprecated feature and will be removed in the future.\n    if commands_module and '/' in commands_module:\n        warn(\n            '`run_cli(__file__)` is deprecated, use `run_cli(\"commands.module\") instead',\n            DeprecationWarning,\n        )\n        root = pth.split(pth.split(commands_module)[0])[1]\n        commands_module = f'{root}.cli.commands'\n    cli_commands: CliCommands = CliCommands(commands={}, meta=default_root_meta)\n    if commands_module:\n        cli_commands = import_cli_commands(commands_module)\n    if add_args:\n        warn('run_cli add_args is deprecated, use meta.add_arguments instead', DeprecationWarning)\n        if not cli_commands.meta:\n            cli_commands.meta = MetaModule(\n                meta=default_root_meta.meta,\n                add_arguments=add_args,\n            )\n        cli_commands.meta.add_arguments = add_args\n    exec_cli(cli_commands)\n</code></pre>"},{"location":"api/m/cli/cli/#m.cli.cli.run_main","title":"<code>run_main(callback, result_handler=default_result_handler, issue_handler=default_issue_handler)</code>","text":"<p>Run the callback and print the returned value.</p> <p>To change how the result or an issue should be display provide the optional arguments <code>handle_result</code> and <code>handle_issue</code>. For instance, to display the raw value provide the <code>print</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[], OneOf[Issue, Any]]</code> <p>A function that returns a <code>OneOf</code>.</p> required <code>result_handler</code> <code>Callable[[Any], None]</code> <p>A function that takes in the Good result.</p> <code>default_result_handler</code> <code>issue_handler</code> <code>Callable[[Issue], None]</code> <p>A function that takes in the Issue.</p> <code>default_issue_handler</code> <p>Returns:</p> Type Description <code>int</code> <p>0 if the callback is a <code>Good</code> result otherwise return 1.</p> Source code in <code>m/cli/cli.py</code> <pre><code>def run_main(\n    callback: Callable[[], OneOf[Issue, Any]],\n    result_handler: Callable[[Any], None] = default_result_handler,\n    issue_handler: Callable[[Issue], None] = default_issue_handler,\n) -&gt; int:\n    \"\"\"Run the callback and print the returned value.\n\n    To change how the result or an issue should be display provide the optional\n    arguments `handle_result` and `handle_issue`. For instance, to display the\n    raw value provide the `print` function.\n\n    Args:\n        callback: A function that returns a `OneOf`.\n        result_handler: A function that takes in the Good result.\n        issue_handler: A function that takes in the Issue.\n\n    Returns:\n        0 if the callback is a `Good` result otherwise return 1.\n    \"\"\"\n    res = None\n    try:\n        res = callback()\n    except Exception as ex:\n        issue_handler(Issue('unknown caught exception', cause=ex))\n        return 2\n    if isinstance(res, Bad):\n        problem = res.value\n        if isinstance(problem, Issue):\n            issue_handler(problem)\n        else:\n            issue_handler(Issue('non-issue exception', cause=problem))\n        return 1\n    result_handler(res.value)\n    return 0\n</code></pre>"},{"location":"api/m/cli/handlers/","title":"handlers","text":""},{"location":"api/m/cli/handlers/#m.cli.handlers.create_dict_handler","title":"<code>create_dict_handler(pretty, as_yaml)</code>","text":"<p>Create a json or yaml handler.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>If true, t highlights the output.</p> required <code>as_yaml</code> <code>bool</code> <p>If true, it formats using yaml.</p> required <p>Returns:</p> Type Description <code>Callable[[Any], None]</code> <p>A function that uses the arguments</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_dict_handler(pretty: bool, as_yaml: bool) -&gt; Callable[[Any], None]:\n    \"\"\"Create a json or yaml handler.\n\n    Args:\n        pretty: If true, t highlights the output.\n        as_yaml: If true, it formats using yaml.\n\n    Returns:\n        A function that uses the arguments\n    \"\"\"\n    return (\n        create_yaml_handler(pretty)\n        if as_yaml\n        else create_json_handler(pretty)\n    )\n</code></pre>"},{"location":"api/m/cli/handlers/#m.cli.handlers.create_issue_handler","title":"<code>create_issue_handler(use_warning)</code>","text":"<p>Generate a function to log an issue.</p> <p>Parameters:</p> Name Type Description Default <code>use_warning</code> <code>bool</code> <p>Uses a warning log instead of an error.</p> required <p>Returns:</p> Type Description <code>Callable[[Issue], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_issue_handler(use_warning: bool) -&gt; Callable[[Issue], None]:\n    \"\"\"Generate a function to log an issue.\n\n    Args:\n        use_warning: Uses a warning log instead of an error.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_issue_handler, use_warning)\n</code></pre>"},{"location":"api/m/cli/handlers/#m.cli.handlers.create_json_handler","title":"<code>create_json_handler(pretty)</code>","text":"<p>Generate a function to display a value to stdout as json.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>If true, it formats with indentation of 2 spaces.</p> required <p>Returns:</p> Type Description <code>Callable[[Any], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_json_handler(pretty: bool) -&gt; Callable[[Any], None]:\n    \"\"\"Generate a function to display a value to stdout as json.\n\n    Args:\n        pretty: If true, it formats with indentation of 2 spaces.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_json_handler, pretty)\n</code></pre>"},{"location":"api/m/cli/handlers/#m.cli.handlers.create_yaml_handler","title":"<code>create_yaml_handler(pretty)</code>","text":"<p>Generate a function to display a value to stdout as yaml.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>If true, it highlights the output.</p> required <p>Returns:</p> Type Description <code>Callable[[Any], None]</code> <p>A function that uses the arguments provided.</p> Source code in <code>m/cli/handlers.py</code> <pre><code>def create_yaml_handler(pretty: bool) -&gt; Callable[[Any], None]:\n    \"\"\"Generate a function to display a value to stdout as yaml.\n\n    Args:\n        pretty: If true, it highlights the output.\n\n    Returns:\n        A function that uses the arguments provided.\n    \"\"\"\n    return partial(_yaml_handler, pretty)\n</code></pre>"},{"location":"api/m/cli/validators/","title":"validators","text":""},{"location":"api/m/cli/validators/#m.cli.validators.env_var","title":"<code>env_var(arg_value)</code>","text":"<p>Read a value from the environment.</p> <p>Parameters:</p> Name Type Description Default <code>arg_value</code> <code>str</code> <p>The input provided by argparse.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The environment variable value if it exists. Otherwise, the input.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def env_var(arg_value: str) -&gt; str:\n    \"\"\"Read a value from the environment.\n\n    Args:\n        arg_value: The input provided by argparse.\n\n    Returns:\n        The environment variable value if it exists. Otherwise, the input.\n    \"\"\"\n    return os.environ.get(arg_value, arg_value)\n</code></pre>"},{"location":"api/m/cli/validators/#m.cli.validators.env_var_or_empty","title":"<code>env_var_or_empty(arg_value)</code>","text":"<p>Read a value from the environment.</p> <p>Unlike the env_var validator, this will only allow the <code>arg_value</code> to pass through if is not in the form of an environment variable. That is, if the value is all uppercase letters and underscores it will attempt to read from the environment and return an empty string if not defined.</p> <p>Parameters:</p> Name Type Description Default <code>arg_value</code> <code>str</code> <p>The input provided by argparse.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The environment variable value if it exists. Otherwise, empty string.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def env_var_or_empty(arg_value: str) -&gt; str:\n    \"\"\"Read a value from the environment.\n\n    Unlike the [env_var][m.cli.validators.env_var] validator, this will only\n    allow the `arg_value` to pass through if is not in the form of an\n    environment variable. That is, if the value is all uppercase letters and\n    underscores it will attempt to read from the environment and return an empty\n    string if not defined.\n\n    Args:\n        arg_value: The input provided by argparse.\n\n    Returns:\n        The environment variable value if it exists. Otherwise, empty string.\n    \"\"\"\n    env_form = arg_value.upper().replace('-', '_', -1)\n    if arg_value == env_form:\n        return os.environ.get(arg_value, '')\n    return arg_value\n</code></pre>"},{"location":"api/m/cli/validators/#m.cli.validators.validate_json_payload","title":"<code>validate_json_payload(file_path)</code>","text":"<p>Return a dictionary from the contents of file_path.</p> <p>This is a string that tell us to read from a file, stdin or just plain json data.</p> <p>It can be used parse <code>yaml</code> files as well. The extension should be <code>.yaml</code> or <code>.yml</code>.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A string with the json payload. If it starts with <code>@</code> then the name of a valid json file from where the payload will be read.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the file_path is meant to be a valid path and it does not exist.</p> <p>Returns:</p> Type Description <code>Any</code> <p>A parsed json payload</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_json_payload(file_path: str) -&gt; Any:\n    \"\"\"Return a dictionary from the contents of file_path.\n\n    This is a string that tell us to read from a file, stdin or just\n    plain json data.\n\n    It can be used parse `yaml` files as well. The extension should be\n    `.yaml` or `.yml`.\n\n    Args:\n        file_path: A string with the json payload. If it starts with `@` then\n            the name of a valid json file from where the payload will be read.\n\n    Raises:\n        ArgumentTypeError: If the file_path is meant to be a valid path and it\n            does not exist.\n\n    Returns:\n        A parsed json payload\n    \"\"\"\n    if file_path == '@-':\n        res = read_json(None)\n        if res.is_bad:\n            msg = f'invalid json payload in SYS.STDIN\\n{res.value}'\n            raise ArgumentTypeError(msg)\n        return res.value\n    if file_path.startswith('@'):\n        err = ''\n        filename = file_path[1:]\n        if Path.exists(Path(filename)):\n            res = read_yson(filename)\n            if not res.is_bad:\n                return res.value\n            err = f'invalid json payload in {filename}\\n{res.value}'\n        else:\n            err = f'file \"{filename}\" does not exist'\n        if err:\n            raise ArgumentTypeError(err)\n    res = parse_json(file_path)\n    if res.is_bad:\n        raise ArgumentTypeError(f'invalid json payload\\n{res.value}')\n    return res.value\n</code></pre>"},{"location":"api/m/cli/validators/#m.cli.validators.validate_non_empty_str","title":"<code>validate_non_empty_str(arg_value)</code>","text":"<p>Return the value as long as its not empty.</p> <p>Parameters:</p> Name Type Description Default <code>arg_value</code> <code>str</code> <p>The input provided by argparse.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the input is not provided.</p> <p>Returns:</p> Type Description <code>str</code> <p>The value if non empty.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_non_empty_str(arg_value: str) -&gt; str:\n    \"\"\"Return the value as long as its not empty.\n\n    Args:\n        arg_value: The input provided by argparse.\n\n    Raises:\n        ArgumentTypeError: If the input is not provided.\n\n    Returns:\n        The value if non empty.\n    \"\"\"\n    if not arg_value:\n        raise ArgumentTypeError('empty value not allowed')\n    return arg_value\n</code></pre>"},{"location":"api/m/cli/validators/#m.cli.validators.validate_payload","title":"<code>validate_payload(file_path)</code>","text":"<p>Return the raw payload.</p> <p>This allows us to read from a file or the stdin stream.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A string with the payload. If it starts with <code>@</code> then the name of a valid file from where the payload will be read.</p> required <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>If the file_path is meant to be a valid path and it does not exist.</p> <p>Returns:</p> Type Description <code>str</code> <p>The payload found in the file.</p> Source code in <code>m/cli/validators.py</code> <pre><code>def validate_payload(file_path: str) -&gt; str:\n    \"\"\"Return the raw payload.\n\n    This allows us to read from a file or the stdin stream.\n\n    Args:\n        file_path: A string with the payload. If it starts with `@` then the\n            name of a valid file from where the payload will be read.\n\n    Raises:\n        ArgumentTypeError: If the file_path is meant to be a valid path and it\n            does not exist.\n\n    Returns:\n        The payload found in the file.\n    \"\"\"\n    if file_path.startswith(r'\\@'):\n        # escape @ with \\ to let the cli know that the payload starts with @\n        return file_path[1:]\n    if file_path == '@-':\n        return sys.stdin.read()\n    if file_path.startswith('@'):\n        filename = file_path[1:]\n        path_handle = Path(filename)\n        if not Path.exists(path_handle):\n            raise ArgumentTypeError(f'file \"{filename}\" does not exist')\n        with Path.open(path_handle, encoding='UTF-8') as fp:\n            return fp.read()\n    return file_path\n</code></pre>"},{"location":"api/m/cli/engine/","title":"engine","text":""},{"location":"api/m/cli/engine/argparse/","title":"argparse","text":""},{"location":"api/m/cli/engine/argparse/#m.cli.engine.argparse.add_model","title":"<code>add_model(parser, model)</code>","text":"<p>Add a pydantic model to an argparse ArgumentParser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The ArgumentParser instance.</p> required <code>model</code> <code>type[BaseModel]</code> <p>The pydantic model declaring the cli options.</p> required Source code in <code>m/cli/engine/argparse.py</code> <pre><code>def add_model(\n    parser: argparse.ArgumentParser,\n    model: type[BaseModel],\n) -&gt; None:\n    \"\"\"Add a pydantic model to an argparse ArgumentParser.\n\n    Args:\n        parser: The ArgumentParser instance.\n        model: The pydantic model declaring the cli options.\n    \"\"\"\n    parser.description = cleandoc(model.__doc__ or '')\n    parser.formatter_class = argparse.RawTextHelpFormatter\n    for name, field in model.model_fields.items():\n        arg_inputs = _parse_field(name, field)\n        parser.add_argument(*arg_inputs.args, **arg_inputs.kwargs)\n</code></pre>"},{"location":"api/m/cli/engine/argparse/#m.cli.engine.argparse.command","title":"<code>command(*, help, model, name=None)</code>","text":"<p>Apply a decorator to the <code>run</code> function to make it into a command.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The command name.</p> <code>None</code> <code>help</code> <code>str</code> <p>A short description of the command.</p> required <code>model</code> <code>type[BaseModel]</code> <p>A pydantic model to describe the cli arguments.</p> required <p>Returns:</p> Type Description <code>partial[partial[int]]</code> <p>A transformed run function aware of the arguments model.</p> Source code in <code>m/cli/engine/argparse.py</code> <pre><code>def command(\n    *,\n    help: str,  # noqa: WPS125\n    model: type[BaseModel],\n    name: str | None = None,\n) -&gt; partial[partial[int]]:\n    \"\"\"Apply a decorator to the `run` function to make it into a command.\n\n    Args:\n        name: The command name.\n        help: A short description of the command.\n        model: A pydantic model to describe the cli arguments.\n\n    Returns:\n        A transformed run function aware of the arguments model.\n    \"\"\"\n    # m no longer uses the name argument but we keep it for now\n    if name:  # pragma: no cover\n        warn('`name` is no longer needed, please remove it', DeprecationWarning)\n    return partial(_handle_decorated_func, CommandInputs(help, model))\n</code></pre>"},{"location":"api/m/cli/engine/misc/","title":"misc","text":""},{"location":"api/m/cli/engine/misc/#m.cli.engine.misc.argument_description","title":"<code>argument_description(description, default=MISSING)</code>","text":"<p>Append default value to argument description.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>argument description.</p> required <code>default</code> <code>Any | None</code> <p>Argument's default value.</p> <code>MISSING</code> <p>Returns:</p> Type Description <code>str</code> <p>The description of the argument.</p> Source code in <code>m/cli/engine/misc.py</code> <pre><code>def argument_description(\n    description: str,\n    default: Any | None = MISSING,\n) -&gt; str:\n    \"\"\"Append default value to argument description.\n\n    Args:\n        description: argument description.\n        default: Argument's default value.\n\n    Returns:\n        The description of the argument.\n    \"\"\"\n    default = f'(default: {default})' if default is not MISSING else ''\n    return f'{description} {default}'.strip()\n</code></pre>"},{"location":"api/m/cli/engine/misc/#m.cli.engine.misc.argument_name","title":"<code>argument_name(name)</code>","text":"<p>Normalize an argument name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the argument.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normalized name of the argument.</p> Source code in <code>m/cli/engine/misc.py</code> <pre><code>def argument_name(name: str) -&gt; str:\n    \"\"\"Normalize an argument name.\n\n    Args:\n        name: Name of the argument.\n\n    Returns:\n        Normalized name of the argument.\n    \"\"\"\n    cli_arg_name = name.replace('_', '-')\n    dashes = '-' if len(cli_arg_name) == 1 else '--'\n    return f'{dashes}{cli_arg_name}'\n</code></pre>"},{"location":"api/m/cli/engine/misc/#m.cli.engine.misc.params_count","title":"<code>params_count(func)</code>","text":"<p>Compute the number of parameters in a function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function in question.</p> required <p>Returns:</p> Type Description <code>int</code> <p>the number of parameters.</p> Source code in <code>m/cli/engine/misc.py</code> <pre><code>def params_count(func: Callable) -&gt; int:\n    \"\"\"Compute the number of parameters in a function.\n\n    Args:\n        func: The function in question.\n\n    Returns:\n        the number of parameters.\n    \"\"\"\n    sig = signature(func)\n    return len(sig.parameters)\n</code></pre>"},{"location":"api/m/cli/engine/sys/","title":"sys","text":""},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.cli_commands","title":"<code>cli_commands(root_meta=None, **commands)</code>","text":"<p>Create a CliCommands instance.</p> <p>Parameters:</p> Name Type Description Default <code>root_meta</code> <code>MetaModule | None</code> <p>The meta for the root command.</p> <code>None</code> <code>commands</code> <code>DecoratedRunFunction | CliSubcommands</code> <p>The commands and subcommands for the cli.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliCommands</code> <p>An instance of CliCommands.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def cli_commands(\n    root_meta: MetaModule | None = None,\n    **commands: DecoratedRunFunction | CliSubcommands,\n) -&gt; CliCommands:\n    \"\"\"Create a CliCommands instance.\n\n    Args:\n        root_meta: The meta for the root command.\n        commands: The commands and subcommands for the cli.\n\n    Returns:\n        An instance of CliCommands.\n    \"\"\"\n    root_meta = root_meta or default_root_meta\n    return CliCommands(\n        meta=root_meta,\n        commands={\n            cmd_name: (\n                cmd_item\n                if isinstance(cmd_item, CliSubcommands)\n                else CommandModule(run=cmd_item)\n            )\n            for cmd_name, cmd_item in commands.items()\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.command_group","title":"<code>command_group(*, help, description, add_arguments=None)</code>","text":"<p>Create an instance of a MetaModule.</p> <p>Named <code>cmd_group</code> since it is used to describe the group of commands.</p> <p>Parameters:</p> Name Type Description Default <code>help</code> <code>str</code> <p>quick help describing the module.</p> required <code>description</code> <code>str</code> <p>Detailed description about the module.</p> required <code>add_arguments</code> <code>Callable[[ArgumentParser], None] | None</code> <p>Optional function to handle the argparse instance.</p> <code>None</code> <p>Returns:</p> Type Description <code>MetaModule</code> <p>An instance of a MetaModule.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def command_group(\n    *,\n    help: str,   # noqa: WPS125\n    description: str,\n    add_arguments: Callable[[ap.ArgumentParser], None] | None = None,\n) -&gt; MetaModule:\n    \"\"\"Create an instance of a MetaModule.\n\n    Named `cmd_group` since it is used to describe the group of commands.\n\n    Args:\n        help: quick help describing the module.\n        description: Detailed description about the module.\n        add_arguments: Optional function to handle the argparse instance.\n\n    Returns:\n        An instance of a MetaModule.\n    \"\"\"\n    return MetaModule(\n        meta=Meta(help=help, description=description),\n        add_arguments=add_arguments,\n    )\n</code></pre>"},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.get_command_modules","title":"<code>get_command_modules(commands_module)</code>","text":"<p>Create a dictionary of a file name to its module.</p> <p>These modules should define a <code>run</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>commands_module</code> <code>str</code> <p>The full module resolution. For instance <code>m.cli.commands</code>.</p> required <p>Returns:</p> Type Description <code>dict[str, CommandModule]</code> <p>A dictionary of command modules.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def get_command_modules(commands_module: str) -&gt; dict[str, CommandModule]:\n    \"\"\"Create a dictionary of a file name to its module.\n\n    These modules should define a `run` function.\n\n    Args:\n        commands_module: The full module resolution. For instance\n            `m.cli.commands`.\n\n    Returns:\n        A dictionary of command modules.\n    \"\"\"\n    cmd_module = import_module(commands_module)\n    dir_name = pth.split(cmd_module.__file__ or '')[0]\n    mod_names = list(iglob(f'{dir_name}/*.py'))\n    mod = {}\n    for mod_name in mod_names:\n        name = pth.split(mod_name)[1][:-3]\n        cmd_mod = _get_command_module(f'{commands_module}.{name}')\n        if cmd_mod:\n            mod[name] = cmd_mod\n    return mod\n</code></pre>"},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.import_cli_commands","title":"<code>import_cli_commands(commands_module)</code>","text":"<p>Gather the commands and subcommands for the cli.</p> <p>Parameters:</p> Name Type Description Default <code>commands_module</code> <code>str</code> <p>module containing all the commands.</p> required <p>Returns:</p> Type Description <code>CliCommands</code> <p>An instance of CliCommands gathered from the commands_module.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def import_cli_commands(commands_module: str) -&gt; CliCommands:\n    \"\"\"Gather the commands and subcommands for the cli.\n\n    Args:\n        commands_module: module containing all the commands.\n\n    Returns:\n        An instance of CliCommands gathered from the commands_module.\n    \"\"\"\n    cmd_module = import_module(commands_module)\n    if hasattr(cmd_module, 'create_cli_commands'):\n        # No extra checks for now, if a module has this we assume that\n        # it has the right signature.\n        return cast(CliCommands, cmd_module.create_cli_commands())\n\n    commands: dict[str, CommandModule | CliSubcommands] = {}\n    root_cmd = get_command_modules(commands_module)\n\n    for key, cmd_mod in root_cmd.items():\n        commands[key] = cmd_mod\n\n    root = pth.split(cmd_module.__file__ or '')[0]\n    for cmd_name in iglob(f'{root}/*'):\n        if cmd_name.endswith('.py') or cmd_name.endswith('__'):\n            continue\n        name = pth.split(cmd_name)[1]\n        commands[name] = CliSubcommands(\n            meta=_get_meta_module(f'{commands_module}.{name}', default_meta),\n            subcommands=get_command_modules(f'{commands_module}.{name}'),\n        )\n\n    return CliCommands(\n        meta=_get_meta_module(commands_module, default_root_meta),\n        commands=commands,\n    )\n</code></pre>"},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.merge_cli_commands","title":"<code>merge_cli_commands(base, overrides, **resolutions)</code>","text":"<p>Merge two CliCommands instances.</p> <p>Resolutions may be provided to resolve merge conflicts between two subcommands.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>CliCommands</code> <p>The base CliCommands instance.</p> required <code>overrides</code> <code>CliCommands</code> <p>The overrides CliCommands instance.</p> required <code>resolutions</code> <code>SubCmdResolution</code> <p>A dictionary of resolutions for subcommands.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliCommands</code> <p>A new CliCommands instance.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def merge_cli_commands(\n    base: CliCommands,\n    overrides: CliCommands,\n    **resolutions: SubCmdResolution,\n) -&gt; CliCommands:\n    \"\"\"Merge two CliCommands instances.\n\n    Resolutions may be provided to resolve merge conflicts between two\n    subcommands.\n\n    Args:\n        base: The base CliCommands instance.\n        overrides: The overrides CliCommands instance.\n        resolutions: A dictionary of resolutions for subcommands.\n\n    Returns:\n        A new CliCommands instance.\n    \"\"\"\n    commands: dict[str, CommandModule | CliSubcommands] = {**base.commands}\n    for cmd_name, cmd_item in overrides.commands.items():\n        resolution = resolutions.get(cmd_name)\n        commands[cmd_name] = _get_new_command(cmd_name, commands, cmd_item, resolution)\n\n    return CliCommands(\n        meta=base.meta or overrides.meta,\n        commands=commands,\n    )\n</code></pre>"},{"location":"api/m/cli/engine/sys/#m.cli.engine.sys.subcommands","title":"<code>subcommands(meta=None, **commands)</code>","text":"<p>Create a CliSubcommands instance.</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>MetaModule | None</code> <p>The meta for the command group.</p> <code>None</code> <code>commands</code> <code>DecoratedRunFunction</code> <p>The commands the group.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CliSubcommands</code> <p>An instance of CliSubcommands.</p> Source code in <code>m/cli/engine/sys.py</code> <pre><code>def subcommands(\n    meta: MetaModule | None = None,\n    **commands: DecoratedRunFunction,\n) -&gt; CliSubcommands:\n    \"\"\"Create a CliSubcommands instance.\n\n    Args:\n        meta: The meta for the command group.\n        commands: The commands the group.\n\n    Returns:\n        An instance of CliSubcommands.\n    \"\"\"\n    return CliSubcommands(\n        meta=meta,\n        subcommands={\n            cmd_name: CommandModule(run=cmd_item)\n            for cmd_name, cmd_item in commands.items()\n        },\n    )\n</code></pre>"},{"location":"api/m/cli/engine/types/","title":"types","text":""},{"location":"api/m/cli/engine/types/#m.cli.engine.types.CliCommands","title":"<code>CliCommands</code>  <code>dataclass</code>","text":"<p>Container to store the commands and subcommands for the cli.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CliCommands:\n    \"\"\"Container to store the commands and subcommands for the cli.\"\"\"\n\n    commands: dict[str, CommandModule | CliSubcommands]\n\n    # Optional root meta data to provide information about the cli.\n    meta: MetaModule | None\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.CliSubcommands","title":"<code>CliSubcommands</code>  <code>dataclass</code>","text":"<p>Container to store subcommands.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CliSubcommands:\n    \"\"\"Container to store subcommands.\"\"\"\n\n    # Dictionary of subcommands.\n    subcommands: CommandModuleMap\n\n    # Each subcommand needs to provide metadata to create the help message.\n    meta: MetaModule | None\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.CommandInputs","title":"<code>CommandInputs</code>  <code>dataclass</code>","text":"<p>Inputs to command decorator.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CommandInputs:\n    \"\"\"Inputs to command decorator.\"\"\"\n\n    help: str\n\n    model: type[BaseModel]\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.CommandModule","title":"<code>CommandModule</code>  <code>dataclass</code>","text":"<p>Container to store the run function from a \"command\" module.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass CommandModule:\n    \"\"\"Container to store the run function from a \"command\" module.\"\"\"\n\n    run: DecoratedRunFunction\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.FuncArgs","title":"<code>FuncArgs</code>  <code>dataclass</code>","text":"<p>Stores function arguments.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass FuncArgs:\n    \"\"\"Stores function arguments.\"\"\"\n\n    args: list[Any]\n    kwargs: dict[str, Any]\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.MetaModule","title":"<code>MetaModule</code>  <code>dataclass</code>","text":"<p>Container to store a metadata dictionary from a \"meta\" module.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@dataclass\nclass MetaModule:\n    \"\"\"Container to store a metadata dictionary from a \"meta\" module.\"\"\"\n\n    meta: dict[str, str]\n    add_arguments: Callable[[ap.ArgumentParser], None] | None = None\n</code></pre>"},{"location":"api/m/cli/engine/types/#m.cli.engine.types.add_arg","title":"<code>add_arg(*args, **kwargs)</code>","text":"<p>Wrap FuncArgs arguments in a function.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The arguments to argparse add_arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to argparse add arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FuncArgs</code> <p>A FuncArgs instance.</p> Source code in <code>m/cli/engine/types.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `add_arg` method is deprecated; use `m.cli.ArgProxy` instead.',\n)\ndef add_arg(*args: Any, **kwargs: Any) -&gt; FuncArgs:\n    \"\"\"Wrap FuncArgs arguments in a function.\n\n    Args:\n        args: The arguments to argparse add_arguments.\n        kwargs: The keyword arguments to argparse add arguments.\n\n    Returns:\n        A FuncArgs instance.\n    \"\"\"\n    # `m` does not reference this function anymore, excluding from coverage\n    return FuncArgs(args=list(args), kwargs=kwargs)  # pragma: no cover\n</code></pre>"},{"location":"api/m/cli/engine/parsers/","title":"parsers","text":""},{"location":"api/m/cli/engine/parsers/boolean/","title":"boolean","text":""},{"location":"api/m/cli/engine/parsers/boolean/#m.cli.engine.parsers.boolean.handle_field","title":"<code>handle_field(name, field)</code>","text":"<p>Treat the field as a boolean field.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument.</p> required <code>field</code> <code>FieldInfo</code> <p>A dictionary representation of the field.</p> required <p>Returns:</p> Type Description <code>FuncArgs</code> <p>Function arguments for the parser <code>add_argument</code> method.</p> Source code in <code>m/cli/engine/parsers/boolean.py</code> <pre><code>def handle_field(name: str, field: FieldInfo) -&gt; FuncArgs:\n    \"\"\"Treat the field as a boolean field.\n\n    Args:\n        name: The name of the argument.\n        field: A dictionary representation of the field.\n\n    Returns:\n        Function arguments for the parser `add_argument` method.\n    \"\"\"\n    default = field.default\n    extras = cast(dict, field.json_schema_extra or {})\n    aliases = cast(list[str], extras.get('aliases', None))\n    args: AnyMap = {\n        'help': argument_description(field.description or '', MISSING),\n        'required': extras.get('required', False),\n    }\n\n    if default:\n        args['action'] = 'store_false'\n        args['dest'] = name\n        names = [argument_name(f'no-{name}')]\n        if aliases:\n            names = [argument_name(f'no-{alias}') for alias in aliases]\n    else:\n        args['action'] = 'store_true'\n        names = [argument_name(name)]\n        if aliases:\n            names = [argument_name(alias) for alias in aliases]\n\n    return FuncArgs(args=names, kwargs=args)\n</code></pre>"},{"location":"api/m/cli/engine/parsers/positional/","title":"positional","text":""},{"location":"api/m/cli/engine/parsers/positional/#m.cli.engine.parsers.positional.handle_field","title":"<code>handle_field(name, field)</code>","text":"<p>Treat the field as a positional field.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument.</p> required <code>field</code> <code>FieldInfo</code> <p>A dictionary representation of the field.</p> required <p>Returns:</p> Type Description <code>FuncArgs</code> <p>Function arguments for the parser <code>add_argument</code> method.</p> Source code in <code>m/cli/engine/parsers/positional.py</code> <pre><code>def handle_field(name: str, field: FieldInfo) -&gt; FuncArgs:\n    \"\"\"Treat the field as a positional field.\n\n    Args:\n        name: The name of the argument.\n        field: A dictionary representation of the field.\n\n    Returns:\n        Function arguments for the parser `add_argument` method.\n    \"\"\"\n    extras = cast(dict, field.json_schema_extra)\n    default = field.default\n    validator = extras.get('validator', None)\n    is_required = extras.get('required', False)\n    nargs = extras.get('nargs', None)\n    arg_default = default if default is MISSING else repr(default)\n    args: AnyMap = {\n        'help': argument_description(field.description or '', arg_default),\n    }\n    if default is not MISSING:\n        args['default'] = default\n\n    if validator:\n        args['type'] = validator\n\n    if nargs:\n        args['nargs'] = nargs\n    elif not is_required:\n        args['nargs'] = '?'\n\n    return FuncArgs(args=[name], kwargs=args)\n</code></pre>"},{"location":"api/m/cli/engine/parsers/positional/#m.cli.engine.parsers.positional.should_handle","title":"<code>should_handle(extras)</code>","text":"<p>Handle a positional field.</p> <p>Parameters:</p> Name Type Description Default <code>extras</code> <code>AnyMap</code> <p>A dictionary with information for a cli argument.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it should handle the field as positional</p> Source code in <code>m/cli/engine/parsers/positional.py</code> <pre><code>def should_handle(extras: AnyMap) -&gt; bool:\n    \"\"\"Handle a positional field.\n\n    Args:\n        extras: A dictionary with information for a cli argument.\n\n    Returns:\n        True if it should handle the field as positional\n    \"\"\"\n    return extras.get('positional', False) is True\n</code></pre>"},{"location":"api/m/cli/engine/parsers/proxy/","title":"proxy","text":""},{"location":"api/m/cli/engine/parsers/proxy/#m.cli.engine.parsers.proxy.handle_field","title":"<code>handle_field(extras)</code>","text":"<p>Pass the <code>proxy</code> property in the field as is.</p> <p>Parameters:</p> Name Type Description Default <code>extras</code> <code>AnyMap</code> <p>A dictionary representation of the field.</p> required <p>Returns:</p> Type Description <code>FuncArgs</code> <p>Function arguments for the parser <code>add_argument</code> method.</p> Source code in <code>m/cli/engine/parsers/proxy.py</code> <pre><code>def handle_field(extras: AnyMap) -&gt; FuncArgs:\n    \"\"\"Pass the `proxy` property in the field as is.\n\n    Args:\n        extras: A dictionary representation of the field.\n\n    Returns:\n        Function arguments for the parser `add_argument` method.\n    \"\"\"\n    # proxy field is expected to be a FuncArgs instance.\n    return cast(FuncArgs, extras['proxy'])\n</code></pre>"},{"location":"api/m/cli/engine/parsers/proxy/#m.cli.engine.parsers.proxy.should_handle","title":"<code>should_handle(extras)</code>","text":"<p>Handle the proxy field.</p> <p>Parameters:</p> Name Type Description Default <code>extras</code> <code>AnyMap</code> <p>A dictionary with information for a cli argument.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it should handle the field as a proxy to the parser.</p> Source code in <code>m/cli/engine/parsers/proxy.py</code> <pre><code>def should_handle(extras: AnyMap) -&gt; bool:\n    \"\"\"Handle the proxy field.\n\n    Args:\n        extras: A dictionary with information for a cli argument.\n\n    Returns:\n        True if it should handle the field as a proxy to the parser.\n    \"\"\"\n    return extras.get('proxy', None) is not None\n</code></pre>"},{"location":"api/m/cli/engine/parsers/remainder/","title":"remainder","text":""},{"location":"api/m/cli/engine/parsers/remainder/#m.cli.engine.parsers.remainder.handle_field","title":"<code>handle_field(name, field)</code>","text":"<p>Set the remainder arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the field.</p> required <code>field</code> <code>FieldInfo</code> <p>A dictionary representation of the field.</p> required <p>Returns:</p> Type Description <code>FuncArgs</code> <p>Function arguments for the parser <code>add_argument</code> method.</p> Source code in <code>m/cli/engine/parsers/remainder.py</code> <pre><code>def handle_field(name: str, field: FieldInfo) -&gt; FuncArgs:\n    \"\"\"Set the remainder arguments.\n\n    Args:\n        name: The name of the field.\n        field: A dictionary representation of the field.\n\n    Returns:\n        Function arguments for the parser `add_argument` method.\n    \"\"\"\n    args: AnyMap = {\n        'help': argument_description(field.description or '', MISSING),\n        'nargs': argparse.REMAINDER,\n    }\n    return FuncArgs(args=[name], kwargs=args)\n</code></pre>"},{"location":"api/m/cli/engine/parsers/remainder/#m.cli.engine.parsers.remainder.should_handle","title":"<code>should_handle(extras)</code>","text":"<p>Handle the __remainder_args field.</p> <p>Parameters:</p> Name Type Description Default <code>extras</code> <code>AnyMap</code> <p>A dictionary with information for a cli argument.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it should provide the remainder arguments.</p> Source code in <code>m/cli/engine/parsers/remainder.py</code> <pre><code>def should_handle(extras: AnyMap) -&gt; bool:\n    \"\"\"Handle the __remainder_args field.\n\n    Args:\n        extras: A dictionary with information for a cli argument.\n\n    Returns:\n        True if it should provide the remainder arguments.\n    \"\"\"\n    return extras.get('__remainder_args') is True\n</code></pre>"},{"location":"api/m/cli/engine/parsers/standard/","title":"standard","text":""},{"location":"api/m/cli/engine/parsers/standard/#m.cli.engine.parsers.standard.handle_field","title":"<code>handle_field(name, field)</code>","text":"<p>Handle a standard field as an argument.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument.</p> required <code>field</code> <code>FieldInfo</code> <p>A dictionary representation of the field.</p> required <p>Returns:</p> Type Description <code>FuncArgs</code> <p>Function arguments for the parser <code>add_argument</code> method.</p> Source code in <code>m/cli/engine/parsers/standard.py</code> <pre><code>def handle_field(name: str, field: FieldInfo) -&gt; FuncArgs:\n    \"\"\"Handle a standard field as an argument.\n\n    Args:\n        name: The name of the argument.\n        field: A dictionary representation of the field.\n\n    Returns:\n        Function arguments for the parser `add_argument` method.\n    \"\"\"\n    extras = cast(dict, field.json_schema_extra or {})\n    default = field.default\n    validator = extras.get('validator', None)\n    required = extras.get('required', False)\n    aliases = cast(list[str], extras.get('aliases', None))\n\n    arg_default = default if default is MISSING else repr(default)\n    if 'env_var' in repr(validator):\n        # special case - do not repr\n        arg_default = f'env.{default}'\n    args: AnyMap = {\n        'help': argument_description(field.description or '', arg_default),\n        'required': required,\n        'type': str,\n    }\n\n    if default is not MISSING:\n        args['default'] = default\n\n    if validator:\n        args['type'] = validator\n\n    names = [argument_name(name)]\n    if aliases:\n        names = [argument_name(alias) for alias in aliases]\n\n    return FuncArgs(args=names, kwargs=args)\n</code></pre>"},{"location":"api/m/color/","title":"color","text":""},{"location":"api/m/color/#m.color.color","title":"<code>color(*args, auto_end=True)</code>","text":"<p>Color a message.</p> <p>Format the arguments by replacing the colors in the Colors class. For instance::</p> <pre><code>color('{blue}Hello there{end}\\n{yellow}WARNING')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>str</code> <p>Strings to color</p> <code>()</code> <code>auto_end</code> <code>bool</code> <p>Add a string to end coloring</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>A formatted message.</p> Source code in <code>m/color/colors.py</code> <pre><code>def color(*args: str, auto_end: bool = True) -&gt; str:\n    r\"\"\"Color a message.\n\n    Format the arguments by replacing the colors in the Colors class.\n    For instance::\n\n        color('{blue}Hello there{end}\\n{yellow}WARNING')\n\n    Args:\n        args: Strings to color\n        auto_end: Add a string to end coloring\n\n    Returns:\n        A formatted message.\n    \"\"\"\n    no_color = color_disabled()\n    color_map = no_color_dict if no_color else color_dict\n    end = '' if no_color or not auto_end else Color.end\n    msg_list = [msg.format(**color_map) for msg in args]\n    return ''.join(msg_list) + end\n</code></pre>"},{"location":"api/m/color/#m.color.color_disabled","title":"<code>color_disabled()</code>","text":"<p>Check for environment variable NO_COLOR.</p> <p>Utilities that format strings with color should call this function to determine if the user wants color in the final output.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if it exists and its set to true or 1.</p> Source code in <code>m/color/disable.py</code> <pre><code>def color_disabled() -&gt; bool:\n    \"\"\"Check for environment variable NO_COLOR.\n\n    Utilities that format strings with color should call this function\n    to determine if the user wants color in the final output.\n\n    Returns:\n        True if it exists and its set to true or 1.\n    \"\"\"\n    return os.environ.get('NO_COLOR', 'false') in {'true', '1', 'True'}\n</code></pre>"},{"location":"api/m/color/#m.color.highlight_json","title":"<code>highlight_json(text)</code>","text":"<p>Highlight a json string.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The json string to highlight.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A colorized json string.</p> Source code in <code>m/color/pygment.py</code> <pre><code>def highlight_json(text: str) -&gt; str:\n    \"\"\"Highlight a json string.\n\n    Args:\n        text: The json string to highlight.\n\n    Returns:\n        A colorized json string.\n    \"\"\"\n    return _highlight(text, JsonLexer())\n</code></pre>"},{"location":"api/m/color/#m.color.highlight_yaml","title":"<code>highlight_yaml(text)</code>","text":"<p>Highlight a yaml string.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The yaml string to highlight.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A colorized yaml string.</p> Source code in <code>m/color/pygment.py</code> <pre><code>def highlight_yaml(text: str) -&gt; str:\n    \"\"\"Highlight a yaml string.\n\n    Args:\n        text: The yaml string to highlight.\n\n    Returns:\n        A colorized yaml string.\n    \"\"\"\n    return _highlight(text, YamlLexer())\n</code></pre>"},{"location":"api/m/color/colors/","title":"colors","text":""},{"location":"api/m/color/colors/#m.color.colors.Color","title":"<code>Color</code>","text":"<p>A class for terminal color codes.</p> Source code in <code>m/color/colors.py</code> <pre><code>class Color:\n    \"\"\"A class for terminal color codes.\"\"\"\n\n    bold = '\\033[1m'\n    blue = '\\033[94m'\n    aqua = '\\033[96m'\n    white = '\\033[97m'\n    green = '\\033[92m'\n    orange = '\\033[38;5;172m'\n    yellow = '\\033[93m'\n    gray = '\\033[90m'\n    red = '\\033[91m'\n    purple = '\\033[95m'\n    bold_white = bold + white\n    bold_blue = bold + blue\n    bold_aqua = bold + aqua\n    bold_green = bold + green\n    bold_orange = bold + orange\n    bold_yellow = bold + yellow\n    bold_gray = bold + gray\n    bold_red = bold + red\n    bold_purple = bold + purple\n    end = '\\033[0m'\n</code></pre>"},{"location":"api/m/color/colors/#m.color.colors.color","title":"<code>color(*args, auto_end=True)</code>","text":"<p>Color a message.</p> <p>Format the arguments by replacing the colors in the Colors class. For instance::</p> <pre><code>color('{blue}Hello there{end}\\n{yellow}WARNING')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>str</code> <p>Strings to color</p> <code>()</code> <code>auto_end</code> <code>bool</code> <p>Add a string to end coloring</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>A formatted message.</p> Source code in <code>m/color/colors.py</code> <pre><code>def color(*args: str, auto_end: bool = True) -&gt; str:\n    r\"\"\"Color a message.\n\n    Format the arguments by replacing the colors in the Colors class.\n    For instance::\n\n        color('{blue}Hello there{end}\\n{yellow}WARNING')\n\n    Args:\n        args: Strings to color\n        auto_end: Add a string to end coloring\n\n    Returns:\n        A formatted message.\n    \"\"\"\n    no_color = color_disabled()\n    color_map = no_color_dict if no_color else color_dict\n    end = '' if no_color or not auto_end else Color.end\n    msg_list = [msg.format(**color_map) for msg in args]\n    return ''.join(msg_list) + end\n</code></pre>"},{"location":"api/m/color/disable/","title":"disable","text":""},{"location":"api/m/color/disable/#m.color.disable.color_disabled","title":"<code>color_disabled()</code>","text":"<p>Check for environment variable NO_COLOR.</p> <p>Utilities that format strings with color should call this function to determine if the user wants color in the final output.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if it exists and its set to true or 1.</p> Source code in <code>m/color/disable.py</code> <pre><code>def color_disabled() -&gt; bool:\n    \"\"\"Check for environment variable NO_COLOR.\n\n    Utilities that format strings with color should call this function\n    to determine if the user wants color in the final output.\n\n    Returns:\n        True if it exists and its set to true or 1.\n    \"\"\"\n    return os.environ.get('NO_COLOR', 'false') in {'true', '1', 'True'}\n</code></pre>"},{"location":"api/m/color/pygment/","title":"pygment","text":""},{"location":"api/m/color/pygment/#m.color.pygment.highlight_json","title":"<code>highlight_json(text)</code>","text":"<p>Highlight a json string.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The json string to highlight.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A colorized json string.</p> Source code in <code>m/color/pygment.py</code> <pre><code>def highlight_json(text: str) -&gt; str:\n    \"\"\"Highlight a json string.\n\n    Args:\n        text: The json string to highlight.\n\n    Returns:\n        A colorized json string.\n    \"\"\"\n    return _highlight(text, JsonLexer())\n</code></pre>"},{"location":"api/m/color/pygment/#m.color.pygment.highlight_yaml","title":"<code>highlight_yaml(text)</code>","text":"<p>Highlight a yaml string.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The yaml string to highlight.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A colorized yaml string.</p> Source code in <code>m/color/pygment.py</code> <pre><code>def highlight_yaml(text: str) -&gt; str:\n    \"\"\"Highlight a yaml string.\n\n    Args:\n        text: The yaml string to highlight.\n\n    Returns:\n        A colorized yaml string.\n    \"\"\"\n    return _highlight(text, YamlLexer())\n</code></pre>"},{"location":"api/m/core/","title":"core","text":""},{"location":"api/m/core/#m.core.Bad","title":"<code>Bad</code>","text":"<p>             Bases: <code>Generic[B, G]</code></p> <p>The bad side of the disjoint union.</p> Source code in <code>m/core/fp.py</code> <pre><code>class Bad(Generic[B, G]):\n    \"\"\"The bad side of the disjoint union.\"\"\"\n\n    value: B\n    is_bad = True\n\n    def __init__(self, value: B):\n        \"\"\"Initialize a `Bad` instance.\n\n        Args:\n            value: The \"bad\" value to store in the instance.\n        \"\"\"\n        self.value = value\n\n    def __iter__(self) -&gt; Iterator[G]:\n        \"\"\"Iterate over values of an instance.\n\n        The intention is to raise a `StopBadIteration` exception to\n        be able to break out of for loop comprehensions.\n\n        Raises:\n            StopBadIteration: If the instance has a \"Bad\" value.\n        \"\"\"\n        raise StopBadIteration(self)\n\n    def iter(self) -&gt; Iterator[G]:\n        \"\"\"Shortcut to transform to a list.\n\n        Can be used as `list(x.iter())`. It will either contain a value or be\n        an empty list.\n\n        Yields:\n            The value if the instance is a \"Good\" value.\n        \"\"\"\n        empty = ()\n        yield from empty\n\n    def get_or_else(self, default: LazyArg[G]) -&gt; G:\n        \"\"\"Return the value if its Good or the given argument if its a Bad.\n\n        Args:\n            default: The default value in case the instance is \"Bad\".\n\n        Returns:\n            Either the value or the default specified by \"default\".\n        \"\"\"\n        return lazy_arg(default)\n\n    def map(self, _fct: Callable[[G], K]) -&gt; 'Bad[B, K]':\n        \"\"\"Apply the function to its value if this is a `Good` instance.\n\n        Args:\n            _fct: The function to apply to the \"Good\" value.\n\n        Returns:\n            Itself if its a `Bad` otherwise another instance of `Good`.\n        \"\"\"\n        return cast(Bad[B, K], self)\n\n    def flat_map_bad(self, fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n        \"\"\"Apply the input function if this is a `Bad` value.\n\n        Args:\n            fct: The function to apply to the \"Bad\" value.\n\n        Returns:\n            Itself if its a `Good` otherwise another instance of `Bad`.\n        \"\"\"\n        return fct(self.value)\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.__init__","title":"<code>__init__(value)</code>","text":"<p>Initialize a <code>Bad</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>B</code> <p>The \"bad\" value to store in the instance.</p> required Source code in <code>m/core/fp.py</code> <pre><code>def __init__(self, value: B):\n    \"\"\"Initialize a `Bad` instance.\n\n    Args:\n        value: The \"bad\" value to store in the instance.\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over values of an instance.</p> <p>The intention is to raise a <code>StopBadIteration</code> exception to be able to break out of for loop comprehensions.</p> <p>Raises:</p> Type Description <code>StopBadIteration</code> <p>If the instance has a \"Bad\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def __iter__(self) -&gt; Iterator[G]:\n    \"\"\"Iterate over values of an instance.\n\n    The intention is to raise a `StopBadIteration` exception to\n    be able to break out of for loop comprehensions.\n\n    Raises:\n        StopBadIteration: If the instance has a \"Bad\" value.\n    \"\"\"\n    raise StopBadIteration(self)\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.flat_map_bad","title":"<code>flat_map_bad(fct)</code>","text":"<p>Apply the input function if this is a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>fct</code> <code>Callable[[B], OneOf[B, G]]</code> <p>The function to apply to the \"Bad\" value.</p> required <p>Returns:</p> Type Description <code>OneOf[B, G]</code> <p>Itself if its a <code>Good</code> otherwise another instance of <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def flat_map_bad(self, fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n    \"\"\"Apply the input function if this is a `Bad` value.\n\n    Args:\n        fct: The function to apply to the \"Bad\" value.\n\n    Returns:\n        Itself if its a `Good` otherwise another instance of `Bad`.\n    \"\"\"\n    return fct(self.value)\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.get_or_else","title":"<code>get_or_else(default)</code>","text":"<p>Return the value if its Good or the given argument if its a Bad.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>LazyArg[G]</code> <p>The default value in case the instance is \"Bad\".</p> required <p>Returns:</p> Type Description <code>G</code> <p>Either the value or the default specified by \"default\".</p> Source code in <code>m/core/fp.py</code> <pre><code>def get_or_else(self, default: LazyArg[G]) -&gt; G:\n    \"\"\"Return the value if its Good or the given argument if its a Bad.\n\n    Args:\n        default: The default value in case the instance is \"Bad\".\n\n    Returns:\n        Either the value or the default specified by \"default\".\n    \"\"\"\n    return lazy_arg(default)\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.iter","title":"<code>iter()</code>","text":"<p>Shortcut to transform to a list.</p> <p>Can be used as <code>list(x.iter())</code>. It will either contain a value or be an empty list.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value if the instance is a \"Good\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def iter(self) -&gt; Iterator[G]:\n    \"\"\"Shortcut to transform to a list.\n\n    Can be used as `list(x.iter())`. It will either contain a value or be\n    an empty list.\n\n    Yields:\n        The value if the instance is a \"Good\" value.\n    \"\"\"\n    empty = ()\n    yield from empty\n</code></pre>"},{"location":"api/m/core/#m.core.Bad.map","title":"<code>map(_fct)</code>","text":"<p>Apply the function to its value if this is a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>_fct</code> <code>Callable[[G], K]</code> <p>The function to apply to the \"Good\" value.</p> required <p>Returns:</p> Type Description <code>'Bad[B, K]'</code> <p>Itself if its a <code>Bad</code> otherwise another instance of <code>Good</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def map(self, _fct: Callable[[G], K]) -&gt; 'Bad[B, K]':\n    \"\"\"Apply the function to its value if this is a `Good` instance.\n\n    Args:\n        _fct: The function to apply to the \"Good\" value.\n\n    Returns:\n        Itself if its a `Bad` otherwise another instance of `Good`.\n    \"\"\"\n    return cast(Bad[B, K], self)\n</code></pre>"},{"location":"api/m/core/#m.core.Good","title":"<code>Good</code>","text":"<p>             Bases: <code>Generic[B, G]</code></p> <p>The good side of the disjoint union.</p> Source code in <code>m/core/fp.py</code> <pre><code>class Good(Generic[B, G]):\n    \"\"\"The good side of the disjoint union.\"\"\"\n\n    value: G\n    is_bad = False\n\n    def __init__(self, value: G):\n        \"\"\"Initialize a `Good` instance.\n\n        Args:\n            value: The \"good\" value to store in the instance.\n        \"\"\"\n        self.value = value\n\n    def __iter__(self) -&gt; Iterator[G]:\n        \"\"\"Iterate over the value of the instance.\n\n        Yields:\n            The value of the instance.\n        \"\"\"\n        yield self.value\n\n    def iter(self) -&gt; Iterator[G]:\n        \"\"\"Shortcut to transform to a list.\n\n        Can be used as `list(x.iter())`. It will either contain a value or be\n        an empty list.\n\n        Yields:\n            The value if the instance is a \"Good\" value.\n        \"\"\"\n        if not self.is_bad:\n            yield self.value\n\n    def get_or_else(self, _default: LazyArg[G]) -&gt; G:\n        \"\"\"Return the value.\n\n        Args:\n            _default: The default value in case the instance is \"Bad\".\n\n        Returns:\n            Either the value or the default specified by \"default\".\n        \"\"\"\n        return self.value\n\n    def map(self, fct: Callable[[G], K]) -&gt; 'Good[B, K]':\n        \"\"\"Apply the function to its value if this is a `Good` instance.\n\n        Args:\n            fct: The function to apply to the \"Good\" value.\n\n        Returns:\n            Itself if its a `Bad` otherwise another instance of `Good`.\n        \"\"\"\n        return Good(fct(self.value))\n\n    def flat_map_bad(self, _fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n        \"\"\"Apply the input function if this is a `Bad` value.\n\n        Args:\n            _fct: The function to apply to the \"Bad\" value.\n\n        Returns:\n            Itself if its a `Good` otherwise another instance of `Bad`.\n        \"\"\"\n        return self\n</code></pre>"},{"location":"api/m/core/#m.core.Good.__init__","title":"<code>__init__(value)</code>","text":"<p>Initialize a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>G</code> <p>The \"good\" value to store in the instance.</p> required Source code in <code>m/core/fp.py</code> <pre><code>def __init__(self, value: G):\n    \"\"\"Initialize a `Good` instance.\n\n    Args:\n        value: The \"good\" value to store in the instance.\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"api/m/core/#m.core.Good.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the value of the instance.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value of the instance.</p> Source code in <code>m/core/fp.py</code> <pre><code>def __iter__(self) -&gt; Iterator[G]:\n    \"\"\"Iterate over the value of the instance.\n\n    Yields:\n        The value of the instance.\n    \"\"\"\n    yield self.value\n</code></pre>"},{"location":"api/m/core/#m.core.Good.flat_map_bad","title":"<code>flat_map_bad(_fct)</code>","text":"<p>Apply the input function if this is a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>_fct</code> <code>Callable[[B], OneOf[B, G]]</code> <p>The function to apply to the \"Bad\" value.</p> required <p>Returns:</p> Type Description <code>OneOf[B, G]</code> <p>Itself if its a <code>Good</code> otherwise another instance of <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def flat_map_bad(self, _fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n    \"\"\"Apply the input function if this is a `Bad` value.\n\n    Args:\n        _fct: The function to apply to the \"Bad\" value.\n\n    Returns:\n        Itself if its a `Good` otherwise another instance of `Bad`.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/m/core/#m.core.Good.get_or_else","title":"<code>get_or_else(_default)</code>","text":"<p>Return the value.</p> <p>Parameters:</p> Name Type Description Default <code>_default</code> <code>LazyArg[G]</code> <p>The default value in case the instance is \"Bad\".</p> required <p>Returns:</p> Type Description <code>G</code> <p>Either the value or the default specified by \"default\".</p> Source code in <code>m/core/fp.py</code> <pre><code>def get_or_else(self, _default: LazyArg[G]) -&gt; G:\n    \"\"\"Return the value.\n\n    Args:\n        _default: The default value in case the instance is \"Bad\".\n\n    Returns:\n        Either the value or the default specified by \"default\".\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"api/m/core/#m.core.Good.iter","title":"<code>iter()</code>","text":"<p>Shortcut to transform to a list.</p> <p>Can be used as <code>list(x.iter())</code>. It will either contain a value or be an empty list.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value if the instance is a \"Good\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def iter(self) -&gt; Iterator[G]:\n    \"\"\"Shortcut to transform to a list.\n\n    Can be used as `list(x.iter())`. It will either contain a value or be\n    an empty list.\n\n    Yields:\n        The value if the instance is a \"Good\" value.\n    \"\"\"\n    if not self.is_bad:\n        yield self.value\n</code></pre>"},{"location":"api/m/core/#m.core.Good.map","title":"<code>map(fct)</code>","text":"<p>Apply the function to its value if this is a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>fct</code> <code>Callable[[G], K]</code> <p>The function to apply to the \"Good\" value.</p> required <p>Returns:</p> Type Description <code>'Good[B, K]'</code> <p>Itself if its a <code>Bad</code> otherwise another instance of <code>Good</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def map(self, fct: Callable[[G], K]) -&gt; 'Good[B, K]':\n    \"\"\"Apply the function to its value if this is a `Good` instance.\n\n    Args:\n        fct: The function to apply to the \"Good\" value.\n\n    Returns:\n        Itself if its a `Bad` otherwise another instance of `Good`.\n    \"\"\"\n    return Good(fct(self.value))\n</code></pre>"},{"location":"api/m/core/#m.core.Issue","title":"<code>Issue</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Wrapper to keep track of all exceptions.</p> <p>It provides a 'cause' field so that we may know why an issue was triggered.</p> Source code in <code>m/core/issue.py</code> <pre><code>class Issue(Exception):  # noqa: N818, WPS230 - Intention is not to raise\n    \"\"\"Wrapper to keep track of all exceptions.\n\n    It provides a 'cause' field so that we may know why an issue was\n    triggered.\n    \"\"\"\n\n    show_traceback = True\n    yaml_traceback = True\n\n    message: str\n    description: str | None\n    cause: Exception | None\n    context: object | None\n    include_traceback: bool\n    cause_tb: list[str] | None\n    traceback: list[str] | None\n\n    def __init__(  # noqa: WPS211 - need to initialize the attributes\n        self,\n        message: str,\n        description: str | None = None,\n        cause: Exception | None = None,\n        context: object | None = None,\n        include_traceback: bool = True,\n    ):\n        \"\"\"Create an Issue.\n\n        Args:\n            message: Simple description of the issue.\n            description: More in depth detail on the issue\n            cause: The exception/Issue that is responsible for this instance.\n            context: Dictionary with any useful data related to the issue.\n            include_traceback: If False, it skips computing the traceback.\n        \"\"\"\n        super().__init__()\n        self.message = message\n        self.description = description\n        self.cause = cause\n        if cause and not isinstance(cause, Issue):\n            # https://stackoverflow.com/a/12539332/788553\n            with suppress(BaseException):\n                exc_info = sys.exc_info()\n                fmt_exception = (\n                    traceback.format_exception_only(exc_info[0], exc_info[1])\n                    if exc_info[0] is not None and exc_info[1] is not None\n                    else []\n                )\n                exception_list = [\n                    *traceback.format_tb(exc_info[2]),\n                    *fmt_exception,\n                ]\n                self.cause_tb = [\n                    y\n                    for x in exception_list\n                    for y in x.splitlines()\n                ]\n        self.context = context\n        self.include_traceback = include_traceback\n        self.traceback = None\n        if self.include_traceback:\n            frame = inspect.currentframe()\n            self.traceback = [\n                y\n                for x in traceback.format_stack(frame)[:-1]\n                for y in x.splitlines()\n            ]\n\n    def only_context(self) -&gt; bool:\n        \"\"\"Return true if the issue only offers context.\n\n        In some cases we may create an issue with only a message and a\n        context. This function will let us know of such case so that a\n        log formatter may be able to unwrap the context.\n\n        Returns:\n            True if it is safe to only display the context value on a log.\n        \"\"\"\n        has_context = self.context is not None\n        all_props = (self.description, self.traceback, self.cause)\n        return has_context and not [_ for _ in all_props if _]\n\n    def to_dict(self, show_traceback: bool = True) -&gt; IssueDict:\n        \"\"\"Convert to a ordered dictionary.\n\n        This is done so that each of the properties are written in an expected\n        order.\n\n        Args:\n            show_traceback: If False, it will remove all stacktraces.\n\n        Returns:\n            An `IssueDict` instance.\n        \"\"\"\n        issue_dict = cast(IssueDict, OrderedDict())\n        issue_dict['message'] = self.message\n        if self.description:\n            issue_dict['description'] = self.description\n        if self.context:\n            issue_dict['context'] = self.context\n        if self.include_traceback and self.traceback:\n            issue_dict['traceback'] = self.traceback\n            if Issue.yaml_traceback and isinstance(self.traceback, list):\n                issue_dict['traceback'] = _traceback_to_str(self.traceback)\n        if self.cause:\n            self._handle_cause(issue_dict)\n        if not show_traceback:\n            remove_traceback(issue_dict)\n        return issue_dict\n\n    def to_str(self, show_traceback: bool) -&gt; str:\n        \"\"\"Convert the instance to string.\n\n        Args:\n            show_traceback: If false, it will remove the error traceback.\n\n        Returns:\n            A string representation of the Issue instance.\n        \"\"\"\n        issue_dict = self.to_dict(show_traceback=show_traceback)\n        if Issue.yaml_traceback:\n            return yaml.dumps(issue_dict)\n        return json.dumps(issue_dict, indent=2)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Convert the instance to a string.\n\n        Returns:\n            A string representation of the Issue instance.\n        \"\"\"\n        issue_str = self.to_str(Issue.show_traceback)\n        if Issue.yaml_traceback:\n            return highlight_yaml(issue_str)\n        return highlight_json(issue_str)\n\n    def _handle_cause(self, issue_dict: IssueDict) -&gt; None:\n        if isinstance(self.cause, Issue):\n            issue_dict['cause'] = self.cause.to_dict()\n        else:\n            issue_dict['cause'] = {\n                'message': str(self.cause),\n                'traceback': self.cause_tb,\n            }\n            # I'm clearly assigning to a dict in the above statement...\n            # but it is an object so a dict can be assigned to it but that\n            # does not mean that we can use `pop` on an object. So we have to\n            # help mypy know that know we are dealing with a dict.\n            cause = cast(dict, issue_dict['cause'])\n            if not self.cause_tb:\n                cause.pop('traceback', None)\n            if Issue.yaml_traceback and isinstance(self.cause_tb, list):\n                cause['traceback'] = _traceback_to_str(self.cause_tb)\n</code></pre>"},{"location":"api/m/core/#m.core.Issue.__init__","title":"<code>__init__(message, description=None, cause=None, context=None, include_traceback=True)</code>","text":"<p>Create an Issue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Simple description of the issue.</p> required <code>description</code> <code>str | None</code> <p>More in depth detail on the issue</p> <code>None</code> <code>cause</code> <code>Exception | None</code> <p>The exception/Issue that is responsible for this instance.</p> <code>None</code> <code>context</code> <code>object | None</code> <p>Dictionary with any useful data related to the issue.</p> <code>None</code> <code>include_traceback</code> <code>bool</code> <p>If False, it skips computing the traceback.</p> <code>True</code> Source code in <code>m/core/issue.py</code> <pre><code>def __init__(  # noqa: WPS211 - need to initialize the attributes\n    self,\n    message: str,\n    description: str | None = None,\n    cause: Exception | None = None,\n    context: object | None = None,\n    include_traceback: bool = True,\n):\n    \"\"\"Create an Issue.\n\n    Args:\n        message: Simple description of the issue.\n        description: More in depth detail on the issue\n        cause: The exception/Issue that is responsible for this instance.\n        context: Dictionary with any useful data related to the issue.\n        include_traceback: If False, it skips computing the traceback.\n    \"\"\"\n    super().__init__()\n    self.message = message\n    self.description = description\n    self.cause = cause\n    if cause and not isinstance(cause, Issue):\n        # https://stackoverflow.com/a/12539332/788553\n        with suppress(BaseException):\n            exc_info = sys.exc_info()\n            fmt_exception = (\n                traceback.format_exception_only(exc_info[0], exc_info[1])\n                if exc_info[0] is not None and exc_info[1] is not None\n                else []\n            )\n            exception_list = [\n                *traceback.format_tb(exc_info[2]),\n                *fmt_exception,\n            ]\n            self.cause_tb = [\n                y\n                for x in exception_list\n                for y in x.splitlines()\n            ]\n    self.context = context\n    self.include_traceback = include_traceback\n    self.traceback = None\n    if self.include_traceback:\n        frame = inspect.currentframe()\n        self.traceback = [\n            y\n            for x in traceback.format_stack(frame)[:-1]\n            for y in x.splitlines()\n        ]\n</code></pre>"},{"location":"api/m/core/#m.core.Issue.__str__","title":"<code>__str__()</code>","text":"<p>Convert the instance to a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the Issue instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Convert the instance to a string.\n\n    Returns:\n        A string representation of the Issue instance.\n    \"\"\"\n    issue_str = self.to_str(Issue.show_traceback)\n    if Issue.yaml_traceback:\n        return highlight_yaml(issue_str)\n    return highlight_json(issue_str)\n</code></pre>"},{"location":"api/m/core/#m.core.Issue.only_context","title":"<code>only_context()</code>","text":"<p>Return true if the issue only offers context.</p> <p>In some cases we may create an issue with only a message and a context. This function will let us know of such case so that a log formatter may be able to unwrap the context.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if it is safe to only display the context value on a log.</p> Source code in <code>m/core/issue.py</code> <pre><code>def only_context(self) -&gt; bool:\n    \"\"\"Return true if the issue only offers context.\n\n    In some cases we may create an issue with only a message and a\n    context. This function will let us know of such case so that a\n    log formatter may be able to unwrap the context.\n\n    Returns:\n        True if it is safe to only display the context value on a log.\n    \"\"\"\n    has_context = self.context is not None\n    all_props = (self.description, self.traceback, self.cause)\n    return has_context and not [_ for _ in all_props if _]\n</code></pre>"},{"location":"api/m/core/#m.core.Issue.to_dict","title":"<code>to_dict(show_traceback=True)</code>","text":"<p>Convert to a ordered dictionary.</p> <p>This is done so that each of the properties are written in an expected order.</p> <p>Parameters:</p> Name Type Description Default <code>show_traceback</code> <code>bool</code> <p>If False, it will remove all stacktraces.</p> <code>True</code> <p>Returns:</p> Type Description <code>IssueDict</code> <p>An <code>IssueDict</code> instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def to_dict(self, show_traceback: bool = True) -&gt; IssueDict:\n    \"\"\"Convert to a ordered dictionary.\n\n    This is done so that each of the properties are written in an expected\n    order.\n\n    Args:\n        show_traceback: If False, it will remove all stacktraces.\n\n    Returns:\n        An `IssueDict` instance.\n    \"\"\"\n    issue_dict = cast(IssueDict, OrderedDict())\n    issue_dict['message'] = self.message\n    if self.description:\n        issue_dict['description'] = self.description\n    if self.context:\n        issue_dict['context'] = self.context\n    if self.include_traceback and self.traceback:\n        issue_dict['traceback'] = self.traceback\n        if Issue.yaml_traceback and isinstance(self.traceback, list):\n            issue_dict['traceback'] = _traceback_to_str(self.traceback)\n    if self.cause:\n        self._handle_cause(issue_dict)\n    if not show_traceback:\n        remove_traceback(issue_dict)\n    return issue_dict\n</code></pre>"},{"location":"api/m/core/#m.core.Issue.to_str","title":"<code>to_str(show_traceback)</code>","text":"<p>Convert the instance to string.</p> <p>Parameters:</p> Name Type Description Default <code>show_traceback</code> <code>bool</code> <p>If false, it will remove the error traceback.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the Issue instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def to_str(self, show_traceback: bool) -&gt; str:\n    \"\"\"Convert the instance to string.\n\n    Args:\n        show_traceback: If false, it will remove the error traceback.\n\n    Returns:\n        A string representation of the Issue instance.\n    \"\"\"\n    issue_dict = self.to_dict(show_traceback=show_traceback)\n    if Issue.yaml_traceback:\n        return yaml.dumps(issue_dict)\n    return json.dumps(issue_dict, indent=2)\n</code></pre>"},{"location":"api/m/core/#m.core.hone","title":"<code>hone(msg, context=None, description=None, include_traceback=True)</code>","text":"<p>Create a function to repackage the issue with a new message and context.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The new message.</p> required <code>context</code> <code>object | None</code> <p>The new context.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>The new description.</p> <code>None</code> <code>include_traceback</code> <code>bool</code> <p>Whether to include the traceback.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[[Issue], OneOf[Issue, Any]]</code> <p>A function that takes an issue and returns a new issue.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def hone(\n    msg: str,\n    context: object | None = None,\n    description: str | None = None,\n    include_traceback: bool = True,\n) -&gt; Callable[[Issue], OneOf[Issue, Any]]:\n    \"\"\"Create a function to repackage the issue with a new message and context.\n\n    Args:\n        msg: The new message.\n        context: The new context.\n        description: The new description.\n        include_traceback: Whether to include the traceback.\n\n    Returns:\n        A function that takes an issue and returns a new issue.\n    \"\"\"\n    return partial(_hone, msg, context, description, include_traceback)\n</code></pre>"},{"location":"api/m/core/#m.core.is_bad","title":"<code>is_bad(inst)</code>","text":"<p>Assert that a OneOf instance is a <code>Bad</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>OneOf[B, G]</code> <p>The <code>OneOf</code> instance.</p> required <p>Returns:</p> Type Description <code>TypeGuard[Bad[B, G]]</code> <p>True if the instance is a <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `is_bad` type guard is deprecated; use `isinstance(inst, Bad)` instead.',\n)\ndef is_bad(inst: OneOf[B, G]) -&gt; TypeGuard[Bad[B, G]]:\n    \"\"\"Assert that a OneOf instance is a `Bad`.\n\n    Args:\n        inst: The `OneOf` instance.\n\n    Returns:\n        True if the instance is a `Bad`.\n    \"\"\"\n    # `m` does not reference this function anymore, excluding from coverage\n    return isinstance(inst, Bad)  # pragma: no cover\n</code></pre>"},{"location":"api/m/core/#m.core.non_issue","title":"<code>non_issue(inst)</code>","text":"<p>Obtain the value of the <code>OneOf</code> as if it was a Good value.</p> <p>Warning: This should only be used provided that we know for sure that we are not dealing with a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>OneOf[Issue, G]</code> <p>A OneOf.</p> required <p>Returns:</p> Type Description <code>G</code> <p>The value stored in the OneOf.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def non_issue(inst: OneOf[Issue, G]) -&gt; G:\n    \"\"\"Obtain the value of the `OneOf` as if it was a Good value.\n\n    Warning: This should only be used provided that we know for sure\n    that we are not dealing with a `Bad` value.\n\n    Args:\n        inst: A OneOf.\n\n    Returns:\n        The value stored in the OneOf.\n    \"\"\"\n    # The assert statement can go away with the -O flag.\n    assert not inst.is_bad  # noqa: S101\n    return cast(G, inst.value)\n</code></pre>"},{"location":"api/m/core/fp/","title":"fp","text":""},{"location":"api/m/core/fp/#m.core.fp.Bad","title":"<code>Bad</code>","text":"<p>             Bases: <code>Generic[B, G]</code></p> <p>The bad side of the disjoint union.</p> Source code in <code>m/core/fp.py</code> <pre><code>class Bad(Generic[B, G]):\n    \"\"\"The bad side of the disjoint union.\"\"\"\n\n    value: B\n    is_bad = True\n\n    def __init__(self, value: B):\n        \"\"\"Initialize a `Bad` instance.\n\n        Args:\n            value: The \"bad\" value to store in the instance.\n        \"\"\"\n        self.value = value\n\n    def __iter__(self) -&gt; Iterator[G]:\n        \"\"\"Iterate over values of an instance.\n\n        The intention is to raise a `StopBadIteration` exception to\n        be able to break out of for loop comprehensions.\n\n        Raises:\n            StopBadIteration: If the instance has a \"Bad\" value.\n        \"\"\"\n        raise StopBadIteration(self)\n\n    def iter(self) -&gt; Iterator[G]:\n        \"\"\"Shortcut to transform to a list.\n\n        Can be used as `list(x.iter())`. It will either contain a value or be\n        an empty list.\n\n        Yields:\n            The value if the instance is a \"Good\" value.\n        \"\"\"\n        empty = ()\n        yield from empty\n\n    def get_or_else(self, default: LazyArg[G]) -&gt; G:\n        \"\"\"Return the value if its Good or the given argument if its a Bad.\n\n        Args:\n            default: The default value in case the instance is \"Bad\".\n\n        Returns:\n            Either the value or the default specified by \"default\".\n        \"\"\"\n        return lazy_arg(default)\n\n    def map(self, _fct: Callable[[G], K]) -&gt; 'Bad[B, K]':\n        \"\"\"Apply the function to its value if this is a `Good` instance.\n\n        Args:\n            _fct: The function to apply to the \"Good\" value.\n\n        Returns:\n            Itself if its a `Bad` otherwise another instance of `Good`.\n        \"\"\"\n        return cast(Bad[B, K], self)\n\n    def flat_map_bad(self, fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n        \"\"\"Apply the input function if this is a `Bad` value.\n\n        Args:\n            fct: The function to apply to the \"Bad\" value.\n\n        Returns:\n            Itself if its a `Good` otherwise another instance of `Bad`.\n        \"\"\"\n        return fct(self.value)\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.__init__","title":"<code>__init__(value)</code>","text":"<p>Initialize a <code>Bad</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>B</code> <p>The \"bad\" value to store in the instance.</p> required Source code in <code>m/core/fp.py</code> <pre><code>def __init__(self, value: B):\n    \"\"\"Initialize a `Bad` instance.\n\n    Args:\n        value: The \"bad\" value to store in the instance.\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over values of an instance.</p> <p>The intention is to raise a <code>StopBadIteration</code> exception to be able to break out of for loop comprehensions.</p> <p>Raises:</p> Type Description <code>StopBadIteration</code> <p>If the instance has a \"Bad\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def __iter__(self) -&gt; Iterator[G]:\n    \"\"\"Iterate over values of an instance.\n\n    The intention is to raise a `StopBadIteration` exception to\n    be able to break out of for loop comprehensions.\n\n    Raises:\n        StopBadIteration: If the instance has a \"Bad\" value.\n    \"\"\"\n    raise StopBadIteration(self)\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.flat_map_bad","title":"<code>flat_map_bad(fct)</code>","text":"<p>Apply the input function if this is a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>fct</code> <code>Callable[[B], OneOf[B, G]]</code> <p>The function to apply to the \"Bad\" value.</p> required <p>Returns:</p> Type Description <code>OneOf[B, G]</code> <p>Itself if its a <code>Good</code> otherwise another instance of <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def flat_map_bad(self, fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n    \"\"\"Apply the input function if this is a `Bad` value.\n\n    Args:\n        fct: The function to apply to the \"Bad\" value.\n\n    Returns:\n        Itself if its a `Good` otherwise another instance of `Bad`.\n    \"\"\"\n    return fct(self.value)\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.get_or_else","title":"<code>get_or_else(default)</code>","text":"<p>Return the value if its Good or the given argument if its a Bad.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>LazyArg[G]</code> <p>The default value in case the instance is \"Bad\".</p> required <p>Returns:</p> Type Description <code>G</code> <p>Either the value or the default specified by \"default\".</p> Source code in <code>m/core/fp.py</code> <pre><code>def get_or_else(self, default: LazyArg[G]) -&gt; G:\n    \"\"\"Return the value if its Good or the given argument if its a Bad.\n\n    Args:\n        default: The default value in case the instance is \"Bad\".\n\n    Returns:\n        Either the value or the default specified by \"default\".\n    \"\"\"\n    return lazy_arg(default)\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.iter","title":"<code>iter()</code>","text":"<p>Shortcut to transform to a list.</p> <p>Can be used as <code>list(x.iter())</code>. It will either contain a value or be an empty list.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value if the instance is a \"Good\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def iter(self) -&gt; Iterator[G]:\n    \"\"\"Shortcut to transform to a list.\n\n    Can be used as `list(x.iter())`. It will either contain a value or be\n    an empty list.\n\n    Yields:\n        The value if the instance is a \"Good\" value.\n    \"\"\"\n    empty = ()\n    yield from empty\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Bad.map","title":"<code>map(_fct)</code>","text":"<p>Apply the function to its value if this is a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>_fct</code> <code>Callable[[G], K]</code> <p>The function to apply to the \"Good\" value.</p> required <p>Returns:</p> Type Description <code>'Bad[B, K]'</code> <p>Itself if its a <code>Bad</code> otherwise another instance of <code>Good</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def map(self, _fct: Callable[[G], K]) -&gt; 'Bad[B, K]':\n    \"\"\"Apply the function to its value if this is a `Good` instance.\n\n    Args:\n        _fct: The function to apply to the \"Good\" value.\n\n    Returns:\n        Itself if its a `Bad` otherwise another instance of `Good`.\n    \"\"\"\n    return cast(Bad[B, K], self)\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good","title":"<code>Good</code>","text":"<p>             Bases: <code>Generic[B, G]</code></p> <p>The good side of the disjoint union.</p> Source code in <code>m/core/fp.py</code> <pre><code>class Good(Generic[B, G]):\n    \"\"\"The good side of the disjoint union.\"\"\"\n\n    value: G\n    is_bad = False\n\n    def __init__(self, value: G):\n        \"\"\"Initialize a `Good` instance.\n\n        Args:\n            value: The \"good\" value to store in the instance.\n        \"\"\"\n        self.value = value\n\n    def __iter__(self) -&gt; Iterator[G]:\n        \"\"\"Iterate over the value of the instance.\n\n        Yields:\n            The value of the instance.\n        \"\"\"\n        yield self.value\n\n    def iter(self) -&gt; Iterator[G]:\n        \"\"\"Shortcut to transform to a list.\n\n        Can be used as `list(x.iter())`. It will either contain a value or be\n        an empty list.\n\n        Yields:\n            The value if the instance is a \"Good\" value.\n        \"\"\"\n        if not self.is_bad:\n            yield self.value\n\n    def get_or_else(self, _default: LazyArg[G]) -&gt; G:\n        \"\"\"Return the value.\n\n        Args:\n            _default: The default value in case the instance is \"Bad\".\n\n        Returns:\n            Either the value or the default specified by \"default\".\n        \"\"\"\n        return self.value\n\n    def map(self, fct: Callable[[G], K]) -&gt; 'Good[B, K]':\n        \"\"\"Apply the function to its value if this is a `Good` instance.\n\n        Args:\n            fct: The function to apply to the \"Good\" value.\n\n        Returns:\n            Itself if its a `Bad` otherwise another instance of `Good`.\n        \"\"\"\n        return Good(fct(self.value))\n\n    def flat_map_bad(self, _fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n        \"\"\"Apply the input function if this is a `Bad` value.\n\n        Args:\n            _fct: The function to apply to the \"Bad\" value.\n\n        Returns:\n            Itself if its a `Good` otherwise another instance of `Bad`.\n        \"\"\"\n        return self\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.__init__","title":"<code>__init__(value)</code>","text":"<p>Initialize a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>G</code> <p>The \"good\" value to store in the instance.</p> required Source code in <code>m/core/fp.py</code> <pre><code>def __init__(self, value: G):\n    \"\"\"Initialize a `Good` instance.\n\n    Args:\n        value: The \"good\" value to store in the instance.\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the value of the instance.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value of the instance.</p> Source code in <code>m/core/fp.py</code> <pre><code>def __iter__(self) -&gt; Iterator[G]:\n    \"\"\"Iterate over the value of the instance.\n\n    Yields:\n        The value of the instance.\n    \"\"\"\n    yield self.value\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.flat_map_bad","title":"<code>flat_map_bad(_fct)</code>","text":"<p>Apply the input function if this is a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>_fct</code> <code>Callable[[B], OneOf[B, G]]</code> <p>The function to apply to the \"Bad\" value.</p> required <p>Returns:</p> Type Description <code>OneOf[B, G]</code> <p>Itself if its a <code>Good</code> otherwise another instance of <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def flat_map_bad(self, _fct: Callable[[B], OneOf[B, G]]) -&gt; OneOf[B, G]:\n    \"\"\"Apply the input function if this is a `Bad` value.\n\n    Args:\n        _fct: The function to apply to the \"Bad\" value.\n\n    Returns:\n        Itself if its a `Good` otherwise another instance of `Bad`.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.get_or_else","title":"<code>get_or_else(_default)</code>","text":"<p>Return the value.</p> <p>Parameters:</p> Name Type Description Default <code>_default</code> <code>LazyArg[G]</code> <p>The default value in case the instance is \"Bad\".</p> required <p>Returns:</p> Type Description <code>G</code> <p>Either the value or the default specified by \"default\".</p> Source code in <code>m/core/fp.py</code> <pre><code>def get_or_else(self, _default: LazyArg[G]) -&gt; G:\n    \"\"\"Return the value.\n\n    Args:\n        _default: The default value in case the instance is \"Bad\".\n\n    Returns:\n        Either the value or the default specified by \"default\".\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.iter","title":"<code>iter()</code>","text":"<p>Shortcut to transform to a list.</p> <p>Can be used as <code>list(x.iter())</code>. It will either contain a value or be an empty list.</p> <p>Yields:</p> Type Description <code>G</code> <p>The value if the instance is a \"Good\" value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def iter(self) -&gt; Iterator[G]:\n    \"\"\"Shortcut to transform to a list.\n\n    Can be used as `list(x.iter())`. It will either contain a value or be\n    an empty list.\n\n    Yields:\n        The value if the instance is a \"Good\" value.\n    \"\"\"\n    if not self.is_bad:\n        yield self.value\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.Good.map","title":"<code>map(fct)</code>","text":"<p>Apply the function to its value if this is a <code>Good</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>fct</code> <code>Callable[[G], K]</code> <p>The function to apply to the \"Good\" value.</p> required <p>Returns:</p> Type Description <code>'Good[B, K]'</code> <p>Itself if its a <code>Bad</code> otherwise another instance of <code>Good</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>def map(self, fct: Callable[[G], K]) -&gt; 'Good[B, K]':\n    \"\"\"Apply the function to its value if this is a `Good` instance.\n\n    Args:\n        fct: The function to apply to the \"Good\" value.\n\n    Returns:\n        Itself if its a `Bad` otherwise another instance of `Good`.\n    \"\"\"\n    return Good(fct(self.value))\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.StopBadIteration","title":"<code>StopBadIteration</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Store a <code>Bad</code> instance.</p> Source code in <code>m/core/fp.py</code> <pre><code>class StopBadIteration(Exception):  # noqa: N818 - This is for internal use\n    \"\"\"Store a `Bad` instance.\"\"\"\n\n    def __init__(self, bad: Any):\n        \"\"\"Initialize the Exception.\n\n        Args:\n            bad: The `Bad` value stored in a `OneOf`.\n        \"\"\"\n        super().__init__()\n        self.bad = bad\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.StopBadIteration.__init__","title":"<code>__init__(bad)</code>","text":"<p>Initialize the Exception.</p> <p>Parameters:</p> Name Type Description Default <code>bad</code> <code>Any</code> <p>The <code>Bad</code> value stored in a <code>OneOf</code>.</p> required Source code in <code>m/core/fp.py</code> <pre><code>def __init__(self, bad: Any):\n    \"\"\"Initialize the Exception.\n\n    Args:\n        bad: The `Bad` value stored in a `OneOf`.\n    \"\"\"\n    super().__init__()\n    self.bad = bad\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.is_bad","title":"<code>is_bad(inst)</code>","text":"<p>Assert that a OneOf instance is a <code>Bad</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>OneOf[B, G]</code> <p>The <code>OneOf</code> instance.</p> required <p>Returns:</p> Type Description <code>TypeGuard[Bad[B, G]]</code> <p>True if the instance is a <code>Bad</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `is_bad` type guard is deprecated; use `isinstance(inst, Bad)` instead.',\n)\ndef is_bad(inst: OneOf[B, G]) -&gt; TypeGuard[Bad[B, G]]:\n    \"\"\"Assert that a OneOf instance is a `Bad`.\n\n    Args:\n        inst: The `OneOf` instance.\n\n    Returns:\n        True if the instance is a `Bad`.\n    \"\"\"\n    # `m` does not reference this function anymore, excluding from coverage\n    return isinstance(inst, Bad)  # pragma: no cover\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.is_good","title":"<code>is_good(inst)</code>","text":"<p>Assert that a OneOf instance is a <code>Good</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>OneOf[B, G]</code> <p>The <code>OneOf</code> instance.</p> required <p>Returns:</p> Type Description <code>TypeGuard[Good[B, G]]</code> <p>True if the instance is a <code>Good</code>.</p> Source code in <code>m/core/fp.py</code> <pre><code>@typing_extensions.deprecated(\n    'The `is_good` type guard is deprecated; use `isinstance(inst, Good)` instead.',\n)\ndef is_good(inst: OneOf[B, G]) -&gt; TypeGuard[Good[B, G]]:\n    \"\"\"Assert that a OneOf instance is a `Good`.\n\n    Args:\n        inst: The `OneOf` instance.\n\n    Returns:\n        True if the instance is a `Good`.\n    \"\"\"\n    # `m` does not reference this function anymore, excluding from coverage\n    return isinstance(inst, Good)  # pragma: no cover\n</code></pre>"},{"location":"api/m/core/fp/#m.core.fp.lazy_arg","title":"<code>lazy_arg(z_arg)</code>","text":"<p>Return the output of calling <code>z_arg</code> if it is function.</p> <p>Otherwise param is returned.</p> <p>Parameters:</p> Name Type Description Default <code>z_arg</code> <code>LazyArg[A]</code> <p>A function or a value</p> required <p>Returns:</p> Type Description <code>A</code> <p>The value.</p> Source code in <code>m/core/fp.py</code> <pre><code>def lazy_arg(z_arg: LazyArg[A]) -&gt; A:\n    \"\"\"Return the output of calling `z_arg` if it is function.\n\n    Otherwise param is returned.\n\n    Args:\n        z_arg: A function or a value\n\n    Returns:\n        The value.\n    \"\"\"\n    return z_arg() if callable(z_arg) else z_arg\n</code></pre>"},{"location":"api/m/core/http/","title":"http","text":""},{"location":"api/m/core/http/#m.core.http.FetchedResponse","title":"<code>FetchedResponse</code>  <code>dataclass</code>","text":"<p>Result object for fetch_response.</p> Source code in <code>m/core/http.py</code> <pre><code>@dataclass\nclass FetchedResponse:\n    \"\"\"Result object for fetch_response.\"\"\"\n\n    response: httplib.HTTPResponse\n    body: str\n</code></pre>"},{"location":"api/m/core/http/#m.core.http.HttpMethod","title":"<code>HttpMethod</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Python 3.10 does not have this enum.</p> <p>https://docs.python.org/3/library/http.html#http-methods</p> Source code in <code>m/core/http.py</code> <pre><code>class HttpMethod(str, Enum):  # noqa: WPS600\n    \"\"\"Python 3.10 does not have this enum.\n\n    https://docs.python.org/3/library/http.html#http-methods\n    \"\"\"\n\n    get = 'GET'\n    post = 'POST'\n    put = 'PUT'\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the value of the enum.\n\n        Returns:\n            The value of the enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"api/m/core/http/#m.core.http.HttpMethod.__str__","title":"<code>__str__()</code>","text":"<p>Return the value of the enum.</p> <p>Returns:</p> Type Description <code>str</code> <p>The value of the enum.</p> Source code in <code>m/core/http.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the value of the enum.\n\n    Returns:\n        The value of the enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"api/m/core/http/#m.core.http.fetch","title":"<code>fetch(url, headers, method=HttpMethod.get, body=None)</code>","text":"<p>Send an http(s) request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to request.</p> required <code>headers</code> <code>Mapping[str, str]</code> <p>The headers for the request. By default it sets the <code>user-agent</code> to \"m\".</p> required <code>method</code> <code>HttpMethod</code> <p>The request method type. Defaults to <code>GET</code>.</p> <code>get</code> <code>body</code> <code>Optional[str]</code> <p>The body of the request.</p> <code>None</code> <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>A <code>OneOf</code> containing the raw response from the server or an Issue.</p> Source code in <code>m/core/http.py</code> <pre><code>def fetch(\n    url: str,\n    headers: Mapping[str, str],\n    method: HttpMethod = HttpMethod.get,\n    body: Optional[str] = None,\n) -&gt; OneOf[Issue, str]:\n    \"\"\"Send an http(s) request.\n\n    Args:\n        url:\n            The url to request.\n        headers:\n            The headers for the request. By default it sets the `user-agent`\n            to \"m\".\n        method:\n            The request method type. Defaults to `GET`.\n        body:\n            The body of the request.\n\n    Returns:\n        A `OneOf` containing the raw response from the server or an Issue.\n    \"\"\"\n    return one_of(lambda: [\n        fetch_res.body\n        for fetch_res in fetch_response(url, headers, method, body)\n    ])\n</code></pre>"},{"location":"api/m/core/http/#m.core.http.fetch_json","title":"<code>fetch_json(url, headers, method=HttpMethod.get, body_json=None)</code>","text":"<p>Specialized fetch to deal with json data.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to request.</p> required <code>headers</code> <code>Mapping[str, str]</code> <p>Additional headers for the request. By default it will add proper accept and content-type headers for json requests.</p> required <code>method</code> <code>HttpMethod</code> <p>The request method type. Defaults to <code>GET</code>.</p> <code>get</code> <code>body_json</code> <code>Any</code> <p>The data to send to the server (python object).</p> <code>None</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>OneOf</code> containing a json parsed response from the server or an</p> <code>OneOf[Issue, Any]</code> <p>Issue.</p> Source code in <code>m/core/http.py</code> <pre><code>def fetch_json(\n    url: str,\n    headers: Mapping[str, str],\n    method: HttpMethod = HttpMethod.get,\n    body_json: Any = None,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Specialized fetch to deal with json data.\n\n    Args:\n        url:\n            The url to request.\n        headers:\n            Additional headers for the request. By default it will add\n            proper accept and content-type headers for json requests.\n        method:\n            The request method type. Defaults to `GET`.\n        body_json:\n            The data to send to the server (python object).\n\n    Returns:\n        A `OneOf` containing a json parsed response from the server or an\n        Issue.\n    \"\"\"\n    body = builtin_json.dumps(body_json) if body_json else None\n    fetch_headers = {\n        'accept': 'application/json',\n        'content-type': 'application/json',\n        **headers,\n    }\n    return one_of(lambda: [\n        response\n        for payload in fetch(url, fetch_headers, method, body)\n        for response in parse_json(payload)\n    ])\n</code></pre>"},{"location":"api/m/core/http/#m.core.http.fetch_response","title":"<code>fetch_response(url, headers, method=HttpMethod.get, body=None)</code>","text":"<p>Send an http(s) request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url to request.</p> required <code>headers</code> <code>Mapping[str, str]</code> <p>The headers for the request. By default it sets the <code>user-agent</code> to \"m\".</p> required <code>method</code> <code>HttpMethod</code> <p>The request method type. Defaults to <code>GET</code>.</p> <code>get</code> <code>body</code> <code>Optional[str]</code> <p>The body of the request.</p> <code>None</code> <p>Returns:</p> Type Description <code>OneOf[Issue, FetchedResponse]</code> <p>A <code>OneOf</code> containing the response object from the server or an Issue.</p> Source code in <code>m/core/http.py</code> <pre><code>def fetch_response(\n    url: str,\n    headers: Mapping[str, str],\n    method: HttpMethod = HttpMethod.get,\n    body: Optional[str] = None,\n) -&gt; OneOf[Issue, FetchedResponse]:\n    \"\"\"Send an http(s) request.\n\n    Args:\n        url:\n            The url to request.\n        headers:\n            The headers for the request. By default it sets the `user-agent`\n            to \"m\".\n        method:\n            The request method type. Defaults to `GET`.\n        body:\n            The body of the request.\n\n    Returns:\n        A `OneOf` containing the response object from the server or an Issue.\n    \"\"\"\n    parts = urlparse(url)\n    protocol, hostname, path = [parts.scheme, parts.netloc, parts.path]\n    path = f'{path}?{parts.query}' if parts.query else path\n    fetch_headers = {'user-agent': 'm', **headers}\n    ctxt: dict[str, str] = {'url': f'{hostname}{path}', 'method': f'{method}'}\n    if body:\n        fetch_headers['content-length'] = str(len(body))\n        if 'DEBUG_HTTP_INCLUDE_BODY' in os.environ:\n            ctxt['body'] = body\n    connection = _get_connection(protocol, hostname)\n    # See the next link for explanation disabling WPS440:\n    #  https://github.com/wemake-services/wemake-python-styleguide/issues/1416\n    try:\n        connection.request(f'{method}', path, body, fetch_headers)\n    except Exception as ex:\n        return issue(f'{protocol} request failure', cause=ex, context=ctxt)\n    try:\n        res = connection.getresponse()\n    except Exception as ex:  # noqa: WPS440\n        return issue(f'{protocol} response failure', cause=ex, context=ctxt)\n    try:\n        res_body = res.read().decode()\n    except Exception as ex:  # noqa: WPS440\n        return issue(f'{protocol} read failure', cause=ex, context=ctxt)\n    code = res.getcode()\n    if HTTPStatus.OK &lt;= code &lt; HTTPStatus.MULTIPLE_CHOICES:\n        return Good(FetchedResponse(\n            response=res,\n            body=res_body,\n        ))\n    return issue(\n        f'{protocol} request failure ({code})',\n        context={\n            'body': body,\n            'code': code,\n            'res_body': res_body,\n            **ctxt,\n        },\n    )\n</code></pre>"},{"location":"api/m/core/io/","title":"io","text":""},{"location":"api/m/core/io/#m.core.io.env","title":"<code>env(name, def_val='')</code>","text":"<p>Access an environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the environment variable.</p> required <code>def_val</code> <code>str</code> <p>The default value to return if not set. Defaults to empty.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The value of the environment variable if set otherwise the <code>def_val</code>.</p> Source code in <code>m/core/io.py</code> <pre><code>def env(name: str, def_val: str = '') -&gt; str:\n    \"\"\"Access an environment variable.\n\n    Args:\n        name: The name of the environment variable.\n        def_val: The default value to return if not set. Defaults to empty.\n\n    Returns:\n        The value of the environment variable if set otherwise the `def_val`.\n    \"\"\"\n    return os.environ.get(name, def_val)\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.env_model","title":"<code>env_model(model)</code>","text":"<p>Require multiple env vars to be defined.</p> <p>This can be done by defining a model::</p> <pre><code>class GithubEnvVars(BaseModel):\n    repo: str = Field('GITHUB_REPOSITORY')\n    run_id: str = Field('GITHUB_RUN_ID')\n</code></pre> <p>Then we use it::</p> <pre><code>print(env.repo for env in env_model(GithubEnvVars)])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[BaseModelT]</code> <p>A pydantic model specifying the environment variables to fetch.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, BaseModelT]</code> <p>A <code>OneOf</code> with the values of the environment variables or an issue.</p> Source code in <code>m/core/io.py</code> <pre><code>def env_model(model: type[BaseModelT]) -&gt; OneOf[Issue, BaseModelT]:\n    \"\"\"Require multiple env vars to be defined.\n\n    This can be done by defining a model::\n\n        class GithubEnvVars(BaseModel):\n            repo: str = Field('GITHUB_REPOSITORY')\n            run_id: str = Field('GITHUB_RUN_ID')\n\n    Then we use it::\n\n        print(env.repo for env in env_model(GithubEnvVars)])\n\n    Args:\n        model: A pydantic model specifying the environment variables to fetch.\n\n    Returns:\n        A `OneOf` with the values of the environment variables or an issue.\n    \"\"\"\n    schema = model.model_json_schema()\n    missing: list[str] = []\n    env_values: dict[str, str] = {}\n    for name, field in schema['properties'].items():\n        env_name = field.get('default')\n        env_value = os.environ.get(env_name)\n        if env_value is None:\n            missing.append(env_name)\n        else:\n            env_values[name] = env_value\n    if missing:\n        missing_str = ', '.join(missing)\n        return issue(f'missing [{missing_str}] in env')\n    return Good(model(**env_values))\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.format_seconds","title":"<code>format_seconds(number_of_seconds)</code>","text":"<p>Return a string representing the number of seconds.</p> <p>The format is Xd:Xh:Xm:Xs:Xms.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_seconds</code> <code>int | float</code> <p>The number of seconds to format.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A friendly representation of the number of seconds.</p> Source code in <code>m/core/io.py</code> <pre><code>def format_seconds(number_of_seconds: int | float) -&gt; str:\n    \"\"\"Return a string representing the number of seconds.\n\n    The format is Xd:Xh:Xm:Xs:Xms.\n\n    Args:\n        number_of_seconds: The number of seconds to format.\n\n    Returns:\n        A friendly representation of the number of seconds.\n    \"\"\"\n    milliseconds = int(math.floor(number_of_seconds * 1000))\n    milli_sec = milliseconds % 1000\n    seconds = int(math.floor(milliseconds / 1000))\n    sec = seconds % 60\n    minutes = int(math.floor(seconds / 60))\n    mins = minutes % 60\n    hours = int(math.floor(minutes / 60))\n    hrs = hours % 24\n    days = int(math.floor(hours / 24))\n\n    entries = [\n        f'{days}d' if days else '',\n        f'{hrs}h' if hours else '',\n        f'{mins}m' if mins else '',\n        f'{sec}s' if sec else '',\n        f'{milli_sec}ms' if milli_sec else '',\n    ]\n    return ':'.join([x for x in entries if x]) or '0s'\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.is_python_info_enabled","title":"<code>is_python_info_enabled()</code>","text":"<p>Return True if the python file location should be displayed.</p> <p>By default this information is not displayed since the stacktrace already provides most of the info. If we need it we can set one of the env var</p> <ul> <li>DEBUG_M_PYTHON</li> <li>DEBUG</li> </ul> <p><code>DEBUG_M_PYTHON</code> is accepted in case we do not want to enable the traceback.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the python file location should be displayed.</p> Source code in <code>m/core/io.py</code> <pre><code>def is_python_info_enabled() -&gt; bool:\n    \"\"\"Return True if the python file location should be displayed.\n\n    By default this information is not displayed since the stacktrace already\n    provides most of the info. If we need it we can set one of the env var\n\n    - DEBUG_M_PYTHON\n    - DEBUG\n\n    `DEBUG_M_PYTHON` is accepted in case we do not want to enable the\n    traceback.\n\n    Returns:\n        True if the python file location should be displayed.\n    \"\"\"\n    debug_python = _is_true('DEBUG_M_PYTHON')\n    debug_mode = _is_true('DEBUG')\n    return debug_python or debug_mode\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.is_traceback_enabled","title":"<code>is_traceback_enabled()</code>","text":"<p>Return True if the stacktrace should be displayed.</p> <p>This is true by default on a CI environment where the env var CI is set to <code>true</code>.</p> <p>We can enable this locally by settings the env vars</p> <ul> <li>DEBUG_M_STACKTRACE</li> <li>DEBUG</li> </ul> <p>The <code>DEBUG_M_STACKTRACE</code> is provided so to only target this particular piece of info and avoid other pieces of code that may be looking at the <code>DEBUG</code> env var from activating.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the stacktrace should be displayed.</p> Source code in <code>m/core/io.py</code> <pre><code>def is_traceback_enabled() -&gt; bool:\n    \"\"\"Return True if the stacktrace should be displayed.\n\n    This is true by default on a CI environment where the env var CI is set\n    to `true`.\n\n    We can enable this locally by settings the env vars\n\n    - DEBUG_M_STACKTRACE\n    - DEBUG\n\n    The `DEBUG_M_STACKTRACE` is provided so to only target this particular\n    piece of info and avoid other pieces of code that may be looking at\n    the `DEBUG` env var from activating.\n\n    Returns:\n        True if the stacktrace should be displayed.\n    \"\"\"\n    debug_stacktrace = _is_true('DEBUG_M_STACKTRACE')\n    debug_mode = _is_true('DEBUG')\n    ci_env = _is_true('CI')\n    return debug_stacktrace or debug_mode or ci_env\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.prompt_choices","title":"<code>prompt_choices(description, choices, as_list=True)</code>","text":"<p>Prompt the user with a description until we get one of the choices.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The prompt to display.</p> required <code>choices</code> <code>Sequence[str]</code> <p>List of accepted choices.</p> required <code>as_list</code> <code>bool</code> <p>If false, it will concat the choices with <code>/</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The string chosen by the user.</p> Source code in <code>m/core/io.py</code> <pre><code>def prompt_choices(\n    description: str,\n    choices: Sequence[str],\n    as_list: bool = True,\n) -&gt; str:\n    \"\"\"Prompt the user with a description until we get one of the choices.\n\n    Args:\n        description: The prompt to display.\n        choices: List of accepted choices.\n        as_list: If false, it will concat the choices with `/`.\n\n    Returns:\n        The string chosen by the user.\n    \"\"\"\n    valid = False\n    dev_input = ''\n    choices_display = choices if as_list else '/'.join(choices)\n    while not valid:\n        logger.prompt(description, {'choices': choices_display})\n        sys.stderr.write('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ')\n        dev_input = input()\n        if dev_input in choices:\n            valid = True\n    return dev_input\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.prompt_next_version","title":"<code>prompt_next_version(version, release_type)</code>","text":"<p>Prompt the developer to select the next version.</p> <p>It displays the possible major, minor and patch versions and prompts the developer to enter one of them. See https://semver.org/.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>The current version.</p> required <code>release_type</code> <code>str</code> <p>If <code>hotfix</code> then it bumps the patch value.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>One of the versions wrapped in a OneOf.</p> Source code in <code>m/core/io.py</code> <pre><code>def prompt_next_version(version: str, release_type: str) -&gt; OneOf[Issue, str]:\n    \"\"\"Prompt the developer to select the next version.\n\n    It displays the possible major, minor and patch versions and prompts the\n    developer to enter one of them. See https://semver.org/.\n\n    Args:\n        version: The current version.\n        release_type: If `hotfix` then it bumps the patch value.\n\n    Returns:\n        One of the versions wrapped in a OneOf.\n    \"\"\"\n    ver = version.split('-')[0]\n    parts = [int(x) for x in ver.split('.')]\n    patch = _ver_str(parts[0], parts[1], parts[2] + 1)\n    if release_type == 'hotfix':\n        return Good(patch)\n\n    minor = _ver_str(parts[0], parts[1] + 1, 0)\n    major = _ver_str(parts[0] + 1, 0, 0)\n    ver = f'{{bold_green}}{version}{{end}}'\n    msg = color(f'Current version is {ver}. Enter one of the following:')\n    return Good(prompt_choices(msg, [minor, major]))\n</code></pre>"},{"location":"api/m/core/io/#m.core.io.renv","title":"<code>renv(key)</code>","text":"<p>Require an environment variable to be defined.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The environment variable required to be defined.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>A <code>OneOf</code> with the value of the environment variable or an issue.</p> Source code in <code>m/core/io.py</code> <pre><code>def renv(key: str) -&gt; OneOf[Issue, str]:\n    \"\"\"Require an environment variable to be defined.\n\n    Args:\n        key: The environment variable required to be defined.\n\n    Returns:\n        A `OneOf` with the value of the environment variable or an issue.\n    \"\"\"\n    env_value = os.environ.get(key)\n    # Value may still be an empty string, checking against None\n    if env_value is not None:\n        return Good(env_value)\n    return issue(f'missing {key} in env')\n</code></pre>"},{"location":"api/m/core/issue/","title":"issue","text":""},{"location":"api/m/core/issue/#m.core.issue.Issue","title":"<code>Issue</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Wrapper to keep track of all exceptions.</p> <p>It provides a 'cause' field so that we may know why an issue was triggered.</p> Source code in <code>m/core/issue.py</code> <pre><code>class Issue(Exception):  # noqa: N818, WPS230 - Intention is not to raise\n    \"\"\"Wrapper to keep track of all exceptions.\n\n    It provides a 'cause' field so that we may know why an issue was\n    triggered.\n    \"\"\"\n\n    show_traceback = True\n    yaml_traceback = True\n\n    message: str\n    description: str | None\n    cause: Exception | None\n    context: object | None\n    include_traceback: bool\n    cause_tb: list[str] | None\n    traceback: list[str] | None\n\n    def __init__(  # noqa: WPS211 - need to initialize the attributes\n        self,\n        message: str,\n        description: str | None = None,\n        cause: Exception | None = None,\n        context: object | None = None,\n        include_traceback: bool = True,\n    ):\n        \"\"\"Create an Issue.\n\n        Args:\n            message: Simple description of the issue.\n            description: More in depth detail on the issue\n            cause: The exception/Issue that is responsible for this instance.\n            context: Dictionary with any useful data related to the issue.\n            include_traceback: If False, it skips computing the traceback.\n        \"\"\"\n        super().__init__()\n        self.message = message\n        self.description = description\n        self.cause = cause\n        if cause and not isinstance(cause, Issue):\n            # https://stackoverflow.com/a/12539332/788553\n            with suppress(BaseException):\n                exc_info = sys.exc_info()\n                fmt_exception = (\n                    traceback.format_exception_only(exc_info[0], exc_info[1])\n                    if exc_info[0] is not None and exc_info[1] is not None\n                    else []\n                )\n                exception_list = [\n                    *traceback.format_tb(exc_info[2]),\n                    *fmt_exception,\n                ]\n                self.cause_tb = [\n                    y\n                    for x in exception_list\n                    for y in x.splitlines()\n                ]\n        self.context = context\n        self.include_traceback = include_traceback\n        self.traceback = None\n        if self.include_traceback:\n            frame = inspect.currentframe()\n            self.traceback = [\n                y\n                for x in traceback.format_stack(frame)[:-1]\n                for y in x.splitlines()\n            ]\n\n    def only_context(self) -&gt; bool:\n        \"\"\"Return true if the issue only offers context.\n\n        In some cases we may create an issue with only a message and a\n        context. This function will let us know of such case so that a\n        log formatter may be able to unwrap the context.\n\n        Returns:\n            True if it is safe to only display the context value on a log.\n        \"\"\"\n        has_context = self.context is not None\n        all_props = (self.description, self.traceback, self.cause)\n        return has_context and not [_ for _ in all_props if _]\n\n    def to_dict(self, show_traceback: bool = True) -&gt; IssueDict:\n        \"\"\"Convert to a ordered dictionary.\n\n        This is done so that each of the properties are written in an expected\n        order.\n\n        Args:\n            show_traceback: If False, it will remove all stacktraces.\n\n        Returns:\n            An `IssueDict` instance.\n        \"\"\"\n        issue_dict = cast(IssueDict, OrderedDict())\n        issue_dict['message'] = self.message\n        if self.description:\n            issue_dict['description'] = self.description\n        if self.context:\n            issue_dict['context'] = self.context\n        if self.include_traceback and self.traceback:\n            issue_dict['traceback'] = self.traceback\n            if Issue.yaml_traceback and isinstance(self.traceback, list):\n                issue_dict['traceback'] = _traceback_to_str(self.traceback)\n        if self.cause:\n            self._handle_cause(issue_dict)\n        if not show_traceback:\n            remove_traceback(issue_dict)\n        return issue_dict\n\n    def to_str(self, show_traceback: bool) -&gt; str:\n        \"\"\"Convert the instance to string.\n\n        Args:\n            show_traceback: If false, it will remove the error traceback.\n\n        Returns:\n            A string representation of the Issue instance.\n        \"\"\"\n        issue_dict = self.to_dict(show_traceback=show_traceback)\n        if Issue.yaml_traceback:\n            return yaml.dumps(issue_dict)\n        return json.dumps(issue_dict, indent=2)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Convert the instance to a string.\n\n        Returns:\n            A string representation of the Issue instance.\n        \"\"\"\n        issue_str = self.to_str(Issue.show_traceback)\n        if Issue.yaml_traceback:\n            return highlight_yaml(issue_str)\n        return highlight_json(issue_str)\n\n    def _handle_cause(self, issue_dict: IssueDict) -&gt; None:\n        if isinstance(self.cause, Issue):\n            issue_dict['cause'] = self.cause.to_dict()\n        else:\n            issue_dict['cause'] = {\n                'message': str(self.cause),\n                'traceback': self.cause_tb,\n            }\n            # I'm clearly assigning to a dict in the above statement...\n            # but it is an object so a dict can be assigned to it but that\n            # does not mean that we can use `pop` on an object. So we have to\n            # help mypy know that know we are dealing with a dict.\n            cause = cast(dict, issue_dict['cause'])\n            if not self.cause_tb:\n                cause.pop('traceback', None)\n            if Issue.yaml_traceback and isinstance(self.cause_tb, list):\n                cause['traceback'] = _traceback_to_str(self.cause_tb)\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.Issue.__init__","title":"<code>__init__(message, description=None, cause=None, context=None, include_traceback=True)</code>","text":"<p>Create an Issue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Simple description of the issue.</p> required <code>description</code> <code>str | None</code> <p>More in depth detail on the issue</p> <code>None</code> <code>cause</code> <code>Exception | None</code> <p>The exception/Issue that is responsible for this instance.</p> <code>None</code> <code>context</code> <code>object | None</code> <p>Dictionary with any useful data related to the issue.</p> <code>None</code> <code>include_traceback</code> <code>bool</code> <p>If False, it skips computing the traceback.</p> <code>True</code> Source code in <code>m/core/issue.py</code> <pre><code>def __init__(  # noqa: WPS211 - need to initialize the attributes\n    self,\n    message: str,\n    description: str | None = None,\n    cause: Exception | None = None,\n    context: object | None = None,\n    include_traceback: bool = True,\n):\n    \"\"\"Create an Issue.\n\n    Args:\n        message: Simple description of the issue.\n        description: More in depth detail on the issue\n        cause: The exception/Issue that is responsible for this instance.\n        context: Dictionary with any useful data related to the issue.\n        include_traceback: If False, it skips computing the traceback.\n    \"\"\"\n    super().__init__()\n    self.message = message\n    self.description = description\n    self.cause = cause\n    if cause and not isinstance(cause, Issue):\n        # https://stackoverflow.com/a/12539332/788553\n        with suppress(BaseException):\n            exc_info = sys.exc_info()\n            fmt_exception = (\n                traceback.format_exception_only(exc_info[0], exc_info[1])\n                if exc_info[0] is not None and exc_info[1] is not None\n                else []\n            )\n            exception_list = [\n                *traceback.format_tb(exc_info[2]),\n                *fmt_exception,\n            ]\n            self.cause_tb = [\n                y\n                for x in exception_list\n                for y in x.splitlines()\n            ]\n    self.context = context\n    self.include_traceback = include_traceback\n    self.traceback = None\n    if self.include_traceback:\n        frame = inspect.currentframe()\n        self.traceback = [\n            y\n            for x in traceback.format_stack(frame)[:-1]\n            for y in x.splitlines()\n        ]\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.Issue.__str__","title":"<code>__str__()</code>","text":"<p>Convert the instance to a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the Issue instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Convert the instance to a string.\n\n    Returns:\n        A string representation of the Issue instance.\n    \"\"\"\n    issue_str = self.to_str(Issue.show_traceback)\n    if Issue.yaml_traceback:\n        return highlight_yaml(issue_str)\n    return highlight_json(issue_str)\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.Issue.only_context","title":"<code>only_context()</code>","text":"<p>Return true if the issue only offers context.</p> <p>In some cases we may create an issue with only a message and a context. This function will let us know of such case so that a log formatter may be able to unwrap the context.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if it is safe to only display the context value on a log.</p> Source code in <code>m/core/issue.py</code> <pre><code>def only_context(self) -&gt; bool:\n    \"\"\"Return true if the issue only offers context.\n\n    In some cases we may create an issue with only a message and a\n    context. This function will let us know of such case so that a\n    log formatter may be able to unwrap the context.\n\n    Returns:\n        True if it is safe to only display the context value on a log.\n    \"\"\"\n    has_context = self.context is not None\n    all_props = (self.description, self.traceback, self.cause)\n    return has_context and not [_ for _ in all_props if _]\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.Issue.to_dict","title":"<code>to_dict(show_traceback=True)</code>","text":"<p>Convert to a ordered dictionary.</p> <p>This is done so that each of the properties are written in an expected order.</p> <p>Parameters:</p> Name Type Description Default <code>show_traceback</code> <code>bool</code> <p>If False, it will remove all stacktraces.</p> <code>True</code> <p>Returns:</p> Type Description <code>IssueDict</code> <p>An <code>IssueDict</code> instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def to_dict(self, show_traceback: bool = True) -&gt; IssueDict:\n    \"\"\"Convert to a ordered dictionary.\n\n    This is done so that each of the properties are written in an expected\n    order.\n\n    Args:\n        show_traceback: If False, it will remove all stacktraces.\n\n    Returns:\n        An `IssueDict` instance.\n    \"\"\"\n    issue_dict = cast(IssueDict, OrderedDict())\n    issue_dict['message'] = self.message\n    if self.description:\n        issue_dict['description'] = self.description\n    if self.context:\n        issue_dict['context'] = self.context\n    if self.include_traceback and self.traceback:\n        issue_dict['traceback'] = self.traceback\n        if Issue.yaml_traceback and isinstance(self.traceback, list):\n            issue_dict['traceback'] = _traceback_to_str(self.traceback)\n    if self.cause:\n        self._handle_cause(issue_dict)\n    if not show_traceback:\n        remove_traceback(issue_dict)\n    return issue_dict\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.Issue.to_str","title":"<code>to_str(show_traceback)</code>","text":"<p>Convert the instance to string.</p> <p>Parameters:</p> Name Type Description Default <code>show_traceback</code> <code>bool</code> <p>If false, it will remove the error traceback.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the Issue instance.</p> Source code in <code>m/core/issue.py</code> <pre><code>def to_str(self, show_traceback: bool) -&gt; str:\n    \"\"\"Convert the instance to string.\n\n    Args:\n        show_traceback: If false, it will remove the error traceback.\n\n    Returns:\n        A string representation of the Issue instance.\n    \"\"\"\n    issue_dict = self.to_dict(show_traceback=show_traceback)\n    if Issue.yaml_traceback:\n        return yaml.dumps(issue_dict)\n    return json.dumps(issue_dict, indent=2)\n</code></pre>"},{"location":"api/m/core/issue/#m.core.issue.remove_traceback","title":"<code>remove_traceback(issue_dict)</code>","text":"<p>Remove the <code>traceback</code> key from a dictionary if it exists.</p> <p>It will recursively remove the <code>traceback</code> from its cause or context.</p> <p>Parameters:</p> Name Type Description Default <code>issue_dict</code> <code>object</code> <p>A dictionary representation of an <code>Issue</code>.</p> required Source code in <code>m/core/issue.py</code> <pre><code>def remove_traceback(issue_dict: object) -&gt; None:\n    \"\"\"Remove the `traceback` key from a dictionary if it exists.\n\n    It will recursively remove the `traceback` from its cause or context.\n\n    Args:\n        issue_dict: A dictionary representation of an `Issue`.\n    \"\"\"\n    if isinstance(issue_dict, dict):\n        if 'traceback' in issue_dict:\n            issue_dict.pop('traceback')\n        cause = issue_dict.get('cause')\n        if cause:\n            remove_traceback(cause)\n        context = issue_dict.get('context')\n        remove_traceback(context)\n        if isinstance(context, list):\n            for context_item in context:\n                remove_traceback(context_item)\n</code></pre>"},{"location":"api/m/core/json/","title":"json","text":""},{"location":"api/m/core/json/#m.core.json.get","title":"<code>get(dict_inst, key_str)</code>","text":"<p>Return the value based on the <code>key_str</code> specified.</p> <p>The following are equivalent::</p> <pre><code>obj['a']['b']['c'] &lt;=&gt; get(obj, 'a.b.c').value\n</code></pre> <p>provided that the keys <code>a</code>, <code>b</code> and <code>c</code> are valid.</p> <p>Parameters:</p> Name Type Description Default <code>dict_inst</code> <code>Any</code> <p>The dictionary instance to query.</p> required <code>key_str</code> <code>str</code> <p>A simple query to fetch from the dict_inst.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>Good</code> if the value we want is available, otherwise it returns a</p> <code>OneOf[Issue, Any]</code> <p><code>Bad</code> with the path that returned <code>None</code>.</p> Source code in <code>m/core/json.py</code> <pre><code>def get(dict_inst: Any, key_str: str) -&gt; OneOf[Issue, Any]:\n    \"\"\"Return the value based on the `key_str` specified.\n\n    The following are equivalent::\n\n        obj['a']['b']['c'] &lt;=&gt; get(obj, 'a.b.c').value\n\n    provided that the keys `a`, `b` and `c` are valid.\n\n    Args:\n        dict_inst: The dictionary instance to query.\n        key_str: A simple query to fetch from the dict_inst.\n\n    Returns:\n        A `Good` if the value we want is available, otherwise it returns a\n        `Bad` with the path that returned `None`.\n    \"\"\"\n    keys = key_str.split('.')\n    current = dict_inst\n    for num, key in enumerate(keys):\n        new_key: Union[str, int] = key\n        with suppress(ValueError):\n            new_key = int(key)\n        try:\n            current = current[new_key]\n        except KeyError:\n            pth = '.'.join(keys[:num + 1])\n            return issue(f'`{pth}` path was not found')\n        except Exception as ex:\n            pth = '.'.join(keys[:num])\n            if not isinstance(current, Mapping):\n                context = pth or current\n                return issue(f'`{context}` is not a dict')\n            # catch unknown issue\n            return issue(  # pragma: no cover\n                f'{pth} resulted in an error',\n                cause=ex,\n            )\n    return Good(current)\n</code></pre>"},{"location":"api/m/core/json/#m.core.json.jsonq","title":"<code>jsonq(dict_inst, separator, *key_str)</code>","text":"<p>Stringify the values obtained from <code>multi_get</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dict_inst</code> <code>Mapping[str, Any]</code> <p>The dictionary instance to query.</p> required <code>separator</code> <code>str</code> <p>A string to use to separate the results.</p> required <code>key_str</code> <code>str</code> <p>The queries to apply.</p> <code>()</code> <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>A string separated by <code>separator</code> if successful or an Issue with</p> <code>OneOf[Issue, str]</code> <p>a description of the problems.</p> Source code in <code>m/core/json.py</code> <pre><code>def jsonq(\n    dict_inst: Map[str, Any],\n    separator: str,\n    *key_str: str,\n) -&gt; OneOf[Issue, str]:\n    \"\"\"Stringify the values obtained from `multi_get`.\n\n    Args:\n        dict_inst: The dictionary instance to query.\n        separator: A string to use to separate the results.\n        key_str: The queries to apply.\n\n    Returns:\n        A string separated by `separator` if successful or an Issue with\n        a description of the problems.\n    \"\"\"\n    return one_of(lambda: [\n        separator.join(map(_to_str, key_values))\n        for key_values in multi_get(dict_inst, *key_str)\n    ])\n</code></pre>"},{"location":"api/m/core/json/#m.core.json.multi_get","title":"<code>multi_get(dict_inst, *keys)</code>","text":"<p>Call <code>get</code> for every input specified by <code>keys</code>.</p> <p>It collects the invalid keys and returns an <code>Issue</code>::</p> <pre><code>multi_get(obj, 'a', 'a.b', 'a.b.c')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dict_inst</code> <code>object</code> <p>The dictionary instance to query.</p> required <code>keys</code> <code>str</code> <p>The queries to apply.</p> <code>()</code> <p>Returns:</p> Type Description <code>OneOf[Issue, list[Any]]</code> <p>A <code>Good</code> with a list of the results if successful, otherwise a <code>Bad</code></p> <code>OneOf[Issue, list[Any]]</code> <p>with the list of failures.</p> Source code in <code>m/core/json.py</code> <pre><code>def multi_get(\n    dict_inst: object,\n    *keys: str,\n) -&gt; OneOf[Issue, list[Any]]:\n    \"\"\"Call `get` for every input specified by `keys`.\n\n    It collects the invalid keys and returns an `Issue`::\n\n        multi_get(obj, 'a', 'a.b', 'a.b.c')\n\n    Args:\n        dict_inst: The dictionary instance to query.\n        keys: The queries to apply.\n\n    Returns:\n        A `Good` with a list of the results if successful, otherwise a `Bad`\n        with the list of failures.\n    \"\"\"\n    result_items = []\n    failures = []\n    for key in keys:\n        res = get(dict_inst, key)\n        if res.is_bad:\n            failures.append(\n                Issue(\n                    message=f'key lookup failure: `{key}`',\n                    cause=res.value,\n                    include_traceback=False,\n                ),\n            )\n        else:\n            result_items.append(res.value)\n    if failures:\n        return issue(\n            'multi_get key retrieval failure',\n            context=[x.to_dict() for x in failures],\n            include_traceback=False,\n        )\n    return Good(result_items)\n</code></pre>"},{"location":"api/m/core/json/#m.core.json.parse_json","title":"<code>parse_json(json_str, error_if_empty=False)</code>","text":"<p>Parse a string as json.</p> <p>Parameters:</p> Name Type Description Default <code>json_str</code> <code>str</code> <p>The string to parse.</p> required <code>error_if_empty</code> <code>bool</code> <p>The json parser may throw an error if <code>True</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>Good</code> containing the parsed contents of the json string.</p> Source code in <code>m/core/json.py</code> <pre><code>def parse_json(\n    json_str: str,\n    error_if_empty: bool = False,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Parse a string as json.\n\n    Args:\n        json_str: The string to parse.\n        error_if_empty: The json parser may throw an error if `True`.\n\n    Returns:\n        A `Good` containing the parsed contents of the json string.\n    \"\"\"\n    empty = '' if error_if_empty else 'null'\n    try:\n        return Good(json.loads(json_str or empty))\n    except Exception as ex:\n        return issue('failed to parse the json data', cause=ex)\n</code></pre>"},{"location":"api/m/core/json/#m.core.json.read_json","title":"<code>read_json(filename, error_if_empty=False)</code>","text":"<p>Read a json object from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | None</code> <p>The filename to read from, if <code>None</code> it reads from stdin.</p> required <code>error_if_empty</code> <code>bool</code> <p>The json parser may throw an error if <code>True</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>Good</code> containing the parsed contents of the json file.</p> Source code in <code>m/core/json.py</code> <pre><code>def read_json(\n    filename: str | None,\n    error_if_empty: bool = False,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Read a json object from a json file.\n\n    Args:\n        filename: The filename to read from, if `None` it reads from stdin.\n        error_if_empty: The json parser may throw an error if `True`.\n\n    Returns:\n        A `Good` containing the parsed contents of the json file.\n    \"\"\"\n    empty: str = '' if error_if_empty else 'null'\n    context = {'filename': filename or 'SYS.STDIN'}\n    return one_of(lambda: [\n        json_data\n        for json_str in rw.read_file(filename)\n        for json_data in parse_json(json_str or empty, error_if_empty)\n    ]).flat_map_bad(hone('failed to read json file', context=context))\n</code></pre>"},{"location":"api/m/core/maybe/","title":"maybe","text":""},{"location":"api/m/core/maybe/#m.core.maybe.maybe","title":"<code>maybe(callback)</code>","text":"<p>Evaluate the callback to return a value.</p> <p>Unlike Typescript, Python does not have optional chaining::</p> <pre><code>https://en.wikipedia.org/wiki/Safe_navigation_operator#Python\n</code></pre> <p>To simulate this we can use this function as follows::</p> <pre><code>ans = maybe(lambda: path.to.prop)  # type: ignore[union-attr]\n</code></pre> <p>It is ok to disable the <code>union-attr</code> mypy check as long as mypy is checking for <code>no-any-return</code>.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[], T]</code> <p>A function return a value.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>The value returned by the function or <code>None</code>.</p> Source code in <code>m/core/maybe.py</code> <pre><code>def maybe(callback: Callable[[], T]) -&gt; T | None:\n    \"\"\"Evaluate the callback to return a value.\n\n    Unlike Typescript, Python does not have optional chaining::\n\n        https://en.wikipedia.org/wiki/Safe_navigation_operator#Python\n\n    To simulate this we can use this function as follows::\n\n        ans = maybe(lambda: path.to.prop)  # type: ignore[union-attr]\n\n    It is ok to disable the `union-attr` mypy check as long as mypy is checking\n    for `no-any-return`.\n\n    Args:\n        callback: A function return a value.\n\n    Returns:\n        The value returned by the function or `None`.\n    \"\"\"\n    try:\n        return callback()\n    except AttributeError:\n        return None\n</code></pre>"},{"location":"api/m/core/maybe/#m.core.maybe.non_null","title":"<code>non_null(inst)</code>","text":"<p>Assert that <code>inst</code> is not <code>None</code>.</p> <p>Implementation taken from::</p> <pre><code>https://github.com/python/typing/issues/645#issuecomment-501057220\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>T | None</code> <p>A possibly null instance.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The same argument with the <code>None</code> type removed.</p> Source code in <code>m/core/maybe.py</code> <pre><code>def non_null(inst: T | None) -&gt; T:\n    \"\"\"Assert that `inst` is not `None`.\n\n    Implementation taken from::\n\n        https://github.com/python/typing/issues/645#issuecomment-501057220\n\n    Args:\n        inst: A possibly null instance.\n\n    Returns:\n        The same argument with the `None` type removed.\n    \"\"\"\n    # The assert statement can go away with the -O flag.\n    assert inst is not None  # noqa: S101\n    return inst\n</code></pre>"},{"location":"api/m/core/one_of/","title":"one_of","text":""},{"location":"api/m/core/one_of/#m.core.one_of.hone","title":"<code>hone(msg, context=None, description=None, include_traceback=True)</code>","text":"<p>Create a function to repackage the issue with a new message and context.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The new message.</p> required <code>context</code> <code>object | None</code> <p>The new context.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>The new description.</p> <code>None</code> <code>include_traceback</code> <code>bool</code> <p>Whether to include the traceback.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[[Issue], OneOf[Issue, Any]]</code> <p>A function that takes an issue and returns a new issue.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def hone(\n    msg: str,\n    context: object | None = None,\n    description: str | None = None,\n    include_traceback: bool = True,\n) -&gt; Callable[[Issue], OneOf[Issue, Any]]:\n    \"\"\"Create a function to repackage the issue with a new message and context.\n\n    Args:\n        msg: The new message.\n        context: The new context.\n        description: The new description.\n        include_traceback: Whether to include the traceback.\n\n    Returns:\n        A function that takes an issue and returns a new issue.\n    \"\"\"\n    return partial(_hone, msg, context, description, include_traceback)\n</code></pre>"},{"location":"api/m/core/one_of/#m.core.one_of.issue","title":"<code>issue(message, description=None, cause=None, context=None, include_traceback=True)</code>","text":"<p>Shortcut to create a Bad OneOf containing an Issue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The issue message.</p> required <code>description</code> <code>str | None</code> <p>Optional description.</p> <code>None</code> <code>cause</code> <code>Exception | None</code> <p>Optional exception that caused the issue.</p> <code>None</code> <code>context</code> <code>object | None</code> <p>Optional dictionary to provide extra information.</p> <code>None</code> <code>include_traceback</code> <code>bool</code> <p>Defaults to true to provide the stack trace.</p> <code>True</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>An instance of an <code>Issue</code>.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def issue(  # noqa: WPS211\n    message: str,\n    description: str | None = None,\n    cause: Exception | None = None,\n    context: object | None = None,\n    include_traceback: bool = True,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Shortcut to create a Bad OneOf containing an Issue.\n\n    Args:\n        message: The issue message.\n        description: Optional description.\n        cause: Optional exception that caused the issue.\n        context: Optional dictionary to provide extra information.\n        include_traceback: Defaults to true to provide the stack trace.\n\n    Returns:\n        An instance of an `Issue`.\n    \"\"\"\n    inst = Issue(message, description, cause, context, include_traceback)\n    return Bad(inst)\n</code></pre>"},{"location":"api/m/core/one_of/#m.core.one_of.non_issue","title":"<code>non_issue(inst)</code>","text":"<p>Obtain the value of the <code>OneOf</code> as if it was a Good value.</p> <p>Warning: This should only be used provided that we know for sure that we are not dealing with a <code>Bad</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>OneOf[Issue, G]</code> <p>A OneOf.</p> required <p>Returns:</p> Type Description <code>G</code> <p>The value stored in the OneOf.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def non_issue(inst: OneOf[Issue, G]) -&gt; G:\n    \"\"\"Obtain the value of the `OneOf` as if it was a Good value.\n\n    Warning: This should only be used provided that we know for sure\n    that we are not dealing with a `Bad` value.\n\n    Args:\n        inst: A OneOf.\n\n    Returns:\n        The value stored in the OneOf.\n    \"\"\"\n    # The assert statement can go away with the -O flag.\n    assert not inst.is_bad  # noqa: S101\n    return cast(G, inst.value)\n</code></pre>"},{"location":"api/m/core/one_of/#m.core.one_of.one_of","title":"<code>one_of(comp)</code>","text":"<p>Handle the \"Good\" value of a <code>OneOf</code>.</p> <p>To be used so that we may iterate over OneOf objects that may raise the <code>StopBadIteration</code> exception.</p> <p>Parameters:</p> Name Type Description Default <code>comp</code> <code>Callable[[], list[G]]</code> <p>A lambda function returning an array with a single value.</p> required <p>Returns:</p> Type Description <code>OneOf[Any, G]</code> <p>A <code>OneOf</code> with the value returned from <code>comp</code>.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def one_of(comp: Callable[[], list[G]]) -&gt; OneOf[Any, G]:\n    \"\"\"Handle the \"Good\" value of a `OneOf`.\n\n    To be used so that we may iterate over OneOf objects that may raise\n    the `StopBadIteration` exception.\n\n    Args:\n        comp: A lambda function returning an array with a single value.\n\n    Returns:\n        A `OneOf` with the value returned from `comp`.\n    \"\"\"\n    res = None\n    try:\n        res = comp()\n    except StopBadIteration as ex:\n        return cast(Bad, ex.bad)\n    except ValidationError as ex:\n        return issue('pydantic validation error', cause=ex)\n    except Exception as ex:\n        return issue('one_of caught exception', cause=ex)\n    if res:\n        return Good(res[0])\n    # LOOK AT ME - you may be here because a mock is not returning a OneOf.\n    return issue('one_of empty response - iteration missing a OneOf')\n</code></pre>"},{"location":"api/m/core/one_of/#m.core.one_of.to_one_of","title":"<code>to_one_of(callback, message, context=None)</code>","text":"<p>Wrap a python call in a <code>OneOf</code>.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[], Any]</code> <p>A lambda function with a simple python statement.</p> required <code>message</code> <code>str</code> <p>An error message in case the statement raises an exception.</p> required <code>context</code> <code>object | None</code> <p>Additional error context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OneOf[Issue, int]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> if the callback raises an error.</p> Source code in <code>m/core/one_of.py</code> <pre><code>def to_one_of(\n    callback: Callable[[], Any],\n    message: str,\n    context: object | None = None,\n) -&gt; OneOf[Issue, int]:\n    \"\"\"Wrap a python call in a `OneOf`.\n\n    Args:\n        callback: A lambda function with a simple python statement.\n        message: An error message in case the statement raises an exception.\n        context: Additional error context.\n\n    Returns:\n        A `OneOf` containing an `Issue` if the callback raises an error.\n    \"\"\"\n    try:\n        callback()\n    except Exception as ex:\n        return issue(message, cause=ex, context=context)\n    return Good(0)\n</code></pre>"},{"location":"api/m/core/rw/","title":"rw","text":""},{"location":"api/m/core/rw/#m.core.rw.assert_file_exists","title":"<code>assert_file_exists(path)</code>","text":"<p>Assert that a file exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, Path]</code> <p>A <code>Good</code> containing the <code>Path</code> if the file exists.</p> Source code in <code>m/core/rw.py</code> <pre><code>def assert_file_exists(path: str) -&gt; OneOf[Issue, Path]:\n    \"\"\"Assert that a file exists.\n\n    Args:\n        path: The path to the file.\n\n    Returns:\n        A `Good` containing the `Path` if the file exists.\n    \"\"\"\n    path_inst = Path(path)\n    if path_inst.exists():\n        return Good(path_inst)\n    return issue('file does not exist', context={'path': path})\n</code></pre>"},{"location":"api/m/core/rw/#m.core.rw.insert_to_file","title":"<code>insert_to_file(filename, start, text, end)</code>","text":"<p>Insert content to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file to insert to.</p> required <code>start</code> <code>str</code> <p>The start delimiter where the insertion will take place.</p> required <code>text</code> <code>str</code> <p>The main content to insert.</p> required <code>end</code> <code>str</code> <p>The end delimiter.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, int]</code> <p>None if successful, else an issue.</p> Source code in <code>m/core/rw.py</code> <pre><code>def insert_to_file(\n    filename: str,\n    start: str,\n    text: str,\n    end: str,\n) -&gt; OneOf[Issue, int]:\n    \"\"\"Insert content to a file.\n\n    Args:\n        filename: The file to insert to.\n        start: The start delimiter where the insertion will take place.\n        text: The main content to insert.\n        end: The end delimiter.\n\n    Returns:\n        None if successful, else an issue.\n    \"\"\"\n    return one_of(lambda: [\n        0\n        for file_content in read_file(filename)\n        for new_content in _insert_to_file(file_content, start, text, end)\n        for _ in write_file(filename, new_content)\n    ])\n</code></pre>"},{"location":"api/m/core/rw/#m.core.rw.read_file","title":"<code>read_file(filename)</code>","text":"<p>FP version of open to read the contents of a file.</p> <p>If <code>None</code> is provided it will attempt to read from <code>sys.stdin</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | None</code> <p>The file path to read.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>A <code>Good</code> containing the contents of the file.</p> Source code in <code>m/core/rw.py</code> <pre><code>def read_file(filename: str | None) -&gt; OneOf[Issue, str]:\n    \"\"\"FP version of open to read the contents of a file.\n\n    If `None` is provided it will attempt to read from `sys.stdin`.\n\n    Args:\n        filename: The file path to read.\n\n    Returns:\n        A `Good` containing the contents of the file.\n    \"\"\"\n    if filename is None:\n        return Good(sys.stdin.read())\n    try:\n        with Path.open(Path(filename), encoding='UTF-8') as fp:\n            return Good(fp.read())\n    except Exception as ex:\n        return issue(\n            'failed to read file',\n            context={'filename': filename},\n            cause=ex,\n        )\n</code></pre>"},{"location":"api/m/core/rw/#m.core.rw.write_file","title":"<code>write_file(filename, text)</code>","text":"<p>FP version of open to write to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file path where contents will be written.</p> required <code>text</code> <code>str</code> <p>The contents of the file.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, int]</code> <p>A <code>Good</code> containing 0 if the file was written.</p> Source code in <code>m/core/rw.py</code> <pre><code>def write_file(filename: str, text: str) -&gt; OneOf[Issue, int]:\n    \"\"\"FP version of open to write to a file.\n\n    Args:\n        filename: The file path where contents will be written.\n        text: The contents of the file.\n\n    Returns:\n        A `Good` containing 0 if the file was written.\n    \"\"\"\n    try:\n        with Path.open(Path(filename), 'w', encoding='UTF-8') as fp:\n            fp.write(text)\n    except Exception as ex:\n        return issue(\n            'failed to write file',\n            context={'filename': filename},\n            cause=ex,\n        )\n    return Good(0)\n</code></pre>"},{"location":"api/m/core/subprocess/","title":"subprocess","text":""},{"location":"api/m/core/subprocess/#m.core.subprocess.eval_cmd","title":"<code>eval_cmd(cmd)</code>","text":"<p>Evaluate a bash command and return its output.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>The shell command to evaluate.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>The output of the command (or an Issue if the command failed).</p> Source code in <code>m/core/subprocess.py</code> <pre><code>def eval_cmd(cmd: str) -&gt; OneOf[Issue, str]:\n    \"\"\"Evaluate a bash command and return its output.\n\n    Args:\n        cmd: The shell command to evaluate.\n\n    Returns:\n        The output of the command (or an Issue if the command failed).\n    \"\"\"\n    command = shlex.split(cmd)\n    try:\n        out = sub.check_output(command, stderr=STDOUT, shell=False).decode()  # noqa: S603,E501\n    except CalledProcessError as ex:\n        out = ex.output.decode()\n        return issue(\n            'command returned a non zero exit code',\n            context={'cmd': cmd, 'output': out},\n        )\n    return Good(out.strip())\n</code></pre>"},{"location":"api/m/core/subprocess/#m.core.subprocess.exec_pnpm","title":"<code>exec_pnpm(pnpm_args)</code>","text":"<p>Execute pnpm with the given arguments.</p> <p>This command will execute the pnpm command in the current working directory.</p> <p>Parameters:</p> Name Type Description Default <code>pnpm_args</code> <code>list[str]</code> <p>The arguments to pass to pnpm.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, None]</code> <p>None if successful.</p> Source code in <code>m/core/subprocess.py</code> <pre><code>def exec_pnpm(pnpm_args: list[str]) -&gt; OneOf[Issue, None]:\n    \"\"\"Execute pnpm with the given arguments.\n\n    This command will execute the pnpm command in the current working directory.\n\n    Args:\n        pnpm_args: The arguments to pass to pnpm.\n\n    Returns:\n        None if successful.\n    \"\"\"\n    # delegating the rest of the work to pnpm\n    exit_code = sub.call(['pnpm', *pnpm_args], shell=False)  # noqa: S603, S607\n    if exit_code:\n        return issue('non_zero_pnpm_exit_code', context={\n            'pnpm_args': pnpm_args,\n            'exit_code': exit_code,\n        })\n    return Good(None)\n</code></pre>"},{"location":"api/m/core/types/","title":"types","text":""},{"location":"api/m/core/yaml/","title":"yaml","text":""},{"location":"api/m/core/yaml/#m.core.yaml.dumps","title":"<code>dumps(py_data, *, sort_keys=True, default_flow_style=False)</code>","text":"<p>Dump data as yaml using the safe_dump method.</p> <p>Parameters:</p> Name Type Description Default <code>py_data</code> <code>Any</code> <p>Any object that may be serialized.</p> required <code>sort_keys</code> <code>bool</code> <p>Whether to sort the keys.</p> <code>True</code> <code>default_flow_style</code> <code>bool | None</code> <p>Whether to use the default flow style.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A yaml serialized string.</p> Source code in <code>m/core/yaml.py</code> <pre><code>def dumps(\n    py_data: Any,\n    *,\n    sort_keys: bool = True,\n    default_flow_style: bool | None = False,\n) -&gt; str:\n    \"\"\"Dump data as yaml using the safe_dump method.\n\n    Args:\n        py_data: Any object that may be serialized.\n        sort_keys: Whether to sort the keys.\n        default_flow_style: Whether to use the default flow style.\n\n    Returns:\n        A yaml serialized string.\n    \"\"\"\n    return yaml.dump(\n        py_data,\n        Dumper=_SafeDumper,\n        sort_keys=sort_keys,\n        default_flow_style=default_flow_style,\n    )\n</code></pre>"},{"location":"api/m/core/yaml_fp/","title":"yaml_fp","text":""},{"location":"api/m/core/yaml_fp/#m.core.yaml_fp.parse_yaml","title":"<code>parse_yaml(yaml_str, error_if_empty=False)</code>","text":"<p>Parse a string as yaml.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_str</code> <code>str</code> <p>The string to parse.</p> required <code>error_if_empty</code> <code>bool</code> <p>The parser may throw an error if <code>True</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>Good</code> containing the parsed contents of the yaml string.</p> Source code in <code>m/core/yaml_fp.py</code> <pre><code>def parse_yaml(\n    yaml_str: str,\n    error_if_empty: bool = False,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Parse a string as yaml.\n\n    Args:\n        yaml_str: The string to parse.\n        error_if_empty: The parser may throw an error if `True`.\n\n    Returns:\n        A `Good` containing the parsed contents of the yaml string.\n    \"\"\"\n    empty = '' if error_if_empty else 'null'\n    try:\n        return Good(yaml.safe_load(yaml_str or empty))\n    except Exception as ex:\n        return issue('failed to parse the yaml data', cause=ex)\n</code></pre>"},{"location":"api/m/core/yaml_fp/#m.core.yaml_fp.read_yson","title":"<code>read_yson(filename, error_if_empty=False)</code>","text":"<p>Read a json object from a json or yaml file.</p> <p>It will choose the parser based on the filename extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to read from, if <code>None</code> it reads from stdin.</p> required <code>error_if_empty</code> <code>bool</code> <p>The json parser may throw an error if <code>True</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A <code>Good</code> containing the parsed contents of the json file.</p> Source code in <code>m/core/yaml_fp.py</code> <pre><code>def read_yson(\n    filename: str,\n    error_if_empty: bool = False,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Read a json object from a json or yaml file.\n\n    It will choose the parser based on the filename extension.\n\n    Args:\n        filename: The filename to read from, if `None` it reads from stdin.\n        error_if_empty: The json parser may throw an error if `True`.\n\n    Returns:\n        A `Good` containing the parsed contents of the json file.\n    \"\"\"\n    empty: str = '' if error_if_empty else 'null'\n    file_map: dict[str, ParserFunction] = {\n        '.yaml': parse_yaml,\n        '.yml': parse_yaml,\n        '.json': parse_json,\n    }\n    ext = Path(filename).suffix\n    parser = file_map.get(ext, parse_json)\n    context = {'filename': filename or 'SYS.STDIN'}\n    return one_of(lambda: [\n        json_data\n        for json_str in rw.read_file(filename)\n        for json_data in parser(json_str or empty, error_if_empty)\n    ]).flat_map_bad(hone(f'failed to read \"{ext}\" file', context=context))\n</code></pre>"},{"location":"api/m/devcontainer/","title":"devcontainer","text":""},{"location":"api/m/devcontainer/bashrc/","title":"bashrc","text":""},{"location":"api/m/devcontainer/env/","title":"env","text":""},{"location":"api/m/devcontainer/env/#m.devcontainer.env.DevcontainerEnvVars","title":"<code>DevcontainerEnvVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Collection of variables required for devcontainer operations.</p> <p>All properties are prefixed with <code>MDC</code> to denote that those are variables generated by <code>M Dev Container</code>.</p> <p>Attributes:</p> Name Type Description <code>mdc_repo</code> <code>str</code> <p>...</p> <code>mdc_workspace</code> <code>str</code> <p>...</p> <code>mdc_pnpm_workspace</code> <code>str</code> <p>...</p> <code>mdc_venv_workspace</code> <code>str</code> <p>...</p> Source code in <code>m/devcontainer/env.py</code> <pre><code>class DevcontainerEnvVars(BaseModel):\n    \"\"\"Collection of variables required for devcontainer operations.\n\n    All properties are prefixed with `MDC` to denote that those are variables\n    generated by `M Dev Container`.\n    \"\"\"\n\n    mdc_repo: str\n    mdc_workspace: str\n    mdc_pnpm_workspace: str\n    mdc_venv_workspace: str\n\n    def to_bash(self: 'DevcontainerEnvVars') -&gt; str:\n        \"\"\"Create a bash code snippet that can be used in a bashrc file.\n\n        Returns:\n            A `.bashrc` code snippet.\n        \"\"\"\n        dict_data = self.model_dump()\n        return '\\n'.join([\n            f\"export {var_name.upper()}='{var_value}'\"\n            for var_name, var_value in dict_data.items()\n        ])\n</code></pre>"},{"location":"api/m/devcontainer/env/#m.devcontainer.env.DevcontainerEnvVars.to_bash","title":"<code>to_bash()</code>","text":"<p>Create a bash code snippet that can be used in a bashrc file.</p> <p>Returns:</p> Type Description <code>str</code> <p>A <code>.bashrc</code> code snippet.</p> Source code in <code>m/devcontainer/env.py</code> <pre><code>def to_bash(self: 'DevcontainerEnvVars') -&gt; str:\n    \"\"\"Create a bash code snippet that can be used in a bashrc file.\n\n    Returns:\n        A `.bashrc` code snippet.\n    \"\"\"\n    dict_data = self.model_dump()\n    return '\\n'.join([\n        f\"export {var_name.upper()}='{var_value}'\"\n        for var_name, var_value in dict_data.items()\n    ])\n</code></pre>"},{"location":"api/m/devcontainer/env/#m.devcontainer.env.MissingEnvVars","title":"<code>MissingEnvVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Container for missing environment variables.</p> <p>Attributes:</p> Name Type Description <code>missing</code> <code>list[str]</code> <p>...</p> <code>defined</code> <code>dict[str, str]</code> <p>...</p> Source code in <code>m/devcontainer/env.py</code> <pre><code>class MissingEnvVars(BaseModel):\n    \"\"\"Container for missing environment variables.\"\"\"\n\n    # list of environment variables that are required but do not exist\n    missing: list[str]\n\n    # environment variables that are defined\n    defined: dict[str, str]\n</code></pre>"},{"location":"api/m/devcontainer/env/#m.devcontainer.env.devcontainer_env_vars","title":"<code>devcontainer_env_vars()</code>","text":"<p>Get the environment variables for a devcontainer.</p> <p>This function is intended to be used in a devcontainer or in a Github runner. It will return the following values::</p> <pre><code>- repo: The repository name.\n- workspace: The path to directory containing the repo files.\n- pnpmWorkspace: The path where pnpm operations should take place.\n- venvWorkspace: The path where venv operations should take place.\n</code></pre> <p>Returns:</p> Type Description <code>DevcontainerEnvVars</code> <p>A dictionary with the values described above.</p> Source code in <code>m/devcontainer/env.py</code> <pre><code>def devcontainer_env_vars() -&gt; DevcontainerEnvVars:\n    \"\"\"Get the environment variables for a devcontainer.\n\n    This function is intended to be used in a devcontainer or in a Github\n    runner. It will return the following values::\n\n        - repo: The repository name.\n        - workspace: The path to directory containing the repo files.\n        - pnpmWorkspace: The path where pnpm operations should take place.\n        - venvWorkspace: The path where venv operations should take place.\n\n    Returns:\n        A dictionary with the values described above.\n    \"\"\"\n    github = os.environ.get('GITHUB_WORKSPACE')\n    container = os.environ.get('CONTAINER_WORKSPACE')\n    workspace = github or container or 'ERROR_UNKNOWN_WORKSPACE'\n    # big assumption here that the name of the repo is reflected in the name\n    # of the containing directory. Trying to avoid having to call `git`.\n    repo_name = workspace.split('/')[-1]\n    pnpm_workspace = f'/opt/pnpm/{repo_name}'\n    venv_workspace = f'/opt/venv/{repo_name}'\n    return DevcontainerEnvVars(\n        mdc_repo=repo_name,\n        mdc_workspace=workspace,\n        mdc_pnpm_workspace=pnpm_workspace,\n        mdc_venv_workspace=venv_workspace,\n    )\n</code></pre>"},{"location":"api/m/devcontainer/env/#m.devcontainer.env.require_env_vars","title":"<code>require_env_vars(env_vars)</code>","text":"<p>Require that the given environment variables are defined.</p> <p>Parameters:</p> Name Type Description Default <code>env_vars</code> <code>list[str]</code> <p>list of environment variables to check.</p> required <p>Returns:</p> Type Description <code>OneOf[MissingEnvVars, None]</code> <p>None if all environment variables are defined, otherwise a</p> <code>OneOf[MissingEnvVars, None]</code> <p>MissingEnvVars instance.</p> Source code in <code>m/devcontainer/env.py</code> <pre><code>def require_env_vars(env_vars: list[str]) -&gt; OneOf[MissingEnvVars, None]:\n    \"\"\"Require that the given environment variables are defined.\n\n    Args:\n        env_vars: list of environment variables to check.\n\n    Returns:\n        None if all environment variables are defined, otherwise a\n        MissingEnvVars instance.\n    \"\"\"\n    missing: list[str] = []\n    defined: dict[str, str] = {}\n    for env_var in env_vars:\n        env_var_value = os.environ.get(env_var)\n        if env_var_value is None:\n            missing.append(env_var)\n        else:\n            defined[env_var] = env_var_value\n    if missing:\n        return Bad(MissingEnvVars(missing=missing, defined=defined))\n    return Good(None)\n</code></pre>"},{"location":"api/m/devcontainer/greet/","title":"greet","text":""},{"location":"api/m/devcontainer/greet/#m.devcontainer.greet.greet","title":"<code>greet(img_name, img_version, changelog_url)</code>","text":"<p>Log an \"info\" message to the console stating that the container is ready.</p> <p>Parameters:</p> Name Type Description Default <code>img_name</code> <code>str</code> <p>The name of the image.</p> required <code>img_version</code> <code>str</code> <p>The version of the image.</p> required <code>changelog_url</code> <code>str | None</code> <p>The URL to the changelog.</p> required Source code in <code>m/devcontainer/greet.py</code> <pre><code>def greet(img_name: str, img_version: str, changelog_url: str | None) -&gt; None:\n    \"\"\"Log an \"info\" message to the console stating that the container is ready.\n\n    Args:\n        img_name: The name of the image.\n        img_version: The version of the image.\n        changelog_url: The URL to the changelog.\n    \"\"\"\n    logger = Logger(__name__)\n    context = {\n        'name': img_name,\n        'version': img_version,\n        'TIP': 'set `DEBUG`/`DEBUG_M_LOGS` to true to display debugging info',\n    }\n    if not img_version.startswith('0.0.0') and changelog_url:\n        context['changelog'] = f'{changelog_url}#{img_version}'\n    logger.info('container_ready', context=context)\n</code></pre>"},{"location":"api/m/devcontainer/pnpm/","title":"pnpm","text":""},{"location":"api/m/devcontainer/pnpm/#m.devcontainer.pnpm.PnpmSetupSummary","title":"<code>PnpmSetupSummary</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Summary of the pnpm setup operation.</p> <p>Attributes:</p> Name Type Description <code>node_modules</code> <code>str</code> <p>...</p> <code>package</code> <code>str</code> <p>...</p> <code>npmrc</code> <code>str</code> <p>...</p> <code>pnpm_lock</code> <code>str | None</code> <p>...</p> Source code in <code>m/devcontainer/pnpm.py</code> <pre><code>class PnpmSetupSummary(BaseModel):\n    \"\"\"Summary of the pnpm setup operation.\"\"\"\n\n    node_modules: str\n    package: str\n    npmrc: str\n    pnpm_lock: str | None\n</code></pre>"},{"location":"api/m/devcontainer/pnpm/#m.devcontainer.pnpm.create_symlink","title":"<code>create_symlink(link, source)</code>","text":"<p>Create a symlink that is linked to a source.</p> <p>This is a destructive operation - if the link exists it will be removed.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>Path</code> <p>The path to the link.</p> required <code>source</code> <code>Path</code> <p>The path to the source.</p> required Source code in <code>m/devcontainer/pnpm.py</code> <pre><code>def create_symlink(link: Path, source: Path) -&gt; None:\n    \"\"\"Create a symlink that is linked to a source.\n\n    This is a destructive operation - if the link exists it will be removed.\n\n    Args:\n        link: The path to the link.\n        source: The path to the source.\n    \"\"\"\n    if link.exists() or link.is_symlink():\n        link.unlink()\n    link.symlink_to(source)\n</code></pre>"},{"location":"api/m/devcontainer/pnpm/#m.devcontainer.pnpm.pnpm_setup","title":"<code>pnpm_setup(work_dir, pnpm_dir)</code>","text":"<p>Create symbolic links to a mounted volume.</p> <p>This is done so that pnpm may take advantage of the cache associated with a single pnpm store. When we execute <code>pnpm install</code> in the devcontainer we want to make sure that other containers may be able to share the pnpm cache. To do this we need all containers to use the same pnpm store.</p> <p>Parameters:</p> Name Type Description Default <code>work_dir</code> <code>str</code> <p>The directory where the project is mounted.</p> required <code>pnpm_dir</code> <code>str</code> <p>The directory where the project will execute pnpm commands.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>A <code>PnpmSetupSummary</code> instance.</p> Source code in <code>m/devcontainer/pnpm.py</code> <pre><code>def pnpm_setup(work_dir: str, pnpm_dir: str) -&gt; Res[None]:\n    \"\"\"Create symbolic links to a mounted volume.\n\n    This is done so that pnpm may take advantage of the cache associated with\n    a single pnpm store. When we execute `pnpm install` in the devcontainer\n    we want to make sure that other containers may be able to share the pnpm\n    cache. To do this we need all containers to use the same pnpm store.\n\n    Args:\n        work_dir: The directory where the project is mounted.\n        pnpm_dir: The directory where the project will execute pnpm commands.\n\n    Returns:\n        A `PnpmSetupSummary` instance.\n    \"\"\"\n    package_res = _setup_package(work_dir, pnpm_dir)\n    if isinstance(package_res, Bad):\n        return Bad(package_res.value)\n    package_summary = package_res.value\n\n    node_modules_res = _setup_node_modules(work_dir, pnpm_dir)\n    if isinstance(node_modules_res, Bad):\n        return Bad(node_modules_res.value)\n    node_modules_summary = node_modules_res.value\n\n    npmrc_res = _setup_npmrc(work_dir, pnpm_dir)\n    if isinstance(npmrc_res, Bad):\n        return Bad(npmrc_res.value)\n    npmrc_summary = npmrc_res.value\n\n    # perform a few checks with the lock file\n    work_lock = Path(work_dir) / 'pnpm-lock.yaml'\n    pnpm_lock_summary = None\n    if not work_lock.exists():\n        pnpm_lock_summary = f'MISSING {work_lock}'\n        logger.warning('pnpm_lock_missing', context={\n            'work_lock': pnpm_lock_summary,\n            SUGGESTION: 'run `pnpm install` to generate the lock file',\n        })\n    if work_lock.is_symlink():\n        pnpm_lock_summary = f'unlinked symlink {work_lock}'\n        work_lock.unlink()\n\n    summary = PnpmSetupSummary(\n        node_modules=node_modules_summary,\n        package=package_summary,\n        npmrc=npmrc_summary,\n        pnpm_lock=pnpm_lock_summary,\n    )\n    logger.debug('pnpm_setup_summary', context=summary.model_dump())\n    return Good(None)\n</code></pre>"},{"location":"api/m/devcontainer/pnpm/#m.devcontainer.pnpm.run_pnpm","title":"<code>run_pnpm(pnpm_args, *, force_cd)</code>","text":"<p>Execute the pnpm command with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>pnpm_args</code> <code>list[str]</code> <p>The arguments to pass to pnpm.</p> required <code>force_cd</code> <code>bool</code> <p>If True, change the working directory to the mounted volume.</p> required <p>Returns:</p> Type Description <code>Res[None]</code> <p>The exit code of the pnpm command.</p> Source code in <code>m/devcontainer/pnpm.py</code> <pre><code>def run_pnpm(pnpm_args: list[str], *, force_cd: bool) -&gt; Res[None]:\n    \"\"\"Execute the pnpm command with the given arguments.\n\n    Args:\n        pnpm_args: The arguments to pass to pnpm.\n        force_cd: If True, change the working directory to the mounted volume.\n\n    Returns:\n        The exit code of the pnpm command.\n    \"\"\"\n    workdir = str(Path.cwd())\n    workspace_res = _get_workspaces(workdir)\n    if isinstance(workspace_res, Bad):\n        return Bad(workspace_res.value)\n\n    workspace, pnpm_workspace = workspace_res.value\n    pnpm_command = pnpm_args[0] if pnpm_args else None\n    is_cd_command = pnpm_command in PNPM_MOUNTED_COMMANDS\n    if not force_cd and (not pnpm_command or not is_cd_command):\n        pnpm_res = sub.exec_pnpm(pnpm_args)\n        if isinstance(pnpm_res, Bad):\n            return pnpm_res\n        return Good(None)\n\n    if not Path(f'{workdir}/package.json').exists():\n        return issue('missing_package_json', context={\n            'workdir': workdir,\n            'warning': 'run pnpm commands in directories with package.json',\n        })\n    pnpm_dir = workdir.replace(workspace, pnpm_workspace, 1)\n    return _pnpm(workdir, pnpm_dir, pnpm_args)\n</code></pre>"},{"location":"api/m/devcontainer/prompter/","title":"prompter","text":""},{"location":"api/m/devcontainer/prompter/#m.devcontainer.prompter.prompter","title":"<code>prompter()</code>","text":"<p>Command line prompter.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string to be displayed in the prompt.</p> Source code in <code>m/devcontainer/prompter.py</code> <pre><code>def prompter() -&gt; str:\n    \"\"\"Command line prompter.\n\n    Returns:\n        The string to be displayed in the prompt.\n    \"\"\"\n    branch_res = git.get_branch()\n    if isinstance(branch_res, Bad):\n        return COL(r'\\[{orange}\\]\\w\\[{end}\\]$ ')\n    return _git_prompter(branch_res.value)\n</code></pre>"},{"location":"api/m/github/","title":"github","text":""},{"location":"api/m/github/api/","title":"api","text":""},{"location":"api/m/github/api/#m.github.api.GithubPullRequest","title":"<code>GithubPullRequest</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Data needed to create a pull request.</p> <p>Attributes:</p> Name Type Description <code>title</code> <code>str</code> <p>...</p> <code>body</code> <code>str</code> <p>...</p> <code>head</code> <code>str</code> <p>...</p> <code>base</code> <code>str</code> <p>...</p> Source code in <code>m/github/api.py</code> <pre><code>class GithubPullRequest(BaseModel):\n    \"\"\"Data needed to create a pull request.\"\"\"\n\n    title: str\n    body: str\n    head: str\n    base: str\n</code></pre>"},{"location":"api/m/github/api/#m.github.api.GithubShaStatus","title":"<code>GithubShaStatus</code>  <code>dataclass</code>","text":"<p>Data needed to create a pull request.</p> Source code in <code>m/github/api.py</code> <pre><code>@dataclass\nclass GithubShaStatus:\n    \"\"\"Data needed to create a pull request.\"\"\"\n\n    sha: str\n    context: str\n    state: str\n    description: str\n    url: Optional[str] = None\n</code></pre>"},{"location":"api/m/github/api/#m.github.api.commit_status","title":"<code>commit_status(token, owner, repo, sha_info)</code>","text":"<p>Set a status for a sha.</p> <p>The valid states are::</p> <ul> <li>pending</li> <li>success</li> <li>failure</li> <li>error</li> </ul> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>sha_info</code> <code>GithubShaStatus</code> <p>An instance of a <code>GithubShaStatus</code>.</p> required <p>Returns:</p> Type Description <code>Res[Any]</code> <p>The response from Github after setting a commit status.</p> Source code in <code>m/github/api.py</code> <pre><code>def commit_status(\n    token: str,\n    owner: str,\n    repo: str,\n    sha_info: GithubShaStatus,\n) -&gt; Res[Any]:\n    \"\"\"Set a status for a sha.\n\n    The valid states are::\n\n    - pending\n    - success\n    - failure\n    - error\n\n    Args:\n        token: A github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        sha_info: An instance of a `GithubShaStatus`.\n\n    Returns:\n        The response from Github after setting a commit status.\n    \"\"\"\n    endpoint = _repos(owner, repo, 'statuses', sha_info.sha)\n    payload = {\n        'context': sha_info.context,\n        'state': sha_info.state,\n        'description': sha_info.description,\n    }\n    if sha_info.url:\n        payload['target_url'] = sha_info.url\n    return request(token, endpoint, HttpMethod.post, payload)\n</code></pre>"},{"location":"api/m/github/api/#m.github.api.create_pr","title":"<code>create_pr(token, owner, repo, pr_info)</code>","text":"<p>Send a payload to create a pull request in github.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>pr_info</code> <code>GithubPullRequest</code> <p>The pull request information.</p> required <p>Returns:</p> Type Description <code>Res[Any]</code> <p>The Github response if successful.</p> Source code in <code>m/github/api.py</code> <pre><code>def create_pr(\n    token: str,\n    owner: str,\n    repo: str,\n    pr_info: GithubPullRequest,\n) -&gt; Res[Any]:\n    \"\"\"Send a payload to create a pull request in github.\n\n    Args:\n        token: A github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        pr_info: The pull request information.\n\n    Returns:\n        The Github response if successful.\n    \"\"\"\n    endpoint = _repos(owner, repo, 'pulls')\n    return request(token, endpoint, HttpMethod.post, pr_info.model_dump())\n</code></pre>"},{"location":"api/m/github/api/#m.github.api.create_release","title":"<code>create_release(token, owner, repo, version, branch=None)</code>","text":"<p>Send a payload to create a release in github.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>version</code> <code>str</code> <p>The version that marks the release.</p> required <code>branch</code> <code>str | None</code> <p>Optional branch to tag, defaults to the default branch.</p> <code>None</code> <p>Returns:</p> Type Description <code>Res[Any]</code> <p>The Github response after a release is created.</p> Source code in <code>m/github/api.py</code> <pre><code>def create_release(\n    token: str,\n    owner: str,\n    repo: str,\n    version: str,\n    branch: str | None = None,\n) -&gt; Res[Any]:\n    \"\"\"Send a payload to create a release in github.\n\n    Args:\n        token: A github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        version: The version that marks the release.\n        branch: Optional branch to tag, defaults to the default branch.\n\n    Returns:\n        The Github response after a release is created.\n    \"\"\"\n    endpoint = _repos(owner, repo, 'releases')\n    base = 'https://github.com'\n    link = f'{base}/{owner}/{repo}/blob/master/CHANGELOG.md#{version}'\n    payload = {\n        'tag_name': version,\n        'name': f'{version}',\n        'body': f'**See [CHANGELOG]({link}).**',\n        'draft': False,\n        'prerelease': False,\n    }\n    if branch:\n        payload['target_commitish'] = branch\n    return request(token, endpoint, HttpMethod.post, payload)\n</code></pre>"},{"location":"api/m/github/api/#m.github.api.merge_pr","title":"<code>merge_pr(token, owner, repo, pr_number, commit_title)</code>","text":"<p>Send a payload to merge a pull request in github.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>pr_number</code> <code>int</code> <p>The number of the pull request.</p> required <code>commit_title</code> <code>str | None</code> <p>An optional commit title to use when merging.</p> required <p>Returns:</p> Type Description <code>Res[Any]</code> <p>The payload provided by Github if successful.</p> Source code in <code>m/github/api.py</code> <pre><code>def merge_pr(\n    token: str,\n    owner: str,\n    repo: str,\n    pr_number: int,\n    commit_title: str | None,\n) -&gt; Res[Any]:\n    \"\"\"Send a payload to merge a pull request in github.\n\n    Args:\n        token: A github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        pr_number: The number of the pull request.\n        commit_title: An optional commit title to use when merging.\n\n    Returns:\n        The payload provided by Github if successful.\n    \"\"\"\n    endpoint = _repos(owner, repo, 'pulls', str(pr_number), 'merge')\n    payload = {'commit_title': commit_title} if commit_title else {}\n    return request(token, endpoint, HttpMethod.put, payload)\n</code></pre>"},{"location":"api/m/github/ci/","title":"ci","text":""},{"location":"api/m/github/ci/#m.github.ci.compare_sha_url","title":"<code>compare_sha_url(owner, repo, prev, nxt)</code>","text":"<p>Generate a url to compare two sha/tags in a github repo.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The repo owner.</p> required <code>repo</code> <code>str</code> <p>The repo name.</p> required <code>prev</code> <code>str</code> <p>The previous sha.</p> required <code>nxt</code> <code>str</code> <p>The next sha.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A url comparing two shas.</p> Source code in <code>m/github/ci.py</code> <pre><code>def compare_sha_url(owner: str, repo: str, prev: str, nxt: str) -&gt; str:\n    \"\"\"Generate a url to compare two sha/tags in a github repo.\n\n    Args:\n        owner: The repo owner.\n        repo: The repo name.\n        prev: The previous sha.\n        nxt: The next sha.\n\n    Returns:\n        A url comparing two shas.\n    \"\"\"\n    return f'https://github.com/{owner}/{repo}/compare/{prev}...{nxt}'\n</code></pre>"},{"location":"api/m/github/ci/#m.github.ci.create_ci_query","title":"<code>create_ci_query(pr_number=None, include_commit=False, include_release=False)</code>","text":"<p>Create github graphql query.</p> <p>The information provided is done via presets.</p> <p>Parameters:</p> Name Type Description Default <code>pr_number</code> <code>int | None</code> <p>If included, it will add pull request information.</p> <code>None</code> <code>include_commit</code> <code>bool</code> <p>If true, include commit information.</p> <code>False</code> <code>include_release</code> <code>bool</code> <p>If true, include release information.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string with the graphql query.</p> Source code in <code>m/github/ci.py</code> <pre><code>def create_ci_query(\n    pr_number: int | None = None,\n    include_commit: bool = False,\n    include_release: bool = False,\n) -&gt; str:\n    \"\"\"Create github graphql query.\n\n    The information provided is done via presets.\n\n    Args:\n        pr_number: If included, it will add pull request information.\n        include_commit: If true, include commit information.\n        include_release: If true, include release information.\n\n    Returns:\n        A string with the graphql query.\n    \"\"\"\n    query_items: list[str] = []\n    query_params: list[str] = ['$owner: String!', '$repo: String!']\n    if include_commit:\n        include_pr = pr_number is None\n        query_items.append(commit_query(include_pr, include_author=True))\n        query_params.append('$sha: String')\n    if pr_number:\n        query_items.append(PULL_REQUEST)\n        query_params.append('$pr: Int!')\n        query_params.append('$fc: Int!')\n    if include_release:\n        query_items.append(LATEST_RELEASE)\n    items_str = '\\n'.join(query_items)\n    params_str = ', '.join(query_params)\n    return f\"\"\"query ({params_str}) {{\n      repository(owner:$owner, name:$repo) {{\n        {items_str}\n      }}\n    }}\"\"\"\n</code></pre>"},{"location":"api/m/github/ci/#m.github.ci.get_build_sha","title":"<code>get_build_sha(token, owner, repo, sha)</code>","text":"<p>Obtain the commit sha in a pull request.</p> <p>When building prs, we are not given the actual sha of the commit.</p> <p>Instead, we get the sha of the merge commit. This will give us the sha that we are looking for.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>sha</code> <code>str</code> <p>The merge sha provided by github.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>The actual sha of the commit.</p> Source code in <code>m/github/ci.py</code> <pre><code>def get_build_sha(\n    token: str,\n    owner: str,\n    repo: str,\n    sha: str,\n) -&gt; OneOf[Issue, str]:\n    \"\"\"Obtain the commit sha in a pull request.\n\n    When building prs, we are not given the actual sha of the commit.\n\n    Instead, we get the sha of the merge commit. This will give us the\n    sha that we are looking for.\n\n    Args:\n        token: A Github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        sha: The merge sha provided by github.\n\n    Returns:\n        The actual sha of the commit.\n    \"\"\"\n    query_params = ['$owner: String!', '$repo: String!', '$sha: String!']\n    params_str = ', '.join(query_params)\n    commit_query_str = commit_query(include_pr=False, include_author=False)\n    query = f\"\"\"query ({params_str}) {{\n      repository(owner:$owner, name:$repo) {{\n        {commit_query_str}\n      }}\n    }}\"\"\"\n    variables = {\n        'owner': owner,\n        'repo': repo,\n        'sha': sha,\n    }\n    return one_of(\n        lambda: [\n            _parse_commit_message(commit_msg, sha)\n            for res in api.graphql(token, query, variables)\n            for commit_msg in get(res, 'repository.commit.message')\n        ],\n    )\n</code></pre>"},{"location":"api/m/github/ci/#m.github.ci.get_ci_run_info","title":"<code>get_ci_run_info(token, commit_info, pr_number, file_count, include_release)</code>","text":"<p>Transform the result from get_raw_ci_run_info to a GithubCiRunInfo.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>commit_info</code> <code>CommitInfo</code> <p>An instance of a commit info.</p> required <code>pr_number</code> <code>int | None</code> <p>An optional pull request number.</p> required <code>file_count</code> <code>int</code> <p>The maximum number of files to report.</p> required <code>include_release</code> <code>bool</code> <p>If true it will provide release information.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, GithubCiRunInfo]</code> <p>If successful, a <code>GithubCiRunInfo</code> instance.</p> Source code in <code>m/github/ci.py</code> <pre><code>def get_ci_run_info(\n    token: str,\n    commit_info: CommitInfo,\n    pr_number: int | None,\n    file_count: int,\n    include_release: bool,\n) -&gt; OneOf[Issue, GithubCiRunInfo]:\n    \"\"\"Transform the result from get_raw_ci_run_info to a GithubCiRunInfo.\n\n    Args:\n        token: A Github PAT.\n        commit_info: An instance of a commit info.\n        pr_number: An optional pull request number.\n        file_count: The maximum number of files to report.\n        include_release: If true it will provide release information.\n\n    Returns:\n        If successful, a `GithubCiRunInfo` instance.\n    \"\"\"\n    raw_res = get_raw_ci_run_info(\n        token,\n        commit_info,\n        pr_number,\n        file_count,\n        include_release,\n    )\n    return one_of(\n        lambda: [\n            GithubCiRunInfo(commit=commit, pull_request=pr, release=release)\n            for raw in raw_res\n            for release in _get_release(raw)\n            for commit in _get_commit(commit_info.owner, commit_info.repo, raw)\n            for pr in _get_pull_request(raw, pr_number)\n        ],\n    )\n</code></pre>"},{"location":"api/m/github/ci/#m.github.ci.get_raw_ci_run_info","title":"<code>get_raw_ci_run_info(token, commit_info, pr_number, file_count, include_release, get_sha=True)</code>","text":"<p>Retrieve the information of the given Github PR.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>commit_info</code> <code>CommitInfo</code> <p>The owner, repo and sha.</p> required <code>pr_number</code> <code>int | None</code> <p>The pull request number.</p> required <code>file_count</code> <code>int</code> <p>The maximum number of files in the pr to retrieve.</p> required <code>include_release</code> <code>bool</code> <p>If true it will provide release information.</p> required <code>get_sha</code> <code>bool</code> <p>If true, it will obtain the actual sha of the commit.</p> <code>True</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>The Github payload with the raw information.</p> Source code in <code>m/github/ci.py</code> <pre><code>def get_raw_ci_run_info(\n    token: str,\n    commit_info: CommitInfo,\n    pr_number: int | None,\n    file_count: int,\n    include_release: bool,\n    get_sha: bool = True,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Retrieve the information of the given Github PR.\n\n    Args:\n        token: A Github PAT.\n        commit_info: The owner, repo and sha.\n        pr_number: The pull request number.\n        file_count:  The maximum number of files in the pr to retrieve.\n        include_release: If true it will provide release information.\n        get_sha: If true, it will obtain the actual sha of the commit.\n\n    Returns:\n        The Github payload with the raw information.\n    \"\"\"\n    query = create_ci_query(\n        pr_number,\n        include_commit=True,\n        include_release=include_release,\n    )\n    owner, repo, sha = [commit_info.owner, commit_info.repo, commit_info.sha]\n    variables = {'owner': owner, 'repo': repo, 'sha': sha, 'fc': file_count}\n    if pr_number:\n        variables['pr'] = pr_number\n    if get_sha:\n        build_sha = get_build_sha(token, owner, repo, sha)\n        if build_sha.is_bad:\n            return build_sha\n        variables['sha'] = non_issue(build_sha)\n    return one_of(lambda: [\n        repo_data\n        for res in api.graphql(token, query, variables)\n        for repo_data in get(res, 'repository')\n    ])\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/","title":"ci_dataclasses","text":""},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.AssociatedPullRequest","title":"<code>AssociatedPullRequest</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Information for commits that are associated with a pull request.</p> <p>Attributes:</p> Name Type Description <code>author</code> <code>Author</code> <p>...</p> <code>merged</code> <code>bool</code> <p>...</p> <code>pr_number</code> <code>int</code> <p>...</p> <code>target_branch</code> <code>str</code> <p>...</p> <code>target_sha</code> <code>str</code> <p>...</p> <code>pr_branch</code> <code>str</code> <p>...</p> <code>pr_sha</code> <code>str</code> <p>...</p> <code>title</code> <code>str</code> <p>...</p> <code>body</code> <code>str</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class AssociatedPullRequest(BaseModel):\n    \"\"\"Information for commits that are associated with a pull request.\"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    author: Author\n    merged: bool\n    pr_number: int\n    target_branch: str\n    target_sha: str\n    pr_branch: str\n    pr_sha: str\n    title: str\n    body: str\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.Author","title":"<code>Author</code>","text":"<p>             Bases: <code>CamelModel</code></p> <p>An object representing a committer.</p> <p>Attributes:</p> Name Type Description <code>login</code> <code>str</code> <p>...</p> <code>avatar_url</code> <code>str | None</code> <p>...</p> <code>email</code> <code>str | None</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class Author(CamelModel):\n    \"\"\"An object representing a committer.\"\"\"\n\n    login: str\n    avatar_url: str | None = None\n    email: str | None = None\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.Commit","title":"<code>Commit</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The git commit info.</p> <p>Attributes:</p> Name Type Description <code>author_login</code> <code>str</code> <p>...</p> <code>short_sha</code> <code>str</code> <p>...</p> <code>sha</code> <code>str</code> <p>...</p> <code>message</code> <code>str</code> <p>...</p> <code>url</code> <code>str</code> <p>...</p> <code>associated_pull_request</code> <code>Optional[AssociatedPullRequest]</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class Commit(BaseModel):\n    \"\"\"The git commit info.\"\"\"\n\n    author_login: str\n    short_sha: str\n    sha: str\n    message: str\n    url: str\n    associated_pull_request: Optional[AssociatedPullRequest] = None\n\n    def get_pr_branch(self) -&gt; str:\n        \"\"\"Find the git branch if commit has an associated pr.\n\n        Returns:\n            The pr branch if the commit has an associated pr or empty\n            string.\n        \"\"\"\n        if not self.associated_pull_request:\n            return ''\n        return self.associated_pull_request.pr_branch\n\n    def is_release(self, release_prefix: str | None) -&gt; bool:\n        \"\"\"Determine if the current commit should create a release.\n\n        Args:\n            release_prefix: The prefix used to flag a release.\n\n        Returns:\n            True if we are dealing with a release branch.\n        \"\"\"\n        if not release_prefix:\n            return False\n        return self.get_pr_branch().startswith(release_prefix)\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.Commit.get_pr_branch","title":"<code>get_pr_branch()</code>","text":"<p>Find the git branch if commit has an associated pr.</p> <p>Returns:</p> Type Description <code>str</code> <p>The pr branch if the commit has an associated pr or empty</p> <code>str</code> <p>string.</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>def get_pr_branch(self) -&gt; str:\n    \"\"\"Find the git branch if commit has an associated pr.\n\n    Returns:\n        The pr branch if the commit has an associated pr or empty\n        string.\n    \"\"\"\n    if not self.associated_pull_request:\n        return ''\n    return self.associated_pull_request.pr_branch\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.Commit.is_release","title":"<code>is_release(release_prefix)</code>","text":"<p>Determine if the current commit should create a release.</p> <p>Parameters:</p> Name Type Description Default <code>release_prefix</code> <code>str | None</code> <p>The prefix used to flag a release.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if we are dealing with a release branch.</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>def is_release(self, release_prefix: str | None) -&gt; bool:\n    \"\"\"Determine if the current commit should create a release.\n\n    Args:\n        release_prefix: The prefix used to flag a release.\n\n    Returns:\n        True if we are dealing with a release branch.\n    \"\"\"\n    if not release_prefix:\n        return False\n    return self.get_pr_branch().startswith(release_prefix)\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.CommitInfo","title":"<code>CommitInfo</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A commit can be tracked with the following properties.</p> <p>Attributes:</p> Name Type Description <code>owner</code> <code>str</code> <p>...</p> <code>repo</code> <code>str</code> <p>...</p> <code>sha</code> <code>str</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class CommitInfo(BaseModel):\n    \"\"\"A commit can be tracked with the following properties.\"\"\"\n\n    owner: str\n    repo: str\n    sha: str\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.GithubCiRunInfo","title":"<code>GithubCiRunInfo</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The main information we need for a ci run.</p> <p>Attributes:</p> Name Type Description <code>commit</code> <code>Commit</code> <p>...</p> <code>pull_request</code> <code>Optional[PullRequest]</code> <p>...</p> <code>release</code> <code>Optional[Release]</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class GithubCiRunInfo(BaseModel):\n    \"\"\"The main information we need for a ci run.\"\"\"\n\n    commit: Commit\n    pull_request: Optional[PullRequest] = None\n    release: Optional[Release] = None\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.PullRequest","title":"<code>PullRequest</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Pull request information.</p> <p>Attributes:</p> Name Type Description <code>author</code> <code>Author</code> <p>...</p> <code>pr_number</code> <code>int</code> <p>...</p> <code>pr_branch</code> <code>str</code> <p>...</p> <code>target_branch</code> <code>str</code> <p>...</p> <code>target_sha</code> <code>str</code> <p>...</p> <code>url</code> <code>str</code> <p>...</p> <code>title</code> <code>str</code> <p>...</p> <code>body</code> <code>str</code> <p>...</p> <code>file_count</code> <code>int</code> <p>...</p> <code>files</code> <code>List[str]</code> <p>...</p> <code>is_draft</code> <code>bool</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class PullRequest(BaseModel):\n    \"\"\"Pull request information.\"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    author: Author\n    pr_number: int\n    pr_branch: str\n    target_branch: str\n    target_sha: str\n    url: str\n    title: str\n    body: str\n    file_count: int\n    files: List[str]\n    is_draft: bool\n\n    def is_release_pr(self, release_prefix: str | None) -&gt; bool:\n        \"\"\"Determine if the pull request is a release pull request.\n\n        Args:\n            release_prefix: The prefix used to flag a release.\n\n        Returns:\n            True if we are dealing with a release branch.\n        \"\"\"\n        if not release_prefix:\n            return False\n        return self.pr_branch.startswith(release_prefix)\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.PullRequest.is_release_pr","title":"<code>is_release_pr(release_prefix)</code>","text":"<p>Determine if the pull request is a release pull request.</p> <p>Parameters:</p> Name Type Description Default <code>release_prefix</code> <code>str | None</code> <p>The prefix used to flag a release.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if we are dealing with a release branch.</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>def is_release_pr(self, release_prefix: str | None) -&gt; bool:\n    \"\"\"Determine if the pull request is a release pull request.\n\n    Args:\n        release_prefix: The prefix used to flag a release.\n\n    Returns:\n        True if we are dealing with a release branch.\n    \"\"\"\n    if not release_prefix:\n        return False\n    return self.pr_branch.startswith(release_prefix)\n</code></pre>"},{"location":"api/m/github/ci_dataclasses/#m.github.ci_dataclasses.Release","title":"<code>Release</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Github release &lt;==&gt; Git tag.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>...</p> <code>tag_name</code> <code>str</code> <p>...</p> <code>published_at</code> <code>str</code> <p>...</p> Source code in <code>m/github/ci_dataclasses.py</code> <pre><code>class Release(BaseModel):\n    \"\"\"Github release &lt;==&gt; Git tag.\"\"\"\n\n    name: str\n    tag_name: str\n    published_at: str\n</code></pre>"},{"location":"api/m/github/ci_graph_queries/","title":"ci_graph_queries","text":""},{"location":"api/m/github/ci_graph_queries/#m.github.ci_graph_queries.commit_query","title":"<code>commit_query(include_pr, include_author)</code>","text":"<p>Build a graphql query for github.</p> <p>The output of this function is meant to go inside the repository field.</p> <p>Parameters:</p> Name Type Description Default <code>include_pr</code> <code>bool</code> <p>If true, it will include pull request information.</p> required <code>include_author</code> <code>bool</code> <p>If true, it will include user information.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A valid graphql query.</p> Source code in <code>m/github/ci_graph_queries.py</code> <pre><code>def commit_query(include_pr: bool, include_author: bool) -&gt; str:\n    \"\"\"Build a graphql query for github.\n\n    The output of this function is meant to go inside the repository\n    field.\n\n    Args:\n        include_pr: If true, it will include pull request information.\n        include_author: If true, it will include user information.\n\n    Returns:\n        A valid graphql query.\n    \"\"\"\n    author = \"\"\"\n      author {\n        name\n        email\n        user {\n          login\n        }\n      }\n      oid\n    \"\"\" if include_author else ''\n    pr = \"\"\"\n      associatedPullRequests(first: 1) {\n        nodes {\n          author {\n            login\n            avatarUrl(size: 50)\n            ... on User {\n              email\n            }\n          }\n          number\n          title\n          body\n          baseRefName\n          baseRefOid\n          headRefName\n          headRefOid\n          merged\n        }\n      }\n    \"\"\" if include_pr else ''\n    return f\"\"\"\n      commit: object(expression: $sha) {{\n        ... on Commit {{\n          message\n          {author}\n          {pr}\n        }}\n      }}\n    \"\"\"\n</code></pre>"},{"location":"api/m/github/cli/","title":"cli","text":""},{"location":"api/m/github/cli/#m.github.cli.get_latest_release","title":"<code>get_latest_release(token, owner, repo)</code>","text":"<p>Retrieve the latest release for a repo.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>The latest release.</p> Source code in <code>m/github/cli.py</code> <pre><code>def get_latest_release(\n    token: str,\n    owner: str,\n    repo: str,\n) -&gt; OneOf[Issue, str]:\n    \"\"\"Retrieve the latest release for a repo.\n\n    Args:\n        token: A Github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n\n    Returns:\n        The latest release.\n    \"\"\"\n    query = \"\"\"query ($owner: String!, $repo: String!) {\n      repository(owner:$owner, name:$repo) {\n         releases(last: 1, orderBy: {field: CREATED_AT, direction: ASC}) {\n            nodes {\n                name\n                tagName\n                publishedAt\n            }\n        }\n      }\n    }\"\"\"\n    variables = {'owner': owner, 'repo': repo}\n    return one_of(\n        lambda: [\n            tag_name\n            for res in graphql(token, query, variables)\n            for releases in get(res, 'repository.releases.nodes')\n            for tag_name in _get_latest_release(releases)\n        ],\n    )\n</code></pre>"},{"location":"api/m/github/cli/#m.github.cli.get_pr_info","title":"<code>get_pr_info(token, owner, repo, pr_number, file_count)</code>","text":"<p>Retrieve the information of the given Github PR.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>pr_number</code> <code>int</code> <p>The pull request number in question.</p> required <code>file_count</code> <code>int</code> <p>The maximum number of files in the pr to retrieve.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>The pull request information.</p> Source code in <code>m/github/cli.py</code> <pre><code>def get_pr_info(\n    token: str,\n    owner: str,\n    repo: str,\n    pr_number: int,\n    file_count: int,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Retrieve the information of the given Github PR.\n\n    Args:\n        token: A Github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        pr_number: The pull request number in question.\n        file_count: The maximum number of files in the pr to retrieve.\n\n    Returns:\n        The pull request information.\n    \"\"\"\n    query = create_ci_query(\n        pr_number,\n        include_commit=False,\n        include_release=False,\n    )\n    variables = {\n        'owner': owner,\n        'repo': repo,\n        'pr': pr_number,\n        'fc': file_count,\n    }\n    return one_of(\n        lambda: [\n            pr_info\n            for res in graphql(token, query, variables)\n            for pr_info in get(res, 'repository.pullRequest')\n        ],\n    )\n</code></pre>"},{"location":"api/m/github/request/","title":"request","text":""},{"location":"api/m/github/request/#m.github.request.request","title":"<code>request(token, endpoint, method=http.HttpMethod.get, dict_data=None)</code>","text":"<p>Make an api request to github.</p> <p>See::</p> <pre><code>- https://docs.github.com/en/rest/overview/resources-in-the-rest-api\n- https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github personal access token.</p> required <code>endpoint</code> <code>str</code> <p>A github api endpoint.</p> required <code>method</code> <code>HttpMethod</code> <p>The http method to use. (default 'GET')</p> <code>get</code> <code>dict_data</code> <code>object | None</code> <p>A payload if the method if <code>POST</code> or <code>GET</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>A response from Github.</p> Source code in <code>m/github/request.py</code> <pre><code>def request(\n    token: str,\n    endpoint: str,\n    method: http.HttpMethod = http.HttpMethod.get,\n    dict_data: object | None = None,\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Make an api request to github.\n\n    See::\n\n        - https://docs.github.com/en/rest/overview/resources-in-the-rest-api\n        - https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps\n\n    Args:\n        token: A github personal access token.\n        endpoint: A github api endpoint.\n        method: The http method to use. (default 'GET')\n        dict_data: A payload if the method if `POST` or `GET`.\n\n    Returns:\n        A response from Github.\n    \"\"\"\n    url = f'https://api.github.com{endpoint}'\n    headers = {'authorization': f'Bearer {token}'}\n    return http.fetch_json(url, headers, method, dict_data)\n</code></pre>"},{"location":"api/m/github/graphql/","title":"graphql","text":""},{"location":"api/m/github/graphql/api/","title":"api","text":""},{"location":"api/m/github/graphql/api/#m.github.graphql.api.graphql","title":"<code>graphql(token, query, variables)</code>","text":"<p>Make a request to Github's graphql API.</p> <p>https://docs.github.com/en/graphql/guides/forming-calls-with-graphql</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A github PAT.</p> required <code>query</code> <code>str</code> <p>A graphql query.</p> required <code>variables</code> <code>Mapping[str, Any]</code> <p>The variables to use in the query.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, Any]</code> <p>The Github response.</p> Source code in <code>m/github/graphql/api.py</code> <pre><code>def graphql(\n    token: str,\n    query: str,\n    variables: Mapping[str, Any],\n) -&gt; OneOf[Issue, Any]:\n    \"\"\"Make a request to Github's graphql API.\n\n    https://docs.github.com/en/graphql/guides/forming-calls-with-graphql\n\n    Args:\n        token: A github PAT.\n        query: A graphql query.\n        variables: The variables to use in the query.\n\n    Returns:\n        The Github response.\n    \"\"\"\n    payload = {'query': query, 'variables': variables or {}}\n    return one_of(\n        lambda: [\n            payload\n            for res in request(token, '/graphql', HttpMethod.post, payload)\n            for payload in _filter_data(res)\n        ],\n    )\n</code></pre>"},{"location":"api/m/github/graphql/enums/","title":"enums","text":""},{"location":"api/m/github/graphql/enums/#m.github.graphql.enums.MergeableState","title":"<code>MergeableState</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Whether or not a PullRequest can be merged.</p> Source code in <code>m/github/graphql/enums.py</code> <pre><code>class MergeableState(str, Enum):  # noqa: WPS600\n    \"\"\"Whether or not a PullRequest can be merged.\"\"\"\n\n    # The pull request cannot be merged due to merge conflicts.\n    conflicting = 'CONFLICTING'\n\n    # The pull request can be merged.\n    mergeable = 'MERGEABLE'\n\n    # The mergeability of the pull request is still being calculated.\n    unknown = 'UNKNOWN'\n</code></pre>"},{"location":"api/m/github/graphql/enums/#m.github.graphql.enums.PullRequestReviewState","title":"<code>PullRequestReviewState</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Possible choices for a pull request review state.</p> Source code in <code>m/github/graphql/enums.py</code> <pre><code>class PullRequestReviewState(str, Enum):  # noqa: WPS600\n    \"\"\"Possible choices for a pull request review state.\"\"\"\n\n    # A review allowing the pull request to merge.\n    approved = 'APPROVED'\n\n    # A review blocking the pull request from merging.\n    changes_requested = 'CHANGES_REQUESTED'\n\n    # An informational review.\n    commented = 'COMMENTED'\n\n    # A review that has been dismissed.\n    dismissed = 'DISMISSED'\n\n    # A review that has not yet been submitted.\n    pending = 'PENDING'\n</code></pre>"},{"location":"api/m/github/graphql/generics/","title":"generics","text":""},{"location":"api/m/github/graphql/generics/#m.github.graphql.generics.WithNodes","title":"<code>WithNodes</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[G_Item]</code></p> <p>An object that may contain nodes.</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>list[G_Item]</code> <p>...</p> Source code in <code>m/github/graphql/generics.py</code> <pre><code>class WithNodes(BaseModel, Generic[G_Item]):\n    \"\"\"An object that may contain nodes.\"\"\"\n\n    nodes: list[G_Item]\n</code></pre>"},{"location":"api/m/github/graphql/generics/#m.github.graphql.generics.identity","title":"<code>identity(x)</code>","text":"<p>Identity function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>G_Item</code> <p>The input</p> required <p>Returns:</p> Type Description <code>G_Item</code> <p>The input value.</p> Source code in <code>m/github/graphql/generics.py</code> <pre><code>def identity(x: G_Item) -&gt; G_Item:\n    \"\"\"Identity function.\n\n    Args:\n        x: The input\n\n    Returns:\n        The input value.\n    \"\"\"\n    return x\n</code></pre>"},{"location":"api/m/github/graphql/queries/","title":"queries","text":""},{"location":"api/m/github/graphql/queries/branch_prs/","title":"branch_prs","text":""},{"location":"api/m/github/graphql/queries/branch_prs/#m.github.graphql.queries.branch_prs.Actor","title":"<code>Actor</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>An object representing a committer.</p> <p>Attributes:</p> Name Type Description <code>login</code> <code>str</code> <p>...</p> Source code in <code>m/github/graphql/queries/branch_prs.py</code> <pre><code>class Actor(BaseModel):\n    \"\"\"An object representing a committer.\"\"\"\n\n    login: str\n</code></pre>"},{"location":"api/m/github/graphql/queries/branch_prs/#m.github.graphql.queries.branch_prs.PullRequest","title":"<code>PullRequest</code>","text":"<p>             Bases: <code>CamelModel</code></p> <p>A repository pull request.</p> <p>Attributes:</p> Name Type Description <code>closed</code> <code>bool</code> <p>...</p> <code>title</code> <code>str</code> <p>...</p> <code>number</code> <code>int</code> <p>...</p> <code>base_ref_name</code> <code>str</code> <p>...</p> <code>mergeable</code> <code>MergeableState</code> <p>...</p> <code>merged</code> <code>bool</code> <p>...</p> <code>author</code> <code>Actor</code> <p>...</p> <code>latest_reviews</code> <code>WithNodes[PullRequestReview]</code> <p>...</p> <code>url</code> <code>str</code> <p>...</p> Source code in <code>m/github/graphql/queries/branch_prs.py</code> <pre><code>class PullRequest(CamelModel):\n    \"\"\"A repository pull request.\"\"\"\n\n    closed: bool\n    title: str\n    number: int\n    base_ref_name: str\n    mergeable: MergeableState\n    merged: bool\n    author: Actor\n    latest_reviews: WithNodes[PullRequestReview]\n    url: str\n</code></pre>"},{"location":"api/m/github/graphql/queries/branch_prs/#m.github.graphql.queries.branch_prs.PullRequestReview","title":"<code>PullRequestReview</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A review object for a given pull request.</p> <p>Attributes:</p> Name Type Description <code>author</code> <code>Actor</code> <p>...</p> <code>body</code> <code>str</code> <p>...</p> <code>state</code> <code>PullRequestReviewState</code> <p>...</p> Source code in <code>m/github/graphql/queries/branch_prs.py</code> <pre><code>class PullRequestReview(BaseModel):\n    \"\"\"A review object for a given pull request.\"\"\"\n\n    author: Actor\n    body: str\n    state: PullRequestReviewState\n</code></pre>"},{"location":"api/m/github/graphql/queries/branch_prs/#m.github.graphql.queries.branch_prs.fetch","title":"<code>fetch(token, owner, repo, branch)</code>","text":"<p>Retrieve the pr information for the specified branch.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A Github PAT.</p> required <code>owner</code> <code>str</code> <p>The owner of the repo.</p> required <code>repo</code> <code>str</code> <p>The name of the repo.</p> required <code>branch</code> <code>str</code> <p>Name of the branch.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, list[PullRequest]]</code> <p>A list of pull requests connected to the branch or an issue.</p> Source code in <code>m/github/graphql/queries/branch_prs.py</code> <pre><code>def fetch(\n    token: str,\n    owner: str,\n    repo: str,\n    branch: str,\n) -&gt; OneOf[Issue, list[PullRequest]]:\n    \"\"\"Retrieve the pr information for the specified branch.\n\n    Args:\n        token: A Github PAT.\n        owner: The owner of the repo.\n        repo: The name of the repo.\n        branch: Name of the branch.\n\n    Returns:\n        A list of pull requests connected to the branch or an issue.\n    \"\"\"\n    return _fetch(\n        lambda raw: TypeAdapter(list[PullRequest]).validate_python(raw),\n        token,\n        owner,\n        repo,\n        branch,\n    )\n</code></pre>"},{"location":"api/m/log/","title":"log","text":""},{"location":"api/m/log/#m.log.EnvVars","title":"<code>EnvVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class to store the values of the environment variables.</p> Source code in <code>m/log/ci_tools/types.py</code> <pre><code>class EnvVars(BaseModel):\n    \"\"\"Class to store the values of the environment variables.\"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    ci_env: bool = False\n    github_token: str = ''\n    server_url: str = ''\n    run_id: str = ''\n    run_number: str = ''\n    run_url: str = ''\n    git_branch: str = ''\n    git_sha: str = ''\n    triggered_by: str = ''\n    triggered_by_email: str = ''\n    triggered_by_user: str = ''\n</code></pre>"},{"location":"api/m/log/#m.log.Logger","title":"<code>Logger</code>","text":"<p>Wrapper for python Logger to enable inserting logs in fp loops.</p> <p>This is also so that we may attach context data for a message.</p> <p>We can access the actual logger by using <code>inst</code>.</p> Source code in <code>m/log/logger.py</code> <pre><code>class Logger:  # noqa: WPS230 - loggers have many attributes\n    \"\"\"Wrapper for python Logger to enable inserting logs in fp loops.\n\n    This is also so that we may attach context data for a message.\n\n    We can access the actual logger by using `inst`.\n    \"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    def __init__(self, name: str):\n        \"\"\"Initialize the Logger.\n\n        Args:\n            name: The name of a logger.\n        \"\"\"\n        self.inst = logging.getLogger(name)\n        self.debug = partial(log_func_wrapper, self.inst.debug)\n        self.info = partial(log_func_wrapper, self.inst.info)  # noqa: WPS110\n        self.warning = partial(log_func_wrapper, self.inst.warning)\n        self.exception = partial(log_func_wrapper, self.inst.exception)\n        self.critical = partial(log_func_wrapper, self.inst.critical)\n        self.log = partial(log_func_wrapper, self.inst.log)\n        self.prompt = partial(\n            log_func_wrapper,\n            cast(PromptLogger, self.inst).prompt,\n        )\n        self.error = partial(log_func_wrapper, self.inst.error)\n\n    def open_block(\n        self,\n        name: str,\n        description: str,\n        stderr: bool = False,\n    ) -&gt; Res[int]:\n        \"\"\"Group log lines.\n\n        Signals the formatter that the next log lines should be placed in a\n        group.\n\n        Args:\n            name: The name of the block to open.\n            description: Not supported.\n            stderr: Force message to be displayed in stderr.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        func = self.inst.error if stderr else self.inst.info\n        func(\n            'OPEN_BLOCK',\n            extra={'open_block': (name, description)},\n            stacklevel=2,\n        )\n        return Good(0)\n\n    def close_block(\n        self,\n        name: str,\n        stderr: bool = False,\n    ) -&gt; Res[int]:\n        \"\"\"Close a group log lines.\n\n        Signals the formatter that the current group of lines should end.\n\n        Args:\n            name: The name of the block to close.\n            stderr: Force message to be displayed in stderr.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        func = self.inst.error if stderr else self.inst.info\n        func(\n            'CLOSE_BLOCK',\n            extra={'close_block': name},\n            stacklevel=2,\n        )\n        return Good(0)\n\n    def error_block(\n        self,\n        msg: str | Message,\n        context: dict | Issue,\n    ) -&gt; Res[int]:\n        \"\"\"Display an error block.\n\n        Args:\n            msg: The error message to display.\n            context: The dict/Issue to display in a block.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        self.error(msg)\n        self.open_block('error', '', stderr=True)\n        self.error('', context)\n        self.close_block('error', stderr=True)\n        return Good(0)\n\n    def waning_block(\n        self,\n        msg: str | Message,\n        context: dict | Issue,\n    ) -&gt; Res[int]:\n        \"\"\"Display a warning block.\n\n        Args:\n            msg: The warning message to display.\n            context: The dict/Issue to display in a block.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        self.warning(msg)\n        self.open_block('warning', '', stderr=True)\n        self.warning('', context)\n        self.close_block('warning', stderr=True)\n        return Good(0)\n</code></pre>"},{"location":"api/m/log/#m.log.Logger.__init__","title":"<code>__init__(name)</code>","text":"<p>Initialize the Logger.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of a logger.</p> required Source code in <code>m/log/logger.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initialize the Logger.\n\n    Args:\n        name: The name of a logger.\n    \"\"\"\n    self.inst = logging.getLogger(name)\n    self.debug = partial(log_func_wrapper, self.inst.debug)\n    self.info = partial(log_func_wrapper, self.inst.info)  # noqa: WPS110\n    self.warning = partial(log_func_wrapper, self.inst.warning)\n    self.exception = partial(log_func_wrapper, self.inst.exception)\n    self.critical = partial(log_func_wrapper, self.inst.critical)\n    self.log = partial(log_func_wrapper, self.inst.log)\n    self.prompt = partial(\n        log_func_wrapper,\n        cast(PromptLogger, self.inst).prompt,\n    )\n    self.error = partial(log_func_wrapper, self.inst.error)\n</code></pre>"},{"location":"api/m/log/#m.log.Logger.close_block","title":"<code>close_block(name, stderr=False)</code>","text":"<p>Close a group log lines.</p> <p>Signals the formatter that the current group of lines should end.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the block to close.</p> required <code>stderr</code> <code>bool</code> <p>Force message to be displayed in stderr.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def close_block(\n    self,\n    name: str,\n    stderr: bool = False,\n) -&gt; Res[int]:\n    \"\"\"Close a group log lines.\n\n    Signals the formatter that the current group of lines should end.\n\n    Args:\n        name: The name of the block to close.\n        stderr: Force message to be displayed in stderr.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    func = self.inst.error if stderr else self.inst.info\n    func(\n        'CLOSE_BLOCK',\n        extra={'close_block': name},\n        stacklevel=2,\n    )\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/#m.log.Logger.error_block","title":"<code>error_block(msg, context)</code>","text":"<p>Display an error block.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str | Message</code> <p>The error message to display.</p> required <code>context</code> <code>dict | Issue</code> <p>The dict/Issue to display in a block.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def error_block(\n    self,\n    msg: str | Message,\n    context: dict | Issue,\n) -&gt; Res[int]:\n    \"\"\"Display an error block.\n\n    Args:\n        msg: The error message to display.\n        context: The dict/Issue to display in a block.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    self.error(msg)\n    self.open_block('error', '', stderr=True)\n    self.error('', context)\n    self.close_block('error', stderr=True)\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/#m.log.Logger.open_block","title":"<code>open_block(name, description, stderr=False)</code>","text":"<p>Group log lines.</p> <p>Signals the formatter that the next log lines should be placed in a group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the block to open.</p> required <code>description</code> <code>str</code> <p>Not supported.</p> required <code>stderr</code> <code>bool</code> <p>Force message to be displayed in stderr.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def open_block(\n    self,\n    name: str,\n    description: str,\n    stderr: bool = False,\n) -&gt; Res[int]:\n    \"\"\"Group log lines.\n\n    Signals the formatter that the next log lines should be placed in a\n    group.\n\n    Args:\n        name: The name of the block to open.\n        description: Not supported.\n        stderr: Force message to be displayed in stderr.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    func = self.inst.error if stderr else self.inst.info\n    func(\n        'OPEN_BLOCK',\n        extra={'open_block': (name, description)},\n        stacklevel=2,\n    )\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/#m.log.Logger.waning_block","title":"<code>waning_block(msg, context)</code>","text":"<p>Display a warning block.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str | Message</code> <p>The warning message to display.</p> required <code>context</code> <code>dict | Issue</code> <p>The dict/Issue to display in a block.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def waning_block(\n    self,\n    msg: str | Message,\n    context: dict | Issue,\n) -&gt; Res[int]:\n    \"\"\"Display a warning block.\n\n    Args:\n        msg: The warning message to display.\n        context: The dict/Issue to display in a block.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    self.warning(msg)\n    self.open_block('warning', '', stderr=True)\n    self.warning('', context)\n    self.close_block('warning', stderr=True)\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/#m.log.Message","title":"<code>Message</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Parameters needed to deliver a warning or error message.</p> Source code in <code>m/log/ci_tools/types.py</code> <pre><code>class Message(BaseModel):\n    \"\"\"Parameters needed to deliver a warning or error message.\"\"\"\n\n    msg: str = Field(description='message to display')\n    title: str | None = Field(default=None, description='custom title')\n    file: str | None = Field(  # noqa: WPS110 - required by Github\n        default=None,\n        description='filename',\n    )\n    line: str | None = Field(\n        default=None,\n        description='line number, starting at 1',\n    )\n    end_line: str | None = Field(default=None, description='end line number')\n    col: str | None = Field(\n        default=None,\n        description='column number, starting at 1',\n    )\n    end_col: str | None = Field(default=None, description='end column number')\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/m/log/#m.log.get_ci_tool","title":"<code>get_ci_tool()</code>","text":"<p>Return the current CI Tool based on the environment variables.</p> <p>Returns:</p> Type Description <code>ProviderModule</code> <p>A <code>ProviderModule</code> instance with methods to provide messages in</p> <code>ProviderModule</code> <p>a CI environment.</p> Source code in <code>m/log/ci_tools/ci_tools.py</code> <pre><code>def get_ci_tool() -&gt; ProviderModule:\n    \"\"\"Return the current CI Tool based on the environment variables.\n\n    Returns:\n        A `ProviderModule` instance with methods to provide messages in\n        a CI environment.\n    \"\"\"\n    env = mio.env\n    if env('GITHUB_ACTIONS'):\n        return gh_tool\n    if env('TC') or env('TEAMCITY'):\n        return tc_tool\n    return local_tool\n</code></pre>"},{"location":"api/m/log/#m.log.logging_config","title":"<code>logging_config(level=None, json_file='')</code>","text":"<p>Apply a configuration to the logs.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | None</code> <p>The logging level, defaults to INFO.</p> <code>None</code> <code>json_file</code> <code>str</code> <p>Optional file name where to store each log record as json.</p> <code>''</code> Source code in <code>m/log/config.py</code> <pre><code>def logging_config(level: int | None = None, json_file: str = '') -&gt; None:\n    \"\"\"Apply a configuration to the logs.\n\n    Args:\n        level: The logging level, defaults to INFO.\n        json_file: Optional file name where to store each log record as json.\n    \"\"\"\n    formatter = CiFormatter()\n    stdout_handler = StdOutHandler(formatter)\n    stderr_handler = StdErrHandler(formatter)\n    all_handlers = [stderr_handler, stdout_handler]\n    if json_file:\n        json_formatter = JsonFormatter()\n        all_handlers.append(JsonFileHandler(json_formatter, json_file))\n\n    debug_logs = mio.env('DEBUG_M_LOGS', 'false') == 'true'\n    default_level = logging.DEBUG if debug_logs else logging.INFO\n    logging_level = level if level is not None else default_level\n    logging.basicConfig(\n        level=logging_level,\n        handlers=all_handlers,\n        force=True,\n    )\n</code></pre>"},{"location":"api/m/log/config/","title":"config","text":""},{"location":"api/m/log/config/#m.log.config.logging_config","title":"<code>logging_config(level=None, json_file='')</code>","text":"<p>Apply a configuration to the logs.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | None</code> <p>The logging level, defaults to INFO.</p> <code>None</code> <code>json_file</code> <code>str</code> <p>Optional file name where to store each log record as json.</p> <code>''</code> Source code in <code>m/log/config.py</code> <pre><code>def logging_config(level: int | None = None, json_file: str = '') -&gt; None:\n    \"\"\"Apply a configuration to the logs.\n\n    Args:\n        level: The logging level, defaults to INFO.\n        json_file: Optional file name where to store each log record as json.\n    \"\"\"\n    formatter = CiFormatter()\n    stdout_handler = StdOutHandler(formatter)\n    stderr_handler = StdErrHandler(formatter)\n    all_handlers = [stderr_handler, stdout_handler]\n    if json_file:\n        json_formatter = JsonFormatter()\n        all_handlers.append(JsonFileHandler(json_formatter, json_file))\n\n    debug_logs = mio.env('DEBUG_M_LOGS', 'false') == 'true'\n    default_level = logging.DEBUG if debug_logs else logging.INFO\n    logging_level = level if level is not None else default_level\n    logging.basicConfig(\n        level=logging_level,\n        handlers=all_handlers,\n        force=True,\n    )\n</code></pre>"},{"location":"api/m/log/formatters/","title":"formatters","text":""},{"location":"api/m/log/formatters/#m.log.formatters.CiFormatter","title":"<code>CiFormatter</code>","text":"<p>             Bases: <code>Formatter</code></p> <p>A formatter that takes into account a CI environment.</p> <p>We can still use</p> Source code in <code>m/log/formatters.py</code> <pre><code>class CiFormatter(logging.Formatter):\n    \"\"\"A formatter that takes into account a CI environment.\n\n    We can still use\n    \"\"\"\n\n    def __init__(\n        self,\n        datefmt: str = '%I:%M:%S %p - %b %d, %Y',  # noqa: WPS323\n    ):\n        \"\"\"Initialize by optionally providing a date formatter.\n\n        See https://docs.python.org/3/library/time.html#time.strftime\n        for more info on how to format the date.\n\n        Args:\n            datefmt: The date format to use.\n        \"\"\"\n        super().__init__(datefmt=datefmt)\n        self.opened_blocks: list[str] = []\n        self.ci_tool = get_ci_tool()\n        self.show_traceback = mio.is_traceback_enabled()\n        self.debug_python = mio.is_python_info_enabled()\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        \"\"\"Format a record as based on the CI environment.\n\n        Args:\n            record: The logRecord to format.\n\n        Returns:\n            A formatted string.\n        \"\"\"\n        msg = self.ci_tool.formatter(\n            self,\n            record,\n            self.show_traceback,\n            self.debug_python,\n        )\n        if self.ci_tool.ci:\n            return msg\n\n        record_dict = record.__dict__\n        open_b = record_dict.get('open_block')\n        close_b = record_dict.get('close_block')\n\n        if open_b:\n            name, _ = open_b\n            self.opened_blocks.append(name)\n        if close_b:\n            while self.opened_blocks and self.opened_blocks[-1] != close_b:\n                self.opened_blocks.pop()\n            if self.opened_blocks:\n                self.opened_blocks.pop()\n\n        if not self.opened_blocks:\n            return msg\n        return textwrap.indent(msg, '  ' * len(self.opened_blocks))\n</code></pre>"},{"location":"api/m/log/formatters/#m.log.formatters.CiFormatter.__init__","title":"<code>__init__(datefmt='%I:%M:%S %p - %b %d, %Y')</code>","text":"<p>Initialize by optionally providing a date formatter.</p> <p>See https://docs.python.org/3/library/time.html#time.strftime for more info on how to format the date.</p> <p>Parameters:</p> Name Type Description Default <code>datefmt</code> <code>str</code> <p>The date format to use.</p> <code>'%I:%M:%S %p - %b %d, %Y'</code> Source code in <code>m/log/formatters.py</code> <pre><code>def __init__(\n    self,\n    datefmt: str = '%I:%M:%S %p - %b %d, %Y',  # noqa: WPS323\n):\n    \"\"\"Initialize by optionally providing a date formatter.\n\n    See https://docs.python.org/3/library/time.html#time.strftime\n    for more info on how to format the date.\n\n    Args:\n        datefmt: The date format to use.\n    \"\"\"\n    super().__init__(datefmt=datefmt)\n    self.opened_blocks: list[str] = []\n    self.ci_tool = get_ci_tool()\n    self.show_traceback = mio.is_traceback_enabled()\n    self.debug_python = mio.is_python_info_enabled()\n</code></pre>"},{"location":"api/m/log/formatters/#m.log.formatters.CiFormatter.format","title":"<code>format(record)</code>","text":"<p>Format a record as based on the CI environment.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The logRecord to format.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/formatters.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"Format a record as based on the CI environment.\n\n    Args:\n        record: The logRecord to format.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    msg = self.ci_tool.formatter(\n        self,\n        record,\n        self.show_traceback,\n        self.debug_python,\n    )\n    if self.ci_tool.ci:\n        return msg\n\n    record_dict = record.__dict__\n    open_b = record_dict.get('open_block')\n    close_b = record_dict.get('close_block')\n\n    if open_b:\n        name, _ = open_b\n        self.opened_blocks.append(name)\n    if close_b:\n        while self.opened_blocks and self.opened_blocks[-1] != close_b:\n            self.opened_blocks.pop()\n        if self.opened_blocks:\n            self.opened_blocks.pop()\n\n    if not self.opened_blocks:\n        return msg\n    return textwrap.indent(msg, '  ' * len(self.opened_blocks))\n</code></pre>"},{"location":"api/m/log/formatters/#m.log.formatters.JsonFormatter","title":"<code>JsonFormatter</code>","text":"<p>             Bases: <code>Formatter</code></p> <p>Format each record as JSON data in one single line.</p> Source code in <code>m/log/formatters.py</code> <pre><code>class JsonFormatter(logging.Formatter):\n    \"\"\"Format each record as JSON data in one single line.\"\"\"\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        \"\"\"Format a record as json.\n\n        Args:\n            record: The logRecord to format.\n\n        Returns:\n            A formatted string.\n        \"\"\"\n        record_dict = record.__dict__\n        context = record_dict.get('context')\n        ci_info = record_dict.get('ci_info', Message(msg=record.msg))\n        replacements = {\n            **record_dict,\n            **ci_info.model_dump(),\n            'asctime': self.formatTime(record, self.datefmt),\n            'context': context,\n        }\n        replacements.pop('ci_info', '')\n        sanitized = {\n            key: non_empty\n            for key, non_empty in replacements.items()\n            if non_empty\n        }\n        return json.dumps(sanitized)\n</code></pre>"},{"location":"api/m/log/formatters/#m.log.formatters.JsonFormatter.format","title":"<code>format(record)</code>","text":"<p>Format a record as json.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The logRecord to format.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/formatters.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"Format a record as json.\n\n    Args:\n        record: The logRecord to format.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    record_dict = record.__dict__\n    context = record_dict.get('context')\n    ci_info = record_dict.get('ci_info', Message(msg=record.msg))\n    replacements = {\n        **record_dict,\n        **ci_info.model_dump(),\n        'asctime': self.formatTime(record, self.datefmt),\n        'context': context,\n    }\n    replacements.pop('ci_info', '')\n    sanitized = {\n        key: non_empty\n        for key, non_empty in replacements.items()\n        if non_empty\n    }\n    return json.dumps(sanitized)\n</code></pre>"},{"location":"api/m/log/handlers/","title":"handlers","text":""},{"location":"api/m/log/handlers/#m.log.handlers.JsonFileHandler","title":"<code>JsonFileHandler</code>","text":"<p>             Bases: <code>FileHandler</code></p> <p>A log handler to output to a file.</p> Source code in <code>m/log/handlers.py</code> <pre><code>class JsonFileHandler(logging.FileHandler):\n    \"\"\"A log handler to output to a file.\"\"\"\n\n    def __init__(self, formatter: logging.Formatter, filename: str):\n        \"\"\"Initialize the handler.\n\n        Args:\n            formatter: The formatter to use with the handler.\n            filename: The file where to store the log recrods.\n        \"\"\"\n        super().__init__(filename, encoding='UTF-8')\n        self.setFormatter(formatter)\n\n    def filter(self, _record: logging.LogRecord) -&gt; bool:\n        \"\"\"Display all records.\n\n        Args:\n            _record: A logging record instance.\n\n        Returns:\n            True\n        \"\"\"\n        return True\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.JsonFileHandler.__init__","title":"<code>__init__(formatter, filename)</code>","text":"<p>Initialize the handler.</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>Formatter</code> <p>The formatter to use with the handler.</p> required <code>filename</code> <code>str</code> <p>The file where to store the log recrods.</p> required Source code in <code>m/log/handlers.py</code> <pre><code>def __init__(self, formatter: logging.Formatter, filename: str):\n    \"\"\"Initialize the handler.\n\n    Args:\n        formatter: The formatter to use with the handler.\n        filename: The file where to store the log recrods.\n    \"\"\"\n    super().__init__(filename, encoding='UTF-8')\n    self.setFormatter(formatter)\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.JsonFileHandler.filter","title":"<code>filter(_record)</code>","text":"<p>Display all records.</p> <p>Parameters:</p> Name Type Description Default <code>_record</code> <code>LogRecord</code> <p>A logging record instance.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True</p> Source code in <code>m/log/handlers.py</code> <pre><code>def filter(self, _record: logging.LogRecord) -&gt; bool:\n    \"\"\"Display all records.\n\n    Args:\n        _record: A logging record instance.\n\n    Returns:\n        True\n    \"\"\"\n    return True\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdErrHandler","title":"<code>StdErrHandler</code>","text":"<p>             Bases: <code>StreamHandler</code></p> <p>A log handler to print to stderr.</p> Source code in <code>m/log/handlers.py</code> <pre><code>class StdErrHandler(logging.StreamHandler):\n    \"\"\"A log handler to print to stderr.\"\"\"\n\n    def __init__(self, formatter: logging.Formatter):\n        \"\"\"Initialize the handler.\n\n        Args:\n            formatter: The formatter to use with the handler.\n        \"\"\"\n        super().__init__(sys.stderr)\n        self.setFormatter(formatter)\n\n    def filter(self, record: logging.LogRecord) -&gt; bool:\n        \"\"\"Only display warnings or error records.\n\n        Args:\n            record: A logging record instance.\n\n        Returns:\n            True if the record is a warning or error.\n        \"\"\"\n        return record.levelno &gt;= logging.WARNING\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdErrHandler.__init__","title":"<code>__init__(formatter)</code>","text":"<p>Initialize the handler.</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>Formatter</code> <p>The formatter to use with the handler.</p> required Source code in <code>m/log/handlers.py</code> <pre><code>def __init__(self, formatter: logging.Formatter):\n    \"\"\"Initialize the handler.\n\n    Args:\n        formatter: The formatter to use with the handler.\n    \"\"\"\n    super().__init__(sys.stderr)\n    self.setFormatter(formatter)\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdErrHandler.filter","title":"<code>filter(record)</code>","text":"<p>Only display warnings or error records.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>A logging record instance.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the record is a warning or error.</p> Source code in <code>m/log/handlers.py</code> <pre><code>def filter(self, record: logging.LogRecord) -&gt; bool:\n    \"\"\"Only display warnings or error records.\n\n    Args:\n        record: A logging record instance.\n\n    Returns:\n        True if the record is a warning or error.\n    \"\"\"\n    return record.levelno &gt;= logging.WARNING\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdOutHandler","title":"<code>StdOutHandler</code>","text":"<p>             Bases: <code>StreamHandler</code></p> <p>A log handler to print to stdout.</p> Source code in <code>m/log/handlers.py</code> <pre><code>class StdOutHandler(logging.StreamHandler):\n    \"\"\"A log handler to print to stdout.\"\"\"\n\n    def __init__(self, formatter: logging.Formatter):\n        \"\"\"Initialize the handler.\n\n        Args:\n            formatter: The formatter to use with the handler.\n        \"\"\"\n        super().__init__(sys.stdout)\n        self.setFormatter(formatter)\n\n    def filter(self, record: logging.LogRecord) -&gt; bool:\n        \"\"\"Display non-warnings and non-error records.\n\n        Args:\n            record: A logging record instance.\n\n        Returns:\n            True if the record is not a warning or error.\n        \"\"\"\n        return record.levelno &lt; logging.WARNING\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdOutHandler.__init__","title":"<code>__init__(formatter)</code>","text":"<p>Initialize the handler.</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>Formatter</code> <p>The formatter to use with the handler.</p> required Source code in <code>m/log/handlers.py</code> <pre><code>def __init__(self, formatter: logging.Formatter):\n    \"\"\"Initialize the handler.\n\n    Args:\n        formatter: The formatter to use with the handler.\n    \"\"\"\n    super().__init__(sys.stdout)\n    self.setFormatter(formatter)\n</code></pre>"},{"location":"api/m/log/handlers/#m.log.handlers.StdOutHandler.filter","title":"<code>filter(record)</code>","text":"<p>Display non-warnings and non-error records.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>A logging record instance.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the record is not a warning or error.</p> Source code in <code>m/log/handlers.py</code> <pre><code>def filter(self, record: logging.LogRecord) -&gt; bool:\n    \"\"\"Display non-warnings and non-error records.\n\n    Args:\n        record: A logging record instance.\n\n    Returns:\n        True if the record is not a warning or error.\n    \"\"\"\n    return record.levelno &lt; logging.WARNING\n</code></pre>"},{"location":"api/m/log/logger/","title":"logger","text":""},{"location":"api/m/log/logger/#m.log.logger.Logger","title":"<code>Logger</code>","text":"<p>Wrapper for python Logger to enable inserting logs in fp loops.</p> <p>This is also so that we may attach context data for a message.</p> <p>We can access the actual logger by using <code>inst</code>.</p> Source code in <code>m/log/logger.py</code> <pre><code>class Logger:  # noqa: WPS230 - loggers have many attributes\n    \"\"\"Wrapper for python Logger to enable inserting logs in fp loops.\n\n    This is also so that we may attach context data for a message.\n\n    We can access the actual logger by using `inst`.\n    \"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    def __init__(self, name: str):\n        \"\"\"Initialize the Logger.\n\n        Args:\n            name: The name of a logger.\n        \"\"\"\n        self.inst = logging.getLogger(name)\n        self.debug = partial(log_func_wrapper, self.inst.debug)\n        self.info = partial(log_func_wrapper, self.inst.info)  # noqa: WPS110\n        self.warning = partial(log_func_wrapper, self.inst.warning)\n        self.exception = partial(log_func_wrapper, self.inst.exception)\n        self.critical = partial(log_func_wrapper, self.inst.critical)\n        self.log = partial(log_func_wrapper, self.inst.log)\n        self.prompt = partial(\n            log_func_wrapper,\n            cast(PromptLogger, self.inst).prompt,\n        )\n        self.error = partial(log_func_wrapper, self.inst.error)\n\n    def open_block(\n        self,\n        name: str,\n        description: str,\n        stderr: bool = False,\n    ) -&gt; Res[int]:\n        \"\"\"Group log lines.\n\n        Signals the formatter that the next log lines should be placed in a\n        group.\n\n        Args:\n            name: The name of the block to open.\n            description: Not supported.\n            stderr: Force message to be displayed in stderr.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        func = self.inst.error if stderr else self.inst.info\n        func(\n            'OPEN_BLOCK',\n            extra={'open_block': (name, description)},\n            stacklevel=2,\n        )\n        return Good(0)\n\n    def close_block(\n        self,\n        name: str,\n        stderr: bool = False,\n    ) -&gt; Res[int]:\n        \"\"\"Close a group log lines.\n\n        Signals the formatter that the current group of lines should end.\n\n        Args:\n            name: The name of the block to close.\n            stderr: Force message to be displayed in stderr.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        func = self.inst.error if stderr else self.inst.info\n        func(\n            'CLOSE_BLOCK',\n            extra={'close_block': name},\n            stacklevel=2,\n        )\n        return Good(0)\n\n    def error_block(\n        self,\n        msg: str | Message,\n        context: dict | Issue,\n    ) -&gt; Res[int]:\n        \"\"\"Display an error block.\n\n        Args:\n            msg: The error message to display.\n            context: The dict/Issue to display in a block.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        self.error(msg)\n        self.open_block('error', '', stderr=True)\n        self.error('', context)\n        self.close_block('error', stderr=True)\n        return Good(0)\n\n    def waning_block(\n        self,\n        msg: str | Message,\n        context: dict | Issue,\n    ) -&gt; Res[int]:\n        \"\"\"Display a warning block.\n\n        Args:\n            msg: The warning message to display.\n            context: The dict/Issue to display in a block.\n\n        Returns:\n            A OneOf containing 0 to make it easier to call in fp for loops.\n        \"\"\"\n        self.warning(msg)\n        self.open_block('warning', '', stderr=True)\n        self.warning('', context)\n        self.close_block('warning', stderr=True)\n        return Good(0)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.Logger.__init__","title":"<code>__init__(name)</code>","text":"<p>Initialize the Logger.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of a logger.</p> required Source code in <code>m/log/logger.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initialize the Logger.\n\n    Args:\n        name: The name of a logger.\n    \"\"\"\n    self.inst = logging.getLogger(name)\n    self.debug = partial(log_func_wrapper, self.inst.debug)\n    self.info = partial(log_func_wrapper, self.inst.info)  # noqa: WPS110\n    self.warning = partial(log_func_wrapper, self.inst.warning)\n    self.exception = partial(log_func_wrapper, self.inst.exception)\n    self.critical = partial(log_func_wrapper, self.inst.critical)\n    self.log = partial(log_func_wrapper, self.inst.log)\n    self.prompt = partial(\n        log_func_wrapper,\n        cast(PromptLogger, self.inst).prompt,\n    )\n    self.error = partial(log_func_wrapper, self.inst.error)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.Logger.close_block","title":"<code>close_block(name, stderr=False)</code>","text":"<p>Close a group log lines.</p> <p>Signals the formatter that the current group of lines should end.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the block to close.</p> required <code>stderr</code> <code>bool</code> <p>Force message to be displayed in stderr.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def close_block(\n    self,\n    name: str,\n    stderr: bool = False,\n) -&gt; Res[int]:\n    \"\"\"Close a group log lines.\n\n    Signals the formatter that the current group of lines should end.\n\n    Args:\n        name: The name of the block to close.\n        stderr: Force message to be displayed in stderr.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    func = self.inst.error if stderr else self.inst.info\n    func(\n        'CLOSE_BLOCK',\n        extra={'close_block': name},\n        stacklevel=2,\n    )\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.Logger.error_block","title":"<code>error_block(msg, context)</code>","text":"<p>Display an error block.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str | Message</code> <p>The error message to display.</p> required <code>context</code> <code>dict | Issue</code> <p>The dict/Issue to display in a block.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def error_block(\n    self,\n    msg: str | Message,\n    context: dict | Issue,\n) -&gt; Res[int]:\n    \"\"\"Display an error block.\n\n    Args:\n        msg: The error message to display.\n        context: The dict/Issue to display in a block.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    self.error(msg)\n    self.open_block('error', '', stderr=True)\n    self.error('', context)\n    self.close_block('error', stderr=True)\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.Logger.open_block","title":"<code>open_block(name, description, stderr=False)</code>","text":"<p>Group log lines.</p> <p>Signals the formatter that the next log lines should be placed in a group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the block to open.</p> required <code>description</code> <code>str</code> <p>Not supported.</p> required <code>stderr</code> <code>bool</code> <p>Force message to be displayed in stderr.</p> <code>False</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def open_block(\n    self,\n    name: str,\n    description: str,\n    stderr: bool = False,\n) -&gt; Res[int]:\n    \"\"\"Group log lines.\n\n    Signals the formatter that the next log lines should be placed in a\n    group.\n\n    Args:\n        name: The name of the block to open.\n        description: Not supported.\n        stderr: Force message to be displayed in stderr.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    func = self.inst.error if stderr else self.inst.info\n    func(\n        'OPEN_BLOCK',\n        extra={'open_block': (name, description)},\n        stacklevel=2,\n    )\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.Logger.waning_block","title":"<code>waning_block(msg, context)</code>","text":"<p>Display a warning block.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str | Message</code> <p>The warning message to display.</p> required <code>context</code> <code>dict | Issue</code> <p>The dict/Issue to display in a block.</p> required <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> Source code in <code>m/log/logger.py</code> <pre><code>def waning_block(\n    self,\n    msg: str | Message,\n    context: dict | Issue,\n) -&gt; Res[int]:\n    \"\"\"Display a warning block.\n\n    Args:\n        msg: The warning message to display.\n        context: The dict/Issue to display in a block.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n    \"\"\"\n    self.warning(msg)\n    self.open_block('warning', '', stderr=True)\n    self.warning('', context)\n    self.close_block('warning', stderr=True)\n    return Good(0)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.PromptLogger","title":"<code>PromptLogger</code>","text":"<p>             Bases: <code>Logger</code></p> <p>Adding a prompt level to the logger.</p> Source code in <code>m/log/logger.py</code> <pre><code>class PromptLogger(logging.Logger):\n    \"\"\"Adding a prompt level to the logger.\"\"\"\n\n    def __init__(self, name: str, level: int = logging.NOTSET):\n        \"\"\"Override the Logger init function.\n\n        Args:\n            name: Loggers name.\n            level: An optional level.\n        \"\"\"\n        super().__init__(name, level)\n        logging.addLevelName(PROMPT, 'PROMPT')\n\n    def prompt(self, msg: str, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Log 'msg % args' with severity 'PROMPT'.\n\n        Args:\n            msg: The message to log\n            args: arguments to use in the message replacement.\n            kwargs: The keywords arguments to provide extra information.\n        \"\"\"\n        if self.isEnabledFor(PROMPT):\n            self._log(PROMPT, msg, args, **kwargs)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.PromptLogger.__init__","title":"<code>__init__(name, level=logging.NOTSET)</code>","text":"<p>Override the Logger init function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Loggers name.</p> required <code>level</code> <code>int</code> <p>An optional level.</p> <code>NOTSET</code> Source code in <code>m/log/logger.py</code> <pre><code>def __init__(self, name: str, level: int = logging.NOTSET):\n    \"\"\"Override the Logger init function.\n\n    Args:\n        name: Loggers name.\n        level: An optional level.\n    \"\"\"\n    super().__init__(name, level)\n    logging.addLevelName(PROMPT, 'PROMPT')\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.PromptLogger.prompt","title":"<code>prompt(msg, *args, **kwargs)</code>","text":"<p>Log 'msg % args' with severity 'PROMPT'.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log</p> required <code>args</code> <code>Any</code> <p>arguments to use in the message replacement.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keywords arguments to provide extra information.</p> <code>{}</code> Source code in <code>m/log/logger.py</code> <pre><code>def prompt(self, msg: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Log 'msg % args' with severity 'PROMPT'.\n\n    Args:\n        msg: The message to log\n        args: arguments to use in the message replacement.\n        kwargs: The keywords arguments to provide extra information.\n    \"\"\"\n    if self.isEnabledFor(PROMPT):\n        self._log(PROMPT, msg, args, **kwargs)\n</code></pre>"},{"location":"api/m/log/logger/#m.log.logger.log_func_wrapper","title":"<code>log_func_wrapper(func, msg, context=None, exit_code=0)</code>","text":"<p>Call a logger function with a message and log data.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A logger function (logger.info)</p> required <code>msg</code> <code>str | Message</code> <p>A string or Message containing information about the log.</p> required <code>context</code> <code>dict | Issue | None</code> <p>Data describing the log entry.</p> <code>None</code> <code>exit_code</code> <code>int</code> <p>Used in cli context to force an exit. Default to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Res[int]</code> <p>A OneOf containing 0 to make it easier to call in fp for loops.</p> <code>Res[int]</code> <p>May be overwritten when signaling an error.</p> Source code in <code>m/log/logger.py</code> <pre><code>def log_func_wrapper(\n    func: Callable,\n    msg: str | Message,\n    context: dict | Issue | None = None,\n    exit_code: int = 0,\n) -&gt; Res[int]:\n    \"\"\"Call a logger function with a message and log data.\n\n    Args:\n        func: A logger function (logger.info)\n        msg: A string or Message containing information about the log.\n        context: Data describing the log entry.\n        exit_code: Used in cli context to force an exit. Default to 0.\n\n    Returns:\n        A OneOf containing 0 to make it easier to call in fp for loops.\n        May be overwritten when signaling an error.\n    \"\"\"\n    if isinstance(msg, str):\n        func(msg, extra={'context': context}, stacklevel=2)\n    else:\n        func(\n            msg.msg,\n            extra={'context': context, 'ci_info': msg},\n            stacklevel=2,\n        )\n    return Good(exit_code)\n</code></pre>"},{"location":"api/m/log/misc/","title":"misc","text":""},{"location":"api/m/log/misc/#m.log.misc.default_record_fmt","title":"<code>default_record_fmt(record, asctime, after_time, after_msg)</code>","text":"<p>Format a log record.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>A log record.</p> required <code>asctime</code> <code>str</code> <p>The string representing the time of creation.</p> required <code>after_time</code> <code>str</code> <p>A string that will be placed after the time.</p> required <code>after_msg</code> <code>str</code> <p>A string to be placed after the main message.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/misc.py</code> <pre><code>def default_record_fmt(\n    record: logging.LogRecord,\n    asctime: str,\n    after_time: str,\n    after_msg: str,\n) -&gt; str:\n    \"\"\"Format a log record.\n\n    Args:\n        record: A log record.\n        asctime: The string representing the time of creation.\n        after_time: A string that will be placed after the time.\n        after_msg: A string to be placed after the main message.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    level_color = {\n        logging.DEBUG: 'green',\n        logging.INFO: 'blue',\n        logging.WARNING: 'yellow',\n        PROMPT: 'bold_blue',\n        logging.ERROR: 'red',\n        logging.CRITICAL: 'bold_red',\n    }.get(record.levelno, 'gray')\n    fmt_time = color(f'{{gray}}[{asctime}]{{end}}') if asctime else ''\n    fmt_level = color(f'{{{level_color}}}[{record.levelname}]{{end}}')\n    prefix = f'{fmt_level} {fmt_time}{after_time}'.rstrip()\n    record_msg = record.msg\n    if level_color != 'blue':\n        record_msg = color(f'{{{level_color}}}{record_msg}{{end}}')\n    return f'{prefix}: {record_msg}{after_msg}'\n</code></pre>"},{"location":"api/m/log/misc/#m.log.misc.format_context","title":"<code>format_context(record, indent, show_traceback)</code>","text":"<p>Extract the context from a log record.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record instance.</p> required <code>indent</code> <code>int</code> <p>The level of indentation to apply to the string.</p> required <code>show_traceback</code> <code>bool</code> <p>Attempts to display the traceback if it exists.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string with leading new line of the context associated with a log</p> <code>str</code> <p>record.</p> Source code in <code>m/log/misc.py</code> <pre><code>def format_context(\n    record: logging.LogRecord,\n    indent: int,\n    show_traceback: bool,\n) -&gt; str:\n    \"\"\"Extract the context from a log record.\n\n    Args:\n        record: The log record instance.\n        indent: The level of indentation to apply to the string.\n        show_traceback: Attempts to display the traceback if it exists.\n\n    Returns:\n        A string with leading new line of the context associated with a log\n        record.\n    \"\"\"\n    context = record.__dict__.get('context')\n    data_dict = None\n    as_yaml = Issue.yaml_traceback\n    if isinstance(context, Issue):\n        data_dict = cast(dict, context.to_dict(show_traceback=show_traceback))\n        if context.only_context():\n            data_dict = data_dict['context']\n    else:\n        data_dict = context\n    return (\n        indent_payload(indent, data_dict, as_yaml=as_yaml)\n        if data_dict\n        else ''\n    )\n</code></pre>"},{"location":"api/m/log/misc/#m.log.misc.format_location","title":"<code>format_location(parts, default_color='aqua')</code>","text":"<p>Join a list of possible defined strings.</p> <p>Parameters:</p> Name Type Description Default <code>parts</code> <code>list[str | None]</code> <p>A list of possibly defined strings.</p> required <code>default_color</code> <code>str</code> <p>The color to use for the string.</p> <code>'aqua'</code> <p>Returns:</p> Type Description <code>str</code> <p>A string with the location or an empty string.</p> Source code in <code>m/log/misc.py</code> <pre><code>def format_location(\n    parts: list[str | None],\n    default_color: str = 'aqua',\n) -&gt; str:\n    \"\"\"Join a list of possible defined strings.\n\n    Args:\n        parts: A list of possibly defined strings.\n        default_color: The color to use for the string.\n\n    Returns:\n        A string with the location or an empty string.\n    \"\"\"\n    loc = ':'.join([x for x in parts if x])\n    return color(f'{{{default_color}}}[{loc}]{{end}}') if loc else ''\n</code></pre>"},{"location":"api/m/log/misc/#m.log.misc.indent_payload","title":"<code>indent_payload(indent, payload, prepend_new_line=True, as_yaml=True)</code>","text":"<p>Stringify a dictionary as JSON and indent it.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>The number of spaces to indent.</p> required <code>payload</code> <code>dict</code> <p>The data to stringify and indent.</p> required <code>prepend_new_line</code> <code>bool</code> <p>Prepend a new line to the payload if <code>True</code>.</p> <code>True</code> <code>as_yaml</code> <code>bool</code> <p>Dump the payload in yaml.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>An indented payload.</p> Source code in <code>m/log/misc.py</code> <pre><code>def indent_payload(\n    indent: int,\n    payload: dict,\n    prepend_new_line: bool = True,\n    as_yaml: bool = True,\n) -&gt; str:\n    \"\"\"Stringify a dictionary as JSON and indent it.\n\n    Args:\n        indent: The number of spaces to indent.\n        payload: The data to stringify and indent.\n        prepend_new_line: Prepend a new line to the payload if `True`.\n        as_yaml: Dump the payload in yaml.\n\n    Returns:\n        An indented payload.\n    \"\"\"\n    json_dict = (\n        highlight_yaml(yaml.dumps(payload))\n        if as_yaml\n        else highlight_json(json.dumps(payload, indent=2))\n    )\n    indented_payload = textwrap.indent(json_dict, ' ' * indent)\n    return f'\\n{indented_payload}' if prepend_new_line else indented_payload\n</code></pre>"},{"location":"api/m/log/ci_tools/","title":"ci_tools","text":""},{"location":"api/m/log/ci_tools/ci_tools/","title":"ci_tools","text":""},{"location":"api/m/log/ci_tools/ci_tools/#m.log.ci_tools.ci_tools.get_ci_tool","title":"<code>get_ci_tool()</code>","text":"<p>Return the current CI Tool based on the environment variables.</p> <p>Returns:</p> Type Description <code>ProviderModule</code> <p>A <code>ProviderModule</code> instance with methods to provide messages in</p> <code>ProviderModule</code> <p>a CI environment.</p> Source code in <code>m/log/ci_tools/ci_tools.py</code> <pre><code>def get_ci_tool() -&gt; ProviderModule:\n    \"\"\"Return the current CI Tool based on the environment variables.\n\n    Returns:\n        A `ProviderModule` instance with methods to provide messages in\n        a CI environment.\n    \"\"\"\n    env = mio.env\n    if env('GITHUB_ACTIONS'):\n        return gh_tool\n    if env('TC') or env('TEAMCITY'):\n        return tc_tool\n    return local_tool\n</code></pre>"},{"location":"api/m/log/ci_tools/types/","title":"types","text":""},{"location":"api/m/log/ci_tools/types/#m.log.ci_tools.types.EnvVars","title":"<code>EnvVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class to store the values of the environment variables.</p> <p>Attributes:</p> Name Type Description <code>ci_env</code> <code>bool</code> <p>...</p> <code>github_token</code> <code>str</code> <p>...</p> <code>server_url</code> <code>str</code> <p>...</p> <code>run_id</code> <code>str</code> <p>...</p> <code>run_number</code> <code>str</code> <p>...</p> <code>run_url</code> <code>str</code> <p>...</p> <code>git_branch</code> <code>str</code> <p>...</p> <code>git_sha</code> <code>str</code> <p>...</p> <code>triggered_by</code> <code>str</code> <p>...</p> <code>triggered_by_email</code> <code>str</code> <p>...</p> <code>triggered_by_user</code> <code>str</code> <p>...</p> Source code in <code>m/log/ci_tools/types.py</code> <pre><code>class EnvVars(BaseModel):\n    \"\"\"Class to store the values of the environment variables.\"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n    ci_env: bool = False\n    github_token: str = ''\n    server_url: str = ''\n    run_id: str = ''\n    run_number: str = ''\n    run_url: str = ''\n    git_branch: str = ''\n    git_sha: str = ''\n    triggered_by: str = ''\n    triggered_by_email: str = ''\n    triggered_by_user: str = ''\n</code></pre>"},{"location":"api/m/log/ci_tools/types/#m.log.ci_tools.types.Message","title":"<code>Message</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Parameters needed to deliver a warning or error message.</p> <p>Attributes:</p> Name Type Description <code>msg</code> <code>str</code> <p>message to display</p> <code>title</code> <code>str | None</code> <p>custom title</p> <code>file</code> <code>str | None</code> <p>filename</p> <code>line</code> <code>str | None</code> <p>line number, starting at 1</p> <code>end_line</code> <code>str | None</code> <p>end line number</p> <code>col</code> <code>str | None</code> <p>column number, starting at 1</p> <code>end_col</code> <code>str | None</code> <p>end column number</p> Source code in <code>m/log/ci_tools/types.py</code> <pre><code>class Message(BaseModel):\n    \"\"\"Parameters needed to deliver a warning or error message.\"\"\"\n\n    msg: str = Field(description='message to display')\n    title: str | None = Field(default=None, description='custom title')\n    file: str | None = Field(  # noqa: WPS110 - required by Github\n        default=None,\n        description='filename',\n    )\n    line: str | None = Field(\n        default=None,\n        description='line number, starting at 1',\n    )\n    end_line: str | None = Field(default=None, description='end line number')\n    col: str | None = Field(\n        default=None,\n        description='column number, starting at 1',\n    )\n    end_col: str | None = Field(default=None, description='end column number')\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/m/log/ci_tools/types/#m.log.ci_tools.types.ProviderModule","title":"<code>ProviderModule</code>  <code>dataclass</code>","text":"<p>Container to store functions from the providers.</p> Source code in <code>m/log/ci_tools/types.py</code> <pre><code>@dataclass\nclass ProviderModule:\n    \"\"\"Container to store functions from the providers.\"\"\"\n\n    ci: bool\n    env_vars: Callable[[], OneOf[Issue, EnvVars]]\n    formatter: Callable[\n        [logging.Formatter, logging.LogRecord, bool, bool],\n        str,\n    ]\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/","title":"providers","text":""},{"location":"api/m/log/ci_tools/providers/github/","title":"github","text":""},{"location":"api/m/log/ci_tools/providers/github/#m.log.ci_tools.providers.github.GithubEnvVars","title":"<code>GithubEnvVars</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Environment variables required when running in Github.</p> <p>Attributes:</p> Name Type Description <code>repo</code> <code>str</code> <p>...</p> <code>run_id</code> <code>str</code> <p>...</p> <code>run_number</code> <code>str</code> <p>...</p> <code>github_token</code> <code>str</code> <p>...</p> <code>git_branch</code> <code>str</code> <p>...</p> <code>git_sha</code> <code>str</code> <p>...</p> <code>triggered_by</code> <code>str</code> <p>...</p> Source code in <code>m/log/ci_tools/providers/github.py</code> <pre><code>class GithubEnvVars(BaseModel):\n    \"\"\"Environment variables required when running in Github.\"\"\"\n\n    repo: str = Field('GITHUB_REPOSITORY')\n    run_id: str = Field('GITHUB_RUN_ID')\n    run_number: str = Field('GITHUB_RUN_NUMBER')\n    github_token: str = Field('GITHUB_TOKEN')\n    git_branch: str = Field('GITHUB_REF')\n    git_sha: str = Field('GITHUB_SHA')\n    triggered_by: str = Field('GITHUB_ACTOR')\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/github/#m.log.ci_tools.providers.github.env_vars","title":"<code>env_vars()</code>","text":"<p>Read the environment variables from Github Actions.</p> <p>Returns:</p> Type Description <code>OneOf[Issue, EnvVars]</code> <p>An <code>EnvVars</code> instance or an Issue.</p> Source code in <code>m/log/ci_tools/providers/github.py</code> <pre><code>def env_vars() -&gt; OneOf[Issue, EnvVars]:\n    \"\"\"Read the environment variables from Github Actions.\n\n    Returns:\n        An `EnvVars` instance or an Issue.\n    \"\"\"\n    server_url = 'https://github.com'\n    return one_of(\n        lambda: [\n            EnvVars(\n                **env.model_dump(),\n                ci_env=True,\n                server_url=server_url,\n                run_url=run_url,\n            )\n            for env in mio.env_model(GithubEnvVars)\n            for run_url in (\n                f'{server_url}/{env.repo}/actions/runs/{env.run_id}',\n            )\n        ],\n    ).flat_map_bad(hone('GH Actions env_vars failure'))\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/github/#m.log.ci_tools.providers.github.log_format","title":"<code>log_format(formatter, record, show_traceback, debug_python)</code>","text":"<p>Format a log record using the functions provided in this module.</p> <p>This function is meant to be used by a log formatter. See more info</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>Formatter</code> <p>A log formatter instance.</p> required <code>record</code> <code>LogRecord</code> <p>A log record.</p> required <code>show_traceback</code> <code>bool</code> <p>If true, display the python stack trace.</p> required <code>debug_python</code> <code>bool</code> <p>If true, display the location of the record's origin.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/ci_tools/providers/github.py</code> <pre><code>def log_format(\n    formatter: logging.Formatter,\n    record: logging.LogRecord,\n    show_traceback: bool,\n    debug_python: bool,\n) -&gt; str:\n    \"\"\"Format a log record using the functions provided in this module.\n\n    This function is meant to be used by a log formatter. See more info\n\n\n    Args:\n        formatter: A log formatter instance.\n        record: A log record.\n        show_traceback: If true, display the python stack trace.\n        debug_python: If true, display the location of the record's origin.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    record_dict = record.__dict__\n\n    open_b = record_dict.get('open_block')\n    if open_b:\n        return _format_block(*open_b)\n\n    if record_dict.get('close_block'):\n        return '::endgroup::'\n\n    is_command = record.levelname in {'WARNING', 'ERROR'}\n\n    indent_padding = 2 if is_command else 3\n    indent = len(record.levelname) + indent_padding\n\n    ci_info = record_dict.get('ci_info', Message(msg=record.msg))\n    context = format_context(record, indent, show_traceback=show_traceback)\n    if not record.msg:\n        return context[1:]\n\n    loc = (\n        format_location([record.pathname, f'{record.lineno}'])\n        if debug_python\n        else ''\n    )\n    if is_command:\n        msg = f'{loc} {record.msg}'.lstrip()\n        return _gh_format(record.levelname.lower(), ci_info, msg, context)\n    return default_record_fmt(\n        record,\n        formatter.formatTime(record, formatter.datefmt),\n        loc,\n        context,\n    )\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/local/","title":"local","text":""},{"location":"api/m/log/ci_tools/providers/local/#m.log.ci_tools.providers.local.env_vars","title":"<code>env_vars()</code>","text":"<p>Obtain basic environment variables in a local environment.</p> <p>Returns:</p> Type Description <code>OneOf[Issue, EnvVars]</code> <p>An <code>EnvVars</code> instance if successful.</p> Source code in <code>m/log/ci_tools/providers/local.py</code> <pre><code>def env_vars() -&gt; OneOf[Issue, EnvVars]:\n    \"\"\"Obtain basic environment variables in a local environment.\n\n    Returns:\n        An `EnvVars` instance if successful.\n    \"\"\"\n    return one_of(\n        lambda: [\n            EnvVars(\n                git_branch=git_branch,\n                git_sha=git_sha,\n            )\n            for git_branch in git.get_branch()\n            for git_sha in git.get_current_commit_sha()\n        ],\n    )\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/local/#m.log.ci_tools.providers.local.log_format","title":"<code>log_format(formatter, record, show_traceback, debug_python)</code>","text":"<p>Format a log record using the functions provided in this module.</p> <p>This function is meant to be used by a log formatter. See more info</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>Formatter</code> <p>A log formatter instance.</p> required <code>record</code> <code>LogRecord</code> <p>A log record.</p> required <code>show_traceback</code> <code>bool</code> <p>If true, display the python stack trace.</p> required <code>debug_python</code> <code>bool</code> <p>If true, display the location of the record's origin.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/ci_tools/providers/local.py</code> <pre><code>def log_format(\n    formatter: logging.Formatter,\n    record: logging.LogRecord,\n    show_traceback: bool,\n    debug_python: bool,\n) -&gt; str:\n    \"\"\"Format a log record using the functions provided in this module.\n\n    This function is meant to be used by a log formatter. See more info\n\n\n    Args:\n        formatter: A log formatter instance.\n        record: A log record.\n        show_traceback: If true, display the python stack trace.\n        debug_python: If true, display the location of the record's origin.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    record_dict = record.__dict__\n\n    open_b = record_dict.get('open_block')\n    if open_b:\n        name, desc = open_b\n        return f'&gt;&gt;&gt; [{name}]: {desc}'.rstrip()\n\n    if record_dict.get('close_block'):\n        return ''\n\n    indent = len(record.levelname) + 3\n    context = format_context(record, indent, show_traceback=show_traceback)\n    if not record.msg:\n        return context[1:]\n\n    ci_info = record_dict.get('ci_info', Message(msg=record.msg))\n    msg_info = format_location([ci_info.file, ci_info.line, ci_info.col])\n    loc = (\n        format_location([record.pathname, f'{record.lineno}'], 'bold_aqua')\n        if debug_python\n        else ''\n    )\n\n    return default_record_fmt(\n        record,\n        formatter.formatTime(record, formatter.datefmt),\n        f'{msg_info}{loc}',\n        context,\n    )\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/teamcity/","title":"teamcity","text":""},{"location":"api/m/log/ci_tools/providers/teamcity/#m.log.ci_tools.providers.teamcity.env_vars","title":"<code>env_vars()</code>","text":"<p>Read basic environment variables from Teamcity.</p> <p>Returns:</p> Type Description <code>OneOf[Issue, EnvVars]</code> <p>An EnvVar instance.</p> Source code in <code>m/log/ci_tools/providers/teamcity.py</code> <pre><code>def env_vars() -&gt; OneOf[Issue, EnvVars]:\n    \"\"\"Read basic environment variables from Teamcity.\n\n    Returns:\n        An EnvVar instance.\n    \"\"\"\n    # WIP: Need to map other variables here. Not willing to do\n    # at the moment since I'm using Github.\n    return Good(EnvVars(ci_env=True))\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/teamcity/#m.log.ci_tools.providers.teamcity.escape_msg","title":"<code>escape_msg(msg)</code>","text":"<p>Escapes characters so Teamcity can print correctly.</p> <p>https://www.jetbrains.com/help/teamcity/build-script-interaction-with-teamcity.html#BuildScriptInteractionwithTeamCity-Escapedvalues</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to process.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A message that can be provided to Teamcity.</p> Source code in <code>m/log/ci_tools/providers/teamcity.py</code> <pre><code>def escape_msg(msg: str) -&gt; str:\n    \"\"\"Escapes characters so Teamcity can print correctly.\n\n    https://www.jetbrains.com/help/teamcity/build-script-interaction-with-teamcity.html#BuildScriptInteractionwithTeamCity-Escapedvalues\n\n    Args:\n        msg: The message to process.\n\n    Returns:\n        A message that can be provided to Teamcity.\n    \"\"\"\n    message = msg\n    for target, replacement in REPLACEMENTS:\n        message = message.replace(target, replacement)\n    return message\n</code></pre>"},{"location":"api/m/log/ci_tools/providers/teamcity/#m.log.ci_tools.providers.teamcity.log_format","title":"<code>log_format(_formatter, record, show_traceback, debug_python)</code>","text":"<p>Format a log record using the functions provided in this module.</p> <p>This function is meant to be used by a log formatter. See more info</p> <p>See::     https://www.jetbrains.com/help/teamcity/build-script-interaction-with-teamcity.html#BuildScriptInteractionwithTeamCity-BlocksofServiceMessages</p> <p>Parameters:</p> Name Type Description Default <code>_formatter</code> <code>Formatter</code> <p>A log formatter instance.</p> required <code>record</code> <code>LogRecord</code> <p>A log record.</p> required <code>show_traceback</code> <code>bool</code> <p>If true, display the python stack trace.</p> required <code>debug_python</code> <code>bool</code> <p>If true, display the location of the record's origin.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string.</p> Source code in <code>m/log/ci_tools/providers/teamcity.py</code> <pre><code>def log_format(\n    _formatter: logging.Formatter,\n    record: logging.LogRecord,\n    show_traceback: bool,\n    debug_python: bool,\n) -&gt; str:\n    \"\"\"Format a log record using the functions provided in this module.\n\n    This function is meant to be used by a log formatter. See more info\n\n    See::\n        https://www.jetbrains.com/help/teamcity/build-script-interaction-with-teamcity.html#BuildScriptInteractionwithTeamCity-BlocksofServiceMessages\n\n    Args:\n        _formatter: A log formatter instance.\n        record: A log record.\n        show_traceback: If true, display the python stack trace.\n        debug_python: If true, display the location of the record's origin.\n\n    Returns:\n        A formatted string.\n    \"\"\"\n    record_dict = record.__dict__\n\n    open_b = _fmt_open(record_dict)\n    if open_b:\n        return open_b\n\n    close_b = record_dict.get('close_block')\n    if close_b:\n        return _tc('blockClosed', postfix='', name=close_b)\n\n    indent_padding = 2 if record.levelname in {'WARNING', 'ERROR'} else 3\n    indent = len(record.levelname) + indent_padding\n\n    context = format_context(record, indent, show_traceback=show_traceback)\n    if not record.msg:\n        return context[1:]\n\n    ci_info = record_dict.get('ci_info', Message(msg=record.msg))\n    msg_info = format_location([ci_info.file, ci_info.line, ci_info.col])\n    msg_info = f'{msg_info}:' if msg_info else ''\n\n    loc = (\n        format_location([record.pathname, f'{record.lineno}'])\n        if debug_python\n        else ''\n    )\n\n    msg = f'{loc}{msg_info} {record.msg}'.lstrip()\n    if record.levelname == 'WARNING':\n        msg = _tc(\n            'message',\n            status='WARNING',\n            text=msg,\n            postfix=context,\n        )\n    elif record.levelname == 'ERROR':\n        msg = _tc('buildProblem', postfix=context, description=msg)\n    else:\n        msg = default_record_fmt(record, '', f'{msg_info}{loc}', context)\n    return msg\n</code></pre>"},{"location":"api/m/npm/","title":"npm","text":""},{"location":"api/m/npm/clean_tags/","title":"clean_tags","text":""},{"location":"api/m/npm/clean_tags/#m.npm.clean_tags.clean_tags","title":"<code>clean_tags(pkg)</code>","text":"<p>Remove tags from a package that point to empty versions.</p> <p>Parameters:</p> Name Type Description Default <code>pkg</code> <code>str</code> <p>The name of the npm package.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, List[str]]</code> <p>A <code>OneOf</code> containing a summary of removed tags or an Issue.</p> Source code in <code>m/npm/clean_tags.py</code> <pre><code>def clean_tags(pkg: str) -&gt; OneOf[Issue, List[str]]:\n    \"\"\"Remove tags from a package that point to empty versions.\n\n    Args:\n        pkg: The name of the npm package.\n\n    Returns:\n        A `OneOf` containing a summary of removed tags or an Issue.\n    \"\"\"\n    return one_of(lambda: [\n        summary\n        for tag_map in get_dist_tags(pkg)\n        for summary in remove_tags(pkg, find_empty_tags(tag_map))\n    ])\n</code></pre>"},{"location":"api/m/npm/clean_tags/#m.npm.clean_tags.find_empty_tags","title":"<code>find_empty_tags(tag_map)</code>","text":"<p>Create a set containing the npm tags that are empty.</p> <p>Parameters:</p> Name Type Description Default <code>tag_map</code> <code>Dict[str, str]</code> <p>A dictionary mapping npm tags to versions.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>A set of npm tags that map to empty strings.</p> Source code in <code>m/npm/clean_tags.py</code> <pre><code>def find_empty_tags(tag_map: Dict[str, str]) -&gt; Set[str]:\n    \"\"\"Create a set containing the npm tags that are empty.\n\n    Args:\n        tag_map: A dictionary mapping npm tags to versions.\n\n    Returns:\n        A set of npm tags that map to empty strings.\n    \"\"\"\n    return {\n        tag_name\n        for tag_name, version in tag_map.items()\n        if not version\n    }\n</code></pre>"},{"location":"api/m/npm/clean_tags/#m.npm.clean_tags.remove_tags","title":"<code>remove_tags(pkg, tags)</code>","text":"<p>Call <code>npm dist-tag</code> to remove npm tags.</p> <p>See https://docs.npmjs.com/cli/v8/commands/npm-dist-tag</p> <p>Parameters:</p> Name Type Description Default <code>pkg</code> <code>str</code> <p>The npm package.</p> required <code>tags</code> <code>Set[str]</code> <p>A set containing the tags to remove.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, List[str]]</code> <p>A <code>OneOf</code> containing a list of the output for each removed tag or an</p> <code>OneOf[Issue, List[str]]</code> <p>issue with a summary.</p> Source code in <code>m/npm/clean_tags.py</code> <pre><code>def remove_tags(pkg: str, tags: Set[str]) -&gt; OneOf[Issue, List[str]]:\n    \"\"\"Call `npm dist-tag` to remove npm tags.\n\n    See https://docs.npmjs.com/cli/v8/commands/npm-dist-tag\n\n    Args:\n        pkg: The npm package.\n        tags: A set containing the tags to remove.\n\n    Returns:\n        A `OneOf` containing a list of the output for each removed tag or an\n        issue with a summary.\n    \"\"\"\n    issues: List[Issue] = []\n    removed: List[str] = []\n    for tag in tags:\n        cmd_result = remove_dist_tag(pkg, tag)\n        if cmd_result.is_bad:\n            issues.append(cast(Issue, cmd_result.value))\n        else:\n            removed.append(cast(str, cmd_result.value))\n    if issues:\n        return issue('dist-tag rm issues', context={\n            'issues': issues,\n            'removed': removed,\n        })\n    return Good(removed)\n</code></pre>"},{"location":"api/m/npm/cli/","title":"cli","text":""},{"location":"api/m/npm/cli/#m.npm.cli.get_dist_tags","title":"<code>get_dist_tags(pkg_name)</code>","text":"<p>Fetch all the npm tags for a package.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The name of the npm package.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, Dict[str, str]]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or map specifying the tags to a</p> <code>OneOf[Issue, Dict[str, str]]</code> <p>published version.</p> Source code in <code>m/npm/cli.py</code> <pre><code>def get_dist_tags(pkg_name: str) -&gt; OneOf[Issue, Dict[str, str]]:\n    \"\"\"Fetch all the npm tags for a package.\n\n    Args:\n        pkg_name: The name of the npm package.\n\n    Returns:\n        A `OneOf` containing an `Issue` or map specifying the tags to a\n        published version.\n    \"\"\"\n    cmd = f'npm info {pkg_name} dist-tags --json'\n    return one_of(lambda: [\n        tag_map\n        for payload in subprocess.eval_cmd(cmd)\n        for tag_map in parse_json(payload)\n    ])\n</code></pre>"},{"location":"api/m/npm/cli/#m.npm.cli.remove_dist_tag","title":"<code>remove_dist_tag(pkg_name, tag)</code>","text":"<p>Remove an npm tag.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_name</code> <code>str</code> <p>The name of the npm package.</p> required <code>tag</code> <code>str</code> <p>The tag to remove.</p> required <p>Returns:</p> Type Description <code>OneOf[Issue, str]</code> <p>A <code>OneOf</code> containing an <code>Issue</code> or the output of the npm command.</p> Source code in <code>m/npm/cli.py</code> <pre><code>def remove_dist_tag(pkg_name: str, tag: str) -&gt; OneOf[Issue, str]:\n    \"\"\"Remove an npm tag.\n\n    Args:\n        pkg_name: The name of the npm package.\n        tag: The tag to remove.\n\n    Returns:\n        A `OneOf` containing an `Issue` or the output of the npm command.\n    \"\"\"\n    return subprocess.eval_cmd(f'npm dist-tag rm {pkg_name} {tag} --json')\n</code></pre>"},{"location":"api/m/npm/tag/","title":"tag","text":""},{"location":"api/m/npm/tag/#m.npm.tag.npm_tags","title":"<code>npm_tags(m_tag)</code>","text":"<p>Convert an m_tag to an npm_tag.</p> <p>Parameters:</p> Name Type Description Default <code>m_tag</code> <code>str</code> <p>A tag/version provided by m.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A tag that can be used by npm during the publishing step.</p> Source code in <code>m/npm/tag.py</code> <pre><code>def npm_tags(m_tag: str) -&gt; list[str]:\n    \"\"\"Convert an m_tag to an npm_tag.\n\n    Args:\n        m_tag: A tag/version provided by m.\n\n    Returns:\n        A tag that can be used by npm during the publishing step.\n    \"\"\"\n    tags = []\n    regex = r'\\d+.\\d+.\\d+-(.*)\\.(.*)'\n    matches = re.match(regex, m_tag)\n    if matches:\n        tag, _ = matches.groups()\n        if tag.startswith('rc') or tag.startswith('hotfix'):\n            tags.append('next')\n        else:\n            tags.append(tag)\n    else:\n        tags.append('latest')\n    return tags\n</code></pre>"},{"location":"cli/SUMMARY/","title":"SUMMARY","text":"<ul> <li>blueprints</li> <li>end_release</li> <li>init</li> <li>json</li> <li>jsonq</li> <li>review_release</li> <li>start_hotfix</li> <li>start_release</li> <li>ci<ul> <li>assert_branch</li> <li>bump_version</li> <li>celt</li> <li>env</li> <li>npm_tag</li> <li>release_setup</li> </ul> </li> <li>devcontainer<ul> <li>bashrc</li> <li>greet</li> <li>pnpm</li> <li>pnpm_setup</li> <li>prompter</li> <li>require_env_vars</li> </ul> </li> <li>git<ul> <li>branch</li> <li>current_sha</li> <li>first_sha</li> <li>status</li> <li>tag_release</li> </ul> </li> <li>github<ul> <li>branch_prs</li> <li>build_sha</li> <li>ci</li> <li>create_pr</li> <li>latest_release</li> <li>merge_pr</li> <li>pr</li> <li>release</li> <li>status</li> </ul> </li> <li>message<ul> <li>close</li> <li>error</li> <li>open</li> <li>sibling_block</li> <li>warn</li> </ul> </li> <li>npm<ul> <li>clean_tags</li> </ul> </li> </ul>"},{"location":"cli/blueprints/","title":"m blueprints","text":"<p>Create the <code>[m_dir]/.m/blueprints</code> directory.</p> <p>This will add shell scripts to build the specified docker images as stated in the <code>[m_dir]/m.yaml</code> file.</p> Source code in <code>m/cli/commands/blueprints.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Create the `[m_dir]/.m/blueprints` directory.\n\n    This will add shell scripts to build the specified docker images as\n    stated in the `[m_dir]/m.yaml` file.\n    \"\"\"\n\n    m_dir: str = Arg(\n        default='m',\n        help='m project directory',\n        positional=True,\n    )\n    m_tag: str = Arg(\n        default='M_TAG',\n        validator=env_var_or_empty,\n        help='unique version to use for all the images',\n    )\n    cache_from_pr: str = Arg(\n        default='M_CACHE_FROM_PR',\n        validator=env_var_or_empty,\n        help='pull request number to attempt to use as cache',\n    )\n    skip_makefile: bool = Arg(\n        default=False,\n        help='do not update Makefile',\n    )\n    skip_workflow: bool = Arg(\n        default=False,\n        help='do not update github workflow',\n    )\n</code></pre>"},{"location":"cli/blueprints/#options","title":"Options","text":""},{"location":"cli/blueprints/#m_tag","title":"<code>--m-tag</code>","text":"<ul><li>default: <code>env.M_TAG</code></li></ul> <p>unique version to use for all the images</p>"},{"location":"cli/blueprints/#cache_from_pr","title":"<code>--cache-from-pr</code>","text":"<ul><li>default: <code>env.M_CACHE_FROM_PR</code></li></ul> <p>pull request number to attempt to use as cache</p>"},{"location":"cli/blueprints/#skip_makefile","title":"<code>--skip-makefile</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>do not update Makefile</p>"},{"location":"cli/blueprints/#skip_workflow","title":"<code>--skip-workflow</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>do not update github workflow</p>"},{"location":"cli/blueprints/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/blueprints/#m_dir","title":"<code>m_dir</code>","text":"<ul><li>default: <code>'m'</code></li></ul> <p>m project directory</p>"},{"location":"cli/end_release/","title":"m end_release","text":"<p>End the release process.</p> <p>Merges the release/hotfix branch into the master branch.</p> Source code in <code>m/cli/commands/end_release.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"End the release process.\n\n    Merges the release/hotfix branch into the master branch.\n    \"\"\"\n\n    github_token: str = ArgProxy(\n        '--github-token',\n        default='GITHUB_TOKEN',\n        type=env_var,\n        help='Github personal access token with repo scope',\n    )\n</code></pre>"},{"location":"cli/end_release/#options","title":"Options","text":""},{"location":"cli/end_release/#github_token","title":"<code>--github-token</code>","text":"<ul><li>default: <code>env.GITHUB_TOKEN</code></li></ul> <p>Github personal access token with repo scope</p>"},{"location":"cli/init/","title":"m init","text":"<p>Create the necessary files for an m project.</p> Source code in <code>m/cli/commands/init.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Create the necessary files for an m project.\"\"\"\n</code></pre>"},{"location":"cli/json/","title":"m json","text":"<p>Format a json payload.</p> <p>similar to <code>python -m json.tool</code> but instead it uses 2 spaces for indentation::</p> <pre><code>$ echo '{\"a\":99}' | m json\n{\n  \"a\": 99\n}\n</code></pre> <p>It is worth noting that if you have access to <code>jq</code> or <code>yq</code> then it should be used instead of <code>m json</code>::</p> <pre><code>$ echo '{\"a\":99}' | jq\n{\n  \"a\": 99\n}\n</code></pre> <ul> <li>jq: https://stedolan.github.io/jq/manual/</li> <li>yq: https://mikefarah.gitbook.io/yq/</li> </ul> Source code in <code>m/cli/commands/json.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Format a json payload.\n\n    similar to `python -m json.tool` but instead it uses 2 spaces\n    for indentation::\n\n        $ echo '{\"a\":99}' | m json\n        {\n          \"a\": 99\n        }\n\n    It is worth noting that if you have access to `jq` or `yq` then\n    it should be used instead of `m json`::\n\n        $ echo '{\"a\":99}' | jq\n        {\n          \"a\": 99\n        }\n\n    - jq: https://stedolan.github.io/jq/manual/\n    - yq: https://mikefarah.gitbook.io/yq/\n    \"\"\"\n\n    payload: Any = Arg(\n        default='@-',\n        help='json data: @- (stdin), @filename (file), string',\n        positional=True,\n        validator=validate_json_payload,\n    )\n\n    sort_keys: bool = Arg(\n        default=False,\n        help='sort the output of dictionaries alphabetically by key',\n    )\n</code></pre>"},{"location":"cli/json/#options","title":"Options","text":""},{"location":"cli/json/#sort_keys","title":"<code>--sort-keys</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>sort the output of dictionaries alphabetically by key</p>"},{"location":"cli/json/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/json/#payload","title":"<code>payload</code>","text":"<ul><li>default: <code>'@-'</code></li></ul> <p>json data: @- (stdin), @filename (file), string</p>"},{"location":"cli/jsonq/","title":"m jsonq","text":"<p>Query json data.</p> <p>single value::</p> <pre><code>m jsonq path.to.property &lt; file.json\ncat file.json | m jsonq path.to.property\nm jsonq @file.json path.to.property\n</code></pre> <p>Return the value stored in the json file. For arrays and objects it will print the python representation of the object.</p> <p>multiple values::</p> <pre><code>m jsonq path1 path2 path3 &lt; file.json\ncat file.json | m jsonq path1 path2 path3\nm jsonq @file.json path1 path2 path3\n</code></pre> <p>use <code>read</code> to store in bash variables::</p> <pre><code>read -r -d '\\n' \\\n    var1 var2 var3 \\\n    &lt;&lt;&lt; \"$(m jsonq @file.json 'path1' 'path2' 'path3')\"\n</code></pre> <p>If available, take advantage of better queries through jq and yq:</p> <ul> <li>jq: https://stedolan.github.io/jq/manual/</li> <li>yq: https://mikefarah.gitbook.io/yq/</li> </ul> Source code in <code>m/cli/commands/jsonq.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Query json data.\n\n    single value::\n\n        m jsonq path.to.property &lt; file.json\n        cat file.json | m jsonq path.to.property\n        m jsonq @file.json path.to.property\n\n    Return the value stored in the json file. For arrays and objects it\n    will print the python representation of the object.\n\n    multiple values::\n\n        m jsonq path1 path2 path3 &lt; file.json\n        cat file.json | m jsonq path1 path2 path3\n        m jsonq @file.json path1 path2 path3\n\n    use `read` to store in bash variables::\n\n        read -r -d '\\n' \\\n            var1 var2 var3 \\\n            &lt;&lt;&lt; \"$(m jsonq @file.json 'path1' 'path2' 'path3')\"\n\n    If available, take advantage of better queries through jq and yq:\n\n    - jq: https://stedolan.github.io/jq/manual/\n    - yq: https://mikefarah.gitbook.io/yq/\n    \"\"\"\n\n    payload: Any = Arg(\n        default='@-',\n        help='json data: @- (stdin), @filename (file), string',\n        validator=validate_json_payload,\n        positional=True,\n    )\n\n    query: list[str] = Arg(\n        help='path to json data',\n        positional=True,\n        nargs='+',\n    )\n\n    warn: bool = Arg(\n        default=False,\n        help='print warning messages instead of errors',\n        aliases=['w', 'warn'],\n    )\n\n    separator: str = Arg(\n        default='\\n',\n        help='separator for multiple values',\n        aliases=['s', 'separator'],\n    )\n</code></pre>"},{"location":"cli/jsonq/#options","title":"Options","text":""},{"location":"cli/jsonq/#warn","title":"<code>-w</code>, <code>--warn</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>print warning messages instead of errors</p>"},{"location":"cli/jsonq/#separator","title":"<code>-s</code>, <code>--separator</code>","text":"<ul><li>default: <code>'\\n'</code></li></ul> <p>separator for multiple values</p>"},{"location":"cli/jsonq/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/jsonq/#payload","title":"<code>payload</code>","text":"<ul><li>default: <code>'@-'</code></li></ul> <p>json data: @- (stdin), @filename (file), string</p>"},{"location":"cli/jsonq/#query","title":"<code>query</code>","text":"<p>path to json data</p>"},{"location":"cli/review_release/","title":"m review_release","text":"<p>Create Github pull request(s) to review the release.</p> Source code in <code>m/cli/commands/review_release.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Create Github pull request(s) to review the release.\"\"\"\n\n    github_token: str = ArgProxy(\n        '--github-token',\n        type=env_var,\n        default='GITHUB_TOKEN',\n        help='Github personal access token with repo scope',\n    )\n</code></pre>"},{"location":"cli/review_release/#options","title":"Options","text":""},{"location":"cli/review_release/#github_token","title":"<code>--github-token</code>","text":"<ul><li>default: <code>env.GITHUB_TOKEN</code></li></ul> <p>Github personal access token with repo scope</p>"},{"location":"cli/start_hotfix/","title":"m start_hotfix","text":"<p>Start the release process for a hotfix.</p> <p>A hotfix should always be done in the master branch.</p> <p>It may also require input from the developer to proceed with certain operations.</p> Source code in <code>m/cli/commands/start_hotfix.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Start the release process for a hotfix.\n\n    A hotfix should always be done in the master branch.\n\n    It may also require input from the developer to proceed with\n    certain operations.\n    \"\"\"\n\n    github_token: str = ArgProxy(\n        '--github-token',\n        default='GITHUB_TOKEN',\n        type=env_var,\n        help='Github personal access token with repo scope',\n    )\n</code></pre>"},{"location":"cli/start_hotfix/#options","title":"Options","text":""},{"location":"cli/start_hotfix/#github_token","title":"<code>--github-token</code>","text":"<ul><li>default: <code>env.GITHUB_TOKEN</code></li></ul> <p>Github personal access token with repo scope</p>"},{"location":"cli/start_release/","title":"m start_release","text":"<p>Start the release process.</p> <p>Depending on the workflow the <code>m</code> configuration is using we will be required to be working on the <code>master</code> or <code>develop</code> branch.</p> <p>It may also require input from the developer to proceed with certain operations.</p> Source code in <code>m/cli/commands/start_release.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Start the release process.\n\n    Depending on the workflow the `m` configuration is using we\n    will be required to be working on the `master` or `develop` branch.\n\n    It may also require input from the developer to proceed with\n    certain operations.\n    \"\"\"\n\n    github_token: str = ArgProxy(\n        '--github-token',\n        default='GITHUB_TOKEN',\n        type=env_var,\n        help='Github personal access token with repo scope',\n    )\n</code></pre>"},{"location":"cli/start_release/#options","title":"Options","text":""},{"location":"cli/start_release/#github_token","title":"<code>--github-token</code>","text":"<ul><li>default: <code>env.GITHUB_TOKEN</code></li></ul> <p>Github personal access token with repo scope</p>"},{"location":"cli/ci/assert_branch/","title":"m ci assert_branch","text":"<p>Fail command when working on a non valid branch for a release/hotfix.</p> <p>Used during a release setup or hotfix setup. We want to make sure that we are working on the correct branch depending on release type we want to make and the workflow that we are using.</p> Source code in <code>m/cli/commands/ci/assert_branch.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Fail command when working on a non valid branch for a release/hotfix.\n\n    Used during a release setup or hotfix setup. We want to make sure\n    that we are working on the correct branch depending on release type\n    we want to make and the workflow that we are using.\n    \"\"\"\n\n    type: str = ArgProxy(\n        '--type',\n        required=True,\n        choices=['release', 'hotfix'],\n        help='verification type',\n    )\n    m_dir: str = Arg(\n        help='m project directory',\n        required=True,\n        positional=True,\n    )\n</code></pre>"},{"location":"cli/ci/assert_branch/#options","title":"Options","text":""},{"location":"cli/ci/assert_branch/#type","title":"<code>--type</code>","text":"<ul><li>choices: <code>release</code>, <code>hotfix</code></li></ul> <p>verification type</p>"},{"location":"cli/ci/assert_branch/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/assert_branch/#m_dir","title":"<code>m_dir</code>","text":"<p>m project directory</p>"},{"location":"cli/ci/bump_version/","title":"m ci bump_version","text":"<p>Prompt user for the next valid semantic version.</p> Source code in <code>m/cli/commands/ci/bump_version.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Prompt user for the next valid semantic version.\"\"\"\n\n    type: str = ArgProxy(\n        '--type',\n        required=True,\n        choices=['release', 'hotfix'],\n        help='verification type',\n    )\n    version: str = Arg(\n        help='version to bump',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/ci/bump_version/#options","title":"Options","text":""},{"location":"cli/ci/bump_version/#type","title":"<code>--type</code>","text":"<ul><li>choices: <code>release</code>, <code>hotfix</code></li></ul> <p>verification type</p>"},{"location":"cli/ci/bump_version/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/bump_version/#version","title":"<code>version</code>","text":"<p>version to bump</p>"},{"location":"cli/ci/celt/","title":"m ci celt","text":"<p>Process a compiler or linter output to determine if the cli should stop.</p>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--examples","title":"Examples","text":"<pre><code>~$ m ci celt -t eslint -c @config.json &lt; &lt;(eslint [dir] -f json)\n\n~$ eslint [...options] &gt; tmp.json\n~$ m ci celt -t eslint @tmp.json -c '{\"allowedEslintRules\":{\"semi\":1}}'\n</code></pre> <p>Depending on the tool that is chosen the configuration should have an entry of the form <code>\"allowed[ToolName]Rules\"</code> or <code>\"ignored[ToolName]Rules\"</code>. Only the first letter of the tool should be capitalized to conform to the camel case style.</p> <p>The entry should define a map of rule ids to the number of allowed violations. In the case of <code>ignored[ToolName]Rules</code> we may define the rule id and assign an explanation as to why its being ignored.</p> <p>In the examples above we use <code>@config.json</code>. This means it will read the file <code>config.json</code>. You can use any file that you want. One option is to use eslintrc.json or create a brand new file called <code>allowed_errors.json</code>.</p>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--tools","title":"Tools","text":"<p>Each tool may provide have different outputs</p>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--eslint","title":"eslint","text":"<p>Should be called with the <code>-f json</code> option.</p> <pre><code>m ci celt -t eslint -c @config.json &lt; &lt;(eslint -f json [dir])\n</code></pre>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--pycodestyle","title":"pycodestyle","text":"<p>Should be called with the <code>--format=default</code> option.</p> <pre><code>m ci celt -t pycodestyle -c @config.json &lt; &lt;(pycodestyle --format=default [dir])\n</code></pre>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--flake8","title":"flake8","text":"<p>Expects default output.</p> <pre><code>m ci celt -t flake8 -c @config.json &lt; &lt;(flake8 [dir])\n</code></pre>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--pylint","title":"pylint","text":"<p>Should be called with the <code>-f json</code> option.</p> <pre><code>m ci celt -t pylint -c @config.json &lt; &lt;(pylint -f json --rcfile=[file] [dir])\n</code></pre>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--typescript","title":"typescript","text":"<p>Should be called with the <code>--pretty false</code> option.</p> <pre><code>m ci celt -t typescript -c @config.json &lt; &lt;(tsc --pretty false)\n</code></pre>"},{"location":"cli/ci/celt/#m.cli.commands.ci.celt.Arguments--ruff","title":"ruff","text":"<p>Should be called with the <code>--format json</code> option.</p> <pre><code>m ci celt -t ruff -c @config.json &lt; &lt;(ruff check --format json [dir])\n</code></pre> Source code in <code>m/cli/commands/ci/celt.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Process a compiler or linter output to determine if the cli should stop.\n\n    ## Examples\n\n    ```shell\n    ~$ m ci celt -t eslint -c @config.json &lt; &lt;(eslint [dir] -f json)\n\n    ~$ eslint [...options] &gt; tmp.json\n    ~$ m ci celt -t eslint @tmp.json -c '{\"allowedEslintRules\":{\"semi\":1}}'\n    ```\n\n    Depending on the tool that is chosen the configuration should have an\n    entry of the form `\"allowed[ToolName]Rules\"` or `\"ignored[ToolName]Rules\"`.\n    Only the first letter of the tool should be capitalized to conform to\n    the camel case style.\n\n    The entry should define a map of rule ids to the number of allowed\n    violations. In the case of `ignored[ToolName]Rules` we may define\n    the rule id and assign an explanation as to why its being ignored.\n\n    In the examples above we use `@config.json`. This means it\n    will read the file `config.json`. You can use any file that you want.\n    One option is to use eslintrc.json or create a brand new file called\n    `allowed_errors.json`.\n\n    ## Tools\n\n    Each tool may provide have different outputs\n\n    ### eslint\n\n    Should be called with the `-f json` option.\n\n    ```bash\n    m ci celt -t eslint -c @config.json &lt; &lt;(eslint -f json [dir])\n    ```\n\n    ### pycodestyle\n\n    Should be called with the `--format=default` option.\n\n    ```bash\n    m ci celt -t pycodestyle -c @config.json &lt; &lt;(pycodestyle --format=default [dir])\n    ```\n\n    ### flake8\n\n    Expects default output.\n\n    ```bash\n    m ci celt -t flake8 -c @config.json &lt; &lt;(flake8 [dir])\n    ```\n\n    ### pylint\n\n    Should be called with the `-f json` option.\n\n    ```bash\n    m ci celt -t pylint -c @config.json &lt; &lt;(pylint -f json --rcfile=[file] [dir])\n    ```\n\n    ### typescript\n\n    Should be called with the `--pretty false` option.\n\n    ```bash\n    m ci celt -t typescript -c @config.json &lt; &lt;(tsc --pretty false)\n    ```\n\n    ### ruff\n\n    Should be called with the `--format json` option.\n\n    ```bash\n    m ci celt -t ruff -c @config.json &lt; &lt;(ruff check --format json [dir])\n    ```\n    \"\"\"\n\n    payload: str = Arg(\n        default='@-',\n        help=\"\"\"\\\n            Output of a compiler or linter. A file may be specified by prefixing\n            a filename with `@`. To read from stdin use `@-`.\n\n            Summary: `@-` (stdin), `@filename` (file), `string`.\n        \"\"\",\n        validator=validate_payload,\n        positional=True,\n    )\n\n    tool: str = Arg(\n        help='name of a supported compiler/linter',\n        required=True,\n        aliases=['t', 'tool'],\n    )\n\n    config: Any = Arg(\n        default='{}',  # noqa: P103 - json object, not attempting to format\n        aliases=['c', 'config'],\n        help='config data: @filename (file), string',\n        validator=validate_json_payload,\n    )\n\n    max_lines: int = Arg(\n        default=5,\n        aliases=['m', 'max_lines'],\n        help='max number of error lines to print, use -1 for all',\n    )\n\n    file_regex: str | None = Arg(\n        aliases=['r', 'file_regex'],\n        help='regex expression to filter files',\n    )\n\n    file_prefix: str | None = Arg(\n        aliases=['p', 'file_prefix'],\n        help=\"replace file prefix with 'old1|old2:new'\",\n    )\n\n    ignore_error_allowance: bool = Arg(\n        default=False,\n        aliases=['i', 'ignore_error_allowance'],\n        help='set every error allowance to 0',\n    )\n\n    stats_only: bool = Arg(\n        default=False,\n        aliases=['s', 'stats_only'],\n        help='display a dictionary with current total violations',\n    )\n\n    full_message: bool = Arg(\n        default=False,\n        aliases=['f', 'full_message'],\n        help='display the full error message',\n    )\n\n    traceback: bool = Arg(\n        default=False,\n        help='display the exception traceback if available',\n    )\n</code></pre>"},{"location":"cli/ci/celt/#required-arguments","title":"Required arguments","text":""},{"location":"cli/ci/celt/#tool","title":"<code>-t</code>, <code>--tool</code>","text":"<p>name of a supported compiler/linter</p>"},{"location":"cli/ci/celt/#options","title":"Options","text":""},{"location":"cli/ci/celt/#config","title":"<code>-c</code>, <code>--config</code>","text":"<ul><li>default: <code>'{}'</code></li></ul> <p>config data: @filename (file), string</p>"},{"location":"cli/ci/celt/#max_lines","title":"<code>-m</code>, <code>--max-lines</code>","text":"<ul><li>default: <code>5</code></li></ul> <p>max number of error lines to print, use -1 for all</p>"},{"location":"cli/ci/celt/#file_regex","title":"<code>-r</code>, <code>--file-regex</code>","text":"<p>regex expression to filter files</p>"},{"location":"cli/ci/celt/#file_prefix","title":"<code>-p</code>, <code>--file-prefix</code>","text":"<p>replace file prefix with 'old1|old2:new'</p>"},{"location":"cli/ci/celt/#ignore_error_allowance","title":"<code>-i</code>, <code>--ignore-error-allowance</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>set every error allowance to 0</p>"},{"location":"cli/ci/celt/#stats_only","title":"<code>-s</code>, <code>--stats-only</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>display a dictionary with current total violations</p>"},{"location":"cli/ci/celt/#full_message","title":"<code>-f</code>, <code>--full-message</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>display the full error message</p>"},{"location":"cli/ci/celt/#traceback","title":"<code>--traceback</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>display the exception traceback if available</p>"},{"location":"cli/ci/celt/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/celt/#payload","title":"<code>payload</code>","text":"<ul><li>default: <code>'@-'</code></li></ul> <p>Output of a compiler or linter. A file may be specified by prefixing a filename with <code>@</code>. To read from stdin use <code>@-</code>.</p> <p>Summary: <code>@-</code> (stdin), <code>@filename</code> (file), <code>string</code>.</p>"},{"location":"cli/ci/env/","title":"m ci env","text":"<p>Create the [m_dir]/.m/env.list file.</p> <p>With the <code>bashrc</code> option it will print a bashrc snippet and no file will be created. Note that boolean values are lowercased in the snippet. This eventually be the case for generated env.list file.</p> Source code in <code>m/cli/commands/ci/env.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Create the [m_dir]/.m/env.list file.\n\n    With the `bashrc` option it will print a bashrc snippet and no file will\n    be created. Note that boolean values are lowercased in the snippet. This\n    eventually be the case for generated env.list file.\n    \"\"\"\n\n    pretty: bool = Arg(\n        default=False,\n        help='format json payload with indentation',\n    )\n    yaml: bool = Arg(\n        default=False,\n        help='use yaml format',\n    )\n    m_dir: str = Arg(\n        default='m',\n        help='m project directory',\n        positional=True,\n    )\n    bashrc: bool = Arg(\n        default=False,\n        help='print bashrc snippet',\n    )\n</code></pre>"},{"location":"cli/ci/env/#options","title":"Options","text":""},{"location":"cli/ci/env/#pretty","title":"<code>--pretty</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>format json payload with indentation</p>"},{"location":"cli/ci/env/#yaml","title":"<code>--yaml</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>use yaml format</p>"},{"location":"cli/ci/env/#bashrc","title":"<code>--bashrc</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>print bashrc snippet</p>"},{"location":"cli/ci/env/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/env/#m_dir","title":"<code>m_dir</code>","text":"<ul><li>default: <code>'m'</code></li></ul> <p>m project directory</p>"},{"location":"cli/ci/npm_tag/","title":"m ci npm_tag","text":"<p>Display an npm tag assigned to given version.</p> <p>examples::</p> <pre><code>~$ m ci npm_tag 0.0.0-develop.b123\ndevelop\n\n~$ m ci npm_tag 0.0.0-pr1234.b123\npr1234\n\n~$ m ci npm_tag 2.0.1-rc1234.b123\nnext\n\n~$ m ci npm_tag 2.0.1\nlatest\n</code></pre> Source code in <code>m/cli/commands/ci/npm_tag.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Display an npm tag assigned to given version.\n\n    examples::\n\n        ~$ m ci npm_tag 0.0.0-develop.b123\n        develop\n\n        ~$ m ci npm_tag 0.0.0-pr1234.b123\n        pr1234\n\n        ~$ m ci npm_tag 2.0.1-rc1234.b123\n        next\n\n        ~$ m ci npm_tag 2.0.1\n        latest\n    \"\"\"\n\n    npm_tag: str = Arg(\n        help='npm package version',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/ci/npm_tag/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/npm_tag/#npm_tag","title":"<code>npm_tag</code>","text":"<p>npm package version</p>"},{"location":"cli/ci/release_setup/","title":"m ci release_setup","text":"<p>Update the config and changelog files.</p> Source code in <code>m/cli/commands/ci/release_setup.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Update the config and changelog files.\"\"\"\n\n    changelog: str = Arg(\n        default='CHANGELOG.md',\n        help='CHANGELOG filename',\n    )\n    m_dir: str = Arg(\n        help='m project directory',\n        positional=True,\n        required=True,\n    )\n    new_ver: str = Arg(\n        help='the new version',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/ci/release_setup/#options","title":"Options","text":""},{"location":"cli/ci/release_setup/#changelog","title":"<code>--changelog</code>","text":"<ul><li>default: <code>'CHANGELOG.md'</code></li></ul> <p>CHANGELOG filename</p>"},{"location":"cli/ci/release_setup/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/ci/release_setup/#m_dir","title":"<code>m_dir</code>","text":"<p>m project directory</p>"},{"location":"cli/ci/release_setup/#new_ver","title":"<code>new_ver</code>","text":"<p>the new version</p>"},{"location":"cli/devcontainer/bashrc/","title":"m devcontainer bashrc","text":"<p>Print a bash snippet of setup instructions.</p> <p>This snippet can be used in a <code>.bashrc</code> file to setup the environment. It will also provide aliases that call other <code>m</code> commands to help facilitate the development in a devcontainer workflow.</p> Source code in <code>m/cli/commands/devcontainer/bashrc.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Print a bash snippet of setup instructions.\n\n    This snippet can be used in a `.bashrc` file to setup the environment.\n    It will also provide aliases that call other `m` commands to help\n    facilitate the development in a devcontainer workflow.\n\n    \"\"\"\n\n    section: str | None = ArgProxy(\n        '--section',\n        choices=['env', 'devex', 'venv'],\n        help='section to print out',\n    )\n</code></pre>"},{"location":"cli/devcontainer/bashrc/#options","title":"Options","text":""},{"location":"cli/devcontainer/bashrc/#section","title":"<code>--section</code>","text":"<ul><li>choices: <code>env</code>, <code>devex</code>, <code>venv</code></li></ul> <p>section to print out</p>"},{"location":"cli/devcontainer/greet/","title":"m devcontainer greet","text":"<p>Add a log message providing basic information about the devcontainer.</p> Source code in <code>m/cli/commands/devcontainer/greet.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Add a log message providing basic information about the devcontainer.\"\"\"\n\n    img_name: str = Arg(help='name of the docker image', required=True)\n    img_version: str = Arg(help='version of the docker image', required=True)\n    changelog_url: str | None = Arg(default=None, help='url to the changelog')\n</code></pre>"},{"location":"cli/devcontainer/greet/#required-arguments","title":"Required arguments","text":""},{"location":"cli/devcontainer/greet/#img_name","title":"<code>--img-name</code>","text":"<p>name of the docker image</p>"},{"location":"cli/devcontainer/greet/#img_version","title":"<code>--img-version</code>","text":"<p>version of the docker image</p>"},{"location":"cli/devcontainer/greet/#options","title":"Options","text":""},{"location":"cli/devcontainer/greet/#changelog_url","title":"<code>--changelog-url</code>","text":"<ul><li>default: <code>None</code></li></ul> <p>url to the changelog</p>"},{"location":"cli/devcontainer/pnpm/","title":"m devcontainer pnpm","text":"<p>Run pnpm in the devcontainer.</p> <p>This command is meant to be used as an alias for <code>pnpm</code> in a devcontainer. If you want view the help for the <code>pnpm</code> command you can run::</p> <pre><code>command pnpm --help\n</code></pre> <p>Depending on the pnpm command that we want to run, this command will change the working directory to the mounted volume and execute the pnpm command.</p> <p>Currently the main commands that will be executed in the mounted volume are</p> <ul> <li>add</li> <li>install</li> <li>remove</li> <li>uninstall</li> </ul> <p>If you need to run other commands in the mounted volume you can use the <code>--force-cd</code> flag.</p> Source code in <code>m/cli/commands/devcontainer/pnpm.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Run pnpm in the devcontainer.\n\n    This command is meant to be used as an alias for `pnpm` in a devcontainer.\n    If you want view the help for the `pnpm` command you can run::\n\n        command pnpm --help\n\n    Depending on the pnpm command that we want to run, this command will change\n    the working directory to the mounted volume and execute the pnpm command.\n\n    Currently the main commands that will be executed in the mounted volume\n    are\n\n    - add\n    - install\n    - remove\n    - uninstall\n\n    If you need to run other commands in the mounted volume you can use the\n    `--force-cd` flag.\n    \"\"\"\n\n    force_cd: bool = Arg(default=False, help='force `cd` to the mounted volume')\n\n    pnpm_args: list[str] = RemainderArgs(help='arguments to pass to pnpm')\n</code></pre>"},{"location":"cli/devcontainer/pnpm/#options","title":"Options","text":""},{"location":"cli/devcontainer/pnpm/#force_cd","title":"<code>--force-cd</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>force <code>cd</code> to the mounted volume</p>"},{"location":"cli/devcontainer/pnpm/#pnpm_args","title":"<code>pnpm_args</code>","text":"<ul><li>default: <code>[]</code></li></ul> <p>arguments to pass to pnpm</p>"},{"location":"cli/devcontainer/pnpm_setup/","title":"m devcontainer pnpm_setup","text":"<p>Setup pnpm in the devcontainer.</p> <p>This command is meant run from inside the devcontainer. It will create several symbolic links so that the pnpm data may be stored in a volume and thus be able to be shared with other devcontainers.</p> Source code in <code>m/cli/commands/devcontainer/pnpm_setup.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Setup pnpm in the devcontainer.\n\n    This command is meant run from inside the devcontainer. It will\n    create several symbolic links so that the pnpm data may be stored in a\n    volume and thus be able to be shared with other devcontainers.\n    \"\"\"\n\n    work_dir: str = Arg(\n        help='the work directory containing package.json',\n        positional=True,\n        required=True,\n    )\n\n    pnpm_dir: str = Arg(\n        help='the directory where pnpm data will be stored',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/devcontainer/pnpm_setup/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/devcontainer/pnpm_setup/#work_dir","title":"<code>work_dir</code>","text":"<p>the work directory containing package.json</p>"},{"location":"cli/devcontainer/pnpm_setup/#pnpm_dir","title":"<code>pnpm_dir</code>","text":"<p>the directory where pnpm data will be stored</p>"},{"location":"cli/devcontainer/prompter/","title":"m devcontainer prompter","text":"<p>Command line prompter.</p> <p>The goal is to display useful git information in the shell prompt.</p> Source code in <code>m/cli/commands/devcontainer/prompter.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Command line prompter.\n\n    The goal is to display useful git information in the shell prompt.\n    \"\"\"\n</code></pre>"},{"location":"cli/devcontainer/require_env_vars/","title":"m devcontainer require_env_vars","text":"<p>Verify that the required environment variables are set.</p> <p>Exists with non-zero exit code if any of the required environment variables are not set.</p> Source code in <code>m/cli/commands/devcontainer/require_env_vars.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Verify that the required environment variables are set.\n\n    Exists with non-zero exit code if any of the required environment variables\n    are not set.\n    \"\"\"\n\n    env_vars: list[str] = Arg(\n        help='environment variables to check',\n        nargs='+',\n        positional=True,\n    )\n</code></pre>"},{"location":"cli/devcontainer/require_env_vars/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/devcontainer/require_env_vars/#env_vars","title":"<code>env_vars</code>","text":"<p>environment variables to check</p>"},{"location":"cli/git/branch/","title":"m git branch","text":"<p>Display the current git branch name.</p> <p>example::</p> <pre><code>$ m git branch\nmaster\n</code></pre> Source code in <code>m/cli/commands/git/branch.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Display the current git branch name.\n\n    example::\n\n        $ m git branch\n        master\n    \"\"\"\n</code></pre>"},{"location":"cli/git/current_sha/","title":"m git current_sha","text":"<p>Display the current commit sha.</p> <p>example::</p> <pre><code>$ m git current_sha\n74075a3ea5c9252a0f2b9fd6b095567b3b9b4028\n</code></pre> Source code in <code>m/cli/commands/git/current_sha.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Display the current commit sha.\n\n    example::\n\n        $ m git current_sha\n        74075a3ea5c9252a0f2b9fd6b095567b3b9b4028\n    \"\"\"\n</code></pre>"},{"location":"cli/git/first_sha/","title":"m git first_sha","text":"<p>Display the very first commit sha in the repository.</p> <p>example::</p> <pre><code>$ m git first_sha\nbf286e270e13c75dfed289a3921289092477c058\n</code></pre> Source code in <code>m/cli/commands/git/first_sha.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Display the very first commit sha in the repository.\n\n    example::\n\n        $ m git first_sha\n        bf286e270e13c75dfed289a3921289092477c058\n    \"\"\"\n</code></pre>"},{"location":"cli/git/status/","title":"m git status","text":"<p>Display a single word representing the current git status.</p> <p>example::</p> <pre><code>$ m git status\nclean\n</code></pre> <p>statuses::</p> <pre><code>unknown\nuntracked\nclean\nahead\nbehind\nstaged\ndirty\ndiverged\n?\n</code></pre> <p>If you want to check for stashed changes, use the <code>--check-stashed</code> flag.</p> Source code in <code>m/cli/commands/git/status.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Display a single word representing the current git status.\n\n    example::\n\n        $ m git status\n        clean\n\n    statuses::\n\n        unknown\n        untracked\n        clean\n        ahead\n        behind\n        staged\n        dirty\n        diverged\n        ?\n\n    If you want to check for stashed changes, use the `--check-stashed` flag.\n    \"\"\"\n\n    check_stashed: bool = Arg(\n        default=False,\n        help='check if there are any stashed changes',\n    )\n</code></pre>"},{"location":"cli/git/status/#options","title":"Options","text":""},{"location":"cli/git/status/#check_stashed","title":"<code>--check-stashed</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>check if there are any stashed changes</p>"},{"location":"cli/git/tag_release/","title":"m git tag_release","text":"<p>Supplement to <code>m github release</code>.</p> <p>This command needs the <code>git</code> cli and it is meant to be run after <code>m github release</code> to create a major and minor release tags.</p> <p>example::</p> <pre><code>$ m git tag_release --version 1.2.3\n</code></pre> <p>It will create or update the following tags::</p> <pre><code>-v1\n-v1.2\n</code></pre> <p>Note that the tags may be moved with each release to point to the latest release. This is done by deleting the tag and creating it again.</p> Source code in <code>m/cli/commands/git/tag_release.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Supplement to `m github release`.\n\n    This command needs the `git` cli and it is meant to be run after\n    `m github release` to create a major and minor release tags.\n\n\n    example::\n\n        $ m git tag_release --version 1.2.3\n\n\n    It will create or update the following tags::\n\n        -v1\n        -v1.2\n\n    Note that the tags may be moved with each release to point to the latest\n    release. This is done by deleting the tag and creating it again.\n    \"\"\"\n\n    version: str = Arg(\n        help='version to create tags from',\n        required=True,\n    )\n    sha: str = Arg(\n        default='',\n        help='sha to tag',\n    )\n    major_only: bool = Arg(\n        default=False,\n        help='only create major tag',\n    )\n</code></pre>"},{"location":"cli/git/tag_release/#required-arguments","title":"Required arguments","text":""},{"location":"cli/git/tag_release/#version","title":"<code>--version</code>","text":"<p>version to create tags from</p>"},{"location":"cli/git/tag_release/#options","title":"Options","text":""},{"location":"cli/git/tag_release/#sha","title":"<code>--sha</code>","text":"<ul><li>default: <code>''</code></li></ul> <p>sha to tag</p>"},{"location":"cli/git/tag_release/#major_only","title":"<code>--major-only</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>only create major tag</p>"},{"location":"cli/github/branch_prs/","title":"m github branch_prs","text":"<p>Retrieve pull requests associated with a branch.</p> <p>example::</p> <pre><code>$ m github branch_prs --owner jmlopez-rod --repo m release/0.18.0\n</code></pre> <p></p> Source code in <code>m/cli/commands/github/branch_prs.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Retrieve pull requests associated with a branch.\n\n    example::\n\n        $ m github branch_prs --owner jmlopez-rod --repo m release/0.18.0\n\n    ![preview](../../assets/branch_prs.svg)\n    \"\"\"\n\n    pretty: bool = Arg(\n        default=False,\n        help='format json payload with indentation',\n    )\n    yaml: bool = Arg(\n        default=False,\n        help='use yaml format',\n    )\n    owner: str = Arg(\n        default='GITHUB_REPOSITORY_OWNER',\n        validator=env_var,\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    branch: str = Arg(\n        help='branch name',\n        required=True,\n        positional=True,\n    )\n</code></pre>"},{"location":"cli/github/branch_prs/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/branch_prs/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/branch_prs/#options","title":"Options","text":""},{"location":"cli/github/branch_prs/#pretty","title":"<code>--pretty</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>format json payload with indentation</p>"},{"location":"cli/github/branch_prs/#yaml","title":"<code>--yaml</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>use yaml format</p>"},{"location":"cli/github/branch_prs/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>env.GITHUB_REPOSITORY_OWNER</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/branch_prs/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/github/branch_prs/#branch","title":"<code>branch</code>","text":"<p>branch name</p>"},{"location":"cli/github/build_sha/","title":"m github build_sha","text":"<p>Provide the build sha.</p> <p>Given the GITHUB_SHA (a merge commit it fetches the sha of the actual commit we thought we were building.</p> <p>example::</p> <pre><code>$ m github build_sha \\\n    --owner jmlopez-rod \\\n    --repo m \\\n    --sha 6bf3a8095891c551043877b922050d5b01d20284\nfa6a600729ffbe1dfd7fece76ef4566e45fbfe40\n</code></pre> <p>The sha can be obtained in Github by looking at the output of the checkout action.</p> <p>The <code>owner</code> option defaults to the value of the environment variable <code>GITHUB_REPOSITORY_OWNER</code>.</p> Source code in <code>m/cli/commands/github/build_sha.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Provide the build sha.\n\n    Given the GITHUB_SHA (a merge commit it fetches the sha of the actual\n    commit we thought we were building.\n\n    example::\n\n        $ m github build_sha \\\n            --owner jmlopez-rod \\\n            --repo m \\\n            --sha 6bf3a8095891c551043877b922050d5b01d20284\n        fa6a600729ffbe1dfd7fece76ef4566e45fbfe40\n\n    The sha can be obtained in Github by looking at the output of the\n    checkout action.\n\n    The `owner` option defaults to the value of the environment variable\n    `GITHUB_REPOSITORY_OWNER`.\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    sha: str = Arg(\n        help='commit sha',\n        required=True,\n    )\n</code></pre>"},{"location":"cli/github/build_sha/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/build_sha/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/build_sha/#sha","title":"<code>--sha</code>","text":"<p>commit sha</p>"},{"location":"cli/github/build_sha/#options","title":"Options","text":""},{"location":"cli/github/build_sha/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/ci/","title":"m github ci","text":"<p>Retrieve the information required for continuous integration.</p> <p>example::</p> <pre><code>$ m github ci \\\n    --owner jmlopez-rod \\\n    --repo pysync \\\n    --sha 4538b2a2556efcbdfc1e7df80c4f71ade45f3958 \\\n    --pr 1 \\\n    --include-release | m json\n{\n\"commit\": {\n    \"associatedPullRequests\": {\n    \"nodes\": [\n        {\n        \"author\": {\n            \"login\": \"jmlopez-rod\",\n            \"avatarUrl\": \"https://avatars.githubusercontent.com/...\",\n            \"email\": \"\"\n        },\n...\n</code></pre> <p>NOTE: Use the --merge-commit flag if you are providing a sha from github actions.</p> Source code in <code>m/cli/commands/github/ci.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Retrieve the information required for continuous integration.\n\n    example::\n\n        $ m github ci \\\n            --owner jmlopez-rod \\\n            --repo pysync \\\n            --sha 4538b2a2556efcbdfc1e7df80c4f71ade45f3958 \\\n            --pr 1 \\\n            --include-release | m json\n        {\n        \"commit\": {\n            \"associatedPullRequests\": {\n            \"nodes\": [\n                {\n                \"author\": {\n                    \"login\": \"jmlopez-rod\",\n                    \"avatarUrl\": \"https://avatars.githubusercontent.com/...\",\n                    \"email\": \"\"\n                },\n        ...\n\n    NOTE: Use the --merge-commit flag if you are providing a sha from\n    github actions.\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    sha: str = Arg(\n        help='commit sha',\n        required=True,\n    )\n    pr: int | None = Arg(help='pull request number')\n    file_count: int = Arg(\n        default=10,\n        help='max number of files to retrieve',\n    )\n    include_release: bool = Arg(\n        default=False,\n        help='include the last release information',\n    )\n    merge_commit: bool = Arg(\n        default=False,\n        help='set if the sha is a merge commit sha (from github)',\n    )\n</code></pre>"},{"location":"cli/github/ci/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/ci/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/ci/#sha","title":"<code>--sha</code>","text":"<p>commit sha</p>"},{"location":"cli/github/ci/#options","title":"Options","text":""},{"location":"cli/github/ci/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/ci/#pr","title":"<code>--pr</code>","text":"<p>pull request number</p>"},{"location":"cli/github/ci/#file_count","title":"<code>--file-count</code>","text":"<ul><li>default: <code>10</code></li></ul> <p>max number of files to retrieve</p>"},{"location":"cli/github/ci/#include_release","title":"<code>--include-release</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>include the last release information</p>"},{"location":"cli/github/ci/#merge_commit","title":"<code>--merge-commit</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>set if the sha is a merge commit sha (from github)</p>"},{"location":"cli/github/create_pr/","title":"m github create_pr","text":"<p>Create a pull request.</p> <p>https://docs.github.com/en/rest/reference/pulls#create-a-pull-request</p> <p>example::</p> <pre><code>$ m github create_pr \\\n    --owner jmlopez-rod \\\n    --repo repo \\\n    --head feature_branch \\\n    --base master \\\n    --title 'PR Title' \\\n    @file_with_pr_body | m json\n</code></pre> Source code in <code>m/cli/commands/github/create_pr.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Create a pull request.\n\n    https://docs.github.com/en/rest/reference/pulls#create-a-pull-request\n\n    example::\n\n        $ m github create_pr \\\n            --owner jmlopez-rod \\\n            --repo repo \\\n            --head feature_branch \\\n            --base master \\\n            --title 'PR Title' \\\n            @file_with_pr_body | m json\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    head: str = Arg(\n        help='name of the branch where the changes are implemented',\n        required=True,\n    )\n    base: str = Arg(\n        help='name of the branch you want the changes pulled into',\n        required=True,\n    )\n    title: str = Arg(\n        help='pull request title',\n        required=True,\n    )\n    body: str = Arg(\n        default='@-',\n        help='data: @- (stdin), @filename (file), string',\n        validator=validate_payload,\n        positional=True,\n    )\n</code></pre>"},{"location":"cli/github/create_pr/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/create_pr/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/create_pr/#head","title":"<code>--head</code>","text":"<p>name of the branch where the changes are implemented</p>"},{"location":"cli/github/create_pr/#base","title":"<code>--base</code>","text":"<p>name of the branch you want the changes pulled into</p>"},{"location":"cli/github/create_pr/#title","title":"<code>--title</code>","text":"<p>pull request title</p>"},{"location":"cli/github/create_pr/#options","title":"Options","text":""},{"location":"cli/github/create_pr/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/create_pr/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/github/create_pr/#body","title":"<code>body</code>","text":"<ul><li>default: <code>'@-'</code></li></ul> <p>data: @- (stdin), @filename (file), string</p>"},{"location":"cli/github/latest_release/","title":"m github latest_release","text":"<p>Retrieve the latest release.</p> <p>example::</p> <pre><code>$ m github latest_release --owner microsoft --repo typescript\n</code></pre> Source code in <code>m/cli/commands/github/latest_release.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Retrieve the latest release.\n\n    example::\n\n        $ m github latest_release --owner microsoft --repo typescript\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n</code></pre>"},{"location":"cli/github/latest_release/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/latest_release/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/latest_release/#options","title":"Options","text":""},{"location":"cli/github/latest_release/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/merge_pr/","title":"m github merge_pr","text":"<p>Merge a pull request.</p> <p>https://docs.github.com/en/rest/reference/pulls#merge-a-pull-request</p> <p>example::</p> <pre><code>$ m github merge_pr \\\\\n    --owner owner \\\\\n    --repo repo \\\\\n    --commit-title 'commit_title' \\\\\n    99\n</code></pre> Source code in <code>m/cli/commands/github/merge_pr.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Merge a pull request.\n\n    https://docs.github.com/en/rest/reference/pulls#merge-a-pull-request\n\n    example::\n\n        $ m github merge_pr \\\\\n            --owner owner \\\\\n            --repo repo \\\\\n            --commit-title 'commit_title' \\\\\n            99\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    commit_title: str | None = Arg(\n        help='commit title',\n    )\n    pr: int = Arg(\n        help='the pr number',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/github/merge_pr/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/merge_pr/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/merge_pr/#options","title":"Options","text":""},{"location":"cli/github/merge_pr/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/merge_pr/#commit_title","title":"<code>--commit-title</code>","text":"<p>commit title</p>"},{"location":"cli/github/merge_pr/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/github/merge_pr/#pr","title":"<code>pr</code>","text":"<p>the pr number</p>"},{"location":"cli/github/pr/","title":"m github pr","text":"<p>Retrieve a pull request information.</p> <p>example::</p> <pre><code>$ m github pr --owner microsoft --repo typescript 44710 | m json\n{\n    \"headRefName\": \"ReduceExceptions\",\n    \"headRefOid\": \"d9ae52cf49732a2d45b6cb7f4069205c88af39eb\",\n    \"baseRefName\": \"main\",\n    \"baseRefOid\": \"6452cfbad0afcc6d09b75e0a1e32da1d07e0b7ca\",\n    \"title\": \"Reduce exceptions\",\n    \"body\": \"...\n</code></pre> <p>Or use the <code>--pretty</code> option to avoid piping.</p> Source code in <code>m/cli/commands/github/pr.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Retrieve a pull request information.\n\n    example::\n\n        $ m github pr --owner microsoft --repo typescript 44710 | m json\n        {\n            \"headRefName\": \"ReduceExceptions\",\n            \"headRefOid\": \"d9ae52cf49732a2d45b6cb7f4069205c88af39eb\",\n            \"baseRefName\": \"main\",\n            \"baseRefOid\": \"6452cfbad0afcc6d09b75e0a1e32da1d07e0b7ca\",\n            \"title\": \"Reduce exceptions\",\n            \"body\": \"...\n\n    Or use the `--pretty` option to avoid piping.\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    files: int = Arg(\n        default=10,\n        help='max number of files to retrieve',\n    )\n    pretty: bool = Arg(\n        default=False,\n        help='format json payload with indentation',\n    )\n    yaml: bool = Arg(\n        default=False,\n        help='use yaml format',\n    )\n    pr_number: int = Arg(\n        help='the pr number',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/github/pr/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/pr/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/pr/#options","title":"Options","text":""},{"location":"cli/github/pr/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/pr/#files","title":"<code>--files</code>","text":"<ul><li>default: <code>10</code></li></ul> <p>max number of files to retrieve</p>"},{"location":"cli/github/pr/#pretty","title":"<code>--pretty</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>format json payload with indentation</p>"},{"location":"cli/github/pr/#yaml","title":"<code>--yaml</code>","text":"<ul><li>default: <code>false</code></li></ul> <p>use yaml format</p>"},{"location":"cli/github/pr/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/github/pr/#pr_number","title":"<code>pr_number</code>","text":"<p>the pr number</p>"},{"location":"cli/github/release/","title":"m github release","text":"<p>Create a release in Github.</p> <p>https://docs.github.com/en/rest/reference/repos#create-a-release</p> <p>example::</p> <pre><code>$ m github release \\\n    --owner jmlopez-rod \\\n    --repo pysync \\\n    --version 1.0.0\n</code></pre> <p>The <code>owner</code> option defaults to the value of the environment variable <code>GITHUB_REPOSITORY_OWNER</code>.</p> Source code in <code>m/cli/commands/github/release.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Create a release in Github.\n\n    https://docs.github.com/en/rest/reference/repos#create-a-release\n\n    example::\n\n        $ m github release \\\n            --owner jmlopez-rod \\\n            --repo pysync \\\n            --version 1.0.0\n\n    The `owner` option defaults to the value of the environment variable\n    `GITHUB_REPOSITORY_OWNER`.\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    version: str = Arg(\n        help='version to release',\n        required=True,\n    )\n    branch: str | None = Arg(\n        help='The branch where the git tag will be created',\n    )\n</code></pre>"},{"location":"cli/github/release/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/release/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/release/#version","title":"<code>--version</code>","text":"<p>version to release</p>"},{"location":"cli/github/release/#options","title":"Options","text":""},{"location":"cli/github/release/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/release/#branch","title":"<code>--branch</code>","text":"<p>The branch where the git tag will be created</p>"},{"location":"cli/github/status/","title":"m github status","text":"<p>Create a commit status.</p> <ul> <li>https://docs.github.com/en/rest/reference/repos#create-a-commit-status</li> </ul> <p>example::</p> <pre><code>$ m github status \\\n    --owner jmlopez-rod \\\n    --repo pysync \\\n    --sha [sha] \\\n    --context github-check \\\n    --state pending \\\n    --description 'running checks'\n</code></pre> <p>The <code>owner</code> option defaults to the value of the environment variable <code>GITHUB_REPOSITORY_OWNER</code>.</p> Source code in <code>m/cli/commands/github/status.py</code> <pre><code>class Arguments(BaseModel):\n    r\"\"\"Create a commit status.\n\n    - https://docs.github.com/en/rest/reference/repos#create-a-commit-status\n\n    example::\n\n        $ m github status \\\n            --owner jmlopez-rod \\\n            --repo pysync \\\n            --sha [sha] \\\n            --context github-check \\\n            --state pending \\\n            --description 'running checks'\n\n    The `owner` option defaults to the value of the environment variable\n    `GITHUB_REPOSITORY_OWNER`.\n    \"\"\"\n\n    owner: str = Arg(\n        default=env('GITHUB_REPOSITORY_OWNER'),\n        help='repo owner',\n    )\n    repo: str = Arg(\n        help='repo name',\n        required=True,\n    )\n    sha: str = Arg(\n        help='commit sha',\n        required=True,\n    )\n    context: str = Arg(\n        help='unique identifier for the status (a name?)',\n        required=True,\n    )\n    state: str = ArgProxy(\n        '--state',\n        required=True,\n        choices=['error', 'failure', 'pending', 'success'],\n        help='the state of the status',\n    )\n    description: str = Arg(\n        help='a short description of the status',\n        required=True,\n    )\n    url: str | None = Arg(\n        help='URL to associate with this status',\n    )\n</code></pre>"},{"location":"cli/github/status/#required-arguments","title":"Required arguments","text":""},{"location":"cli/github/status/#repo","title":"<code>--repo</code>","text":"<p>repo name</p>"},{"location":"cli/github/status/#sha","title":"<code>--sha</code>","text":"<p>commit sha</p>"},{"location":"cli/github/status/#context","title":"<code>--context</code>","text":"<p>unique identifier for the status (a name?)</p>"},{"location":"cli/github/status/#description","title":"<code>--description</code>","text":"<p>a short description of the status</p>"},{"location":"cli/github/status/#options","title":"Options","text":""},{"location":"cli/github/status/#owner","title":"<code>--owner</code>","text":"<ul><li>default: <code>'jmlopez-rod'</code></li></ul> <p>repo owner</p>"},{"location":"cli/github/status/#state","title":"<code>--state</code>","text":"<ul><li>choices: <code>error</code>, <code>failure</code>, <code>pending</code>, <code>success</code></li></ul> <p>the state of the status</p>"},{"location":"cli/github/status/#url","title":"<code>--url</code>","text":"<p>URL to associate with this status</p>"},{"location":"cli/message/close/","title":"m message close","text":"<p>Close a block.</p> <p>When a block is closed, all its inner blocks are closed automatically. Not all CI Tools support nesting.</p> Source code in <code>m/cli/commands/message/close.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Close a block.\n\n    When a block is closed, all its inner blocks are closed automatically.\n    Not all CI Tools support nesting.\n    \"\"\"\n\n    name: str = Arg(\n        help='block name to close',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/message/close/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/message/close/#name","title":"<code>name</code>","text":"<p>block name to close</p>"},{"location":"cli/message/error/","title":"m message error","text":"<p>Report an error.</p> <p>example::</p> <pre><code>~$ m message error 'this is an error'\n::error::this is an error\n~$ echo $?\n1\n</code></pre> <p>The procedure exits with non-zero code.</p> Source code in <code>m/cli/commands/message/error.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Report an error.\n\n    example::\n\n        ~$ m message error 'this is an error'\n        ::error::this is an error\n        ~$ echo $?\n        1\n\n    The procedure exits with non-zero code.\n    \"\"\"\n\n    message: str = Arg(\n        help='error message',\n        positional=True,\n        required=True,\n    )\n    file: str | None = Arg(  # noqa: WPS110 - required by Github\n        aliases=['f', 'file'],\n        help='filename where error occurred',\n    )\n    line: str | None = Arg(\n        aliases=['l', 'line'],\n        help='line where error occurred',\n    )\n    col: str | None = Arg(\n        aliases=['c', 'col'],\n        help='column where error occurred',\n    )\n</code></pre>"},{"location":"cli/message/error/#options","title":"Options","text":""},{"location":"cli/message/error/#file","title":"<code>-f</code>, <code>--file</code>","text":"<p>filename where error occurred</p>"},{"location":"cli/message/error/#line","title":"<code>-l</code>, <code>--line</code>","text":"<p>line where error occurred</p>"},{"location":"cli/message/error/#col","title":"<code>-c</code>, <code>--col</code>","text":"<p>column where error occurred</p>"},{"location":"cli/message/error/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/message/error/#message","title":"<code>message</code>","text":"<p>error message</p>"},{"location":"cli/message/open/","title":"m message open","text":"<p>Open a block to group several messages in the build log.</p> Source code in <code>m/cli/commands/message/open.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Open a block to group several messages in the build log.\"\"\"\n\n    name: str = Arg(\n        help='block name to open',\n        positional=True,\n        required=True,\n    )\n    description: str = Arg(\n        help='block description',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/message/open/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/message/open/#name","title":"<code>name</code>","text":"<p>block name to open</p>"},{"location":"cli/message/open/#description","title":"<code>description</code>","text":"<p>block description</p>"},{"location":"cli/message/sibling_block/","title":"m message sibling_block","text":"<p>Close and immediately open another block.</p> Source code in <code>m/cli/commands/message/sibling_block.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Close and immediately open another block.\"\"\"\n\n    to_close: str = Arg(\n        help='block name to close',\n        positional=True,\n        required=True,\n    )\n    name: str = Arg(\n        help='block name to open',\n        positional=True,\n        required=True,\n    )\n    description: str = Arg(\n        help='block description',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/message/sibling_block/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/message/sibling_block/#to_close","title":"<code>to_close</code>","text":"<p>block name to close</p>"},{"location":"cli/message/sibling_block/#name","title":"<code>name</code>","text":"<p>block name to open</p>"},{"location":"cli/message/sibling_block/#description","title":"<code>description</code>","text":"<p>block description</p>"},{"location":"cli/message/warn/","title":"m message warn","text":"<p>Report a warning.</p> <p>example::</p> <pre><code>~$ m message warn 'this is a warning' -f app.js -l 1 -c 5\n::warning file=app.js,line=1,col=5::Missing semicolon\n</code></pre> Source code in <code>m/cli/commands/message/warn.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Report a warning.\n\n    example::\n\n        ~$ m message warn 'this is a warning' -f app.js -l 1 -c 5\n        ::warning file=app.js,line=1,col=5::Missing semicolon\n    \"\"\"\n\n    message: str = Arg(\n        help='warning message',\n        positional=True,\n        required=True,\n    )\n    file: str | None = Arg(  # noqa: WPS110 - required by Github\n        aliases=['f', 'file'],\n        help='filename where warning occurred',\n    )\n    line: str | None = Arg(\n        aliases=['l', 'line'],\n        help='line where warning occurred',\n    )\n    col: str | None = Arg(\n        aliases=['c', 'col'],\n        help='column where warning occurred',\n    )\n</code></pre>"},{"location":"cli/message/warn/#options","title":"Options","text":""},{"location":"cli/message/warn/#file","title":"<code>-f</code>, <code>--file</code>","text":"<p>filename where warning occurred</p>"},{"location":"cli/message/warn/#line","title":"<code>-l</code>, <code>--line</code>","text":"<p>line where warning occurred</p>"},{"location":"cli/message/warn/#col","title":"<code>-c</code>, <code>--col</code>","text":"<p>column where warning occurred</p>"},{"location":"cli/message/warn/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/message/warn/#message","title":"<code>message</code>","text":"<p>warning message</p>"},{"location":"cli/npm/clean_tags/","title":"m npm clean_tags","text":"<p>Remove empty npm tags.</p> <pre><code>$ m npm clean_tags @scope/package\n</code></pre> <p>When packages are removed there will be empty tags that point to nothing. This command will find those empty tags and remove them.</p> Source code in <code>m/cli/commands/npm/clean_tags.py</code> <pre><code>class Arguments(BaseModel):\n    \"\"\"Remove empty npm tags.\n\n        $ m npm clean_tags @scope/package\n\n    When packages are removed there will be empty tags that point to nothing.\n    This command will find those empty tags and remove them.\n    \"\"\"\n\n    package_name: str = Arg(\n        help='name of the npm package',\n        positional=True,\n        required=True,\n    )\n</code></pre>"},{"location":"cli/npm/clean_tags/#positional-arguments","title":"Positional arguments","text":""},{"location":"cli/npm/clean_tags/#package_name","title":"<code>package_name</code>","text":"<p>name of the npm package</p>"}]}