---
sidebar_position: 30
sidebar_label: API
---

# Testing

`m` provides several utilities to help us test our actions. We can start with
this example

```python
import pytest
from m.github.actions import Action
from m.testing import ActionStepTestCase as TCase
from m.testing import run_action_test_case
from pytest_mock import MockerFixture

from pkg.actions import actions


@pytest.mark.parametrize(
    'tcase',
    [
        TCase(
            name='test_id',
            py_file=f'src/pkg/main.py',
            inputs={
              'INPUT_ARG_A': 'val_a',
              'INPUT_ARG_B': 'val_b',
            },
            expected_stdout='Anything we print to stdout',
            outputs=['some-output=some_value'],
        ),
    ],
    ids=lambda tcase: tcase.name,
)
def test_m_gh_actions_api(tcase: TCase, mocker: MockerFixture) -> None:
    run_action_test_case(mocker, tcase)


def test_actions_instance() -> None:
    assert isinstance(actions, Action)
    assert actions.name == 'Action Name'
```

:::important

This is not required but it is recommended to have this in the `__init__.py` for
the root of the tests.

```python
from m.testing import block_m_side_effects, block_network_access

block_m_side_effects()
block_network_access()
```

This will make sure that our tests do not make any calls to the internet and
prevents out code from writing files. Instead it will force us to create mocks.

:::

## Testing API

### `block_network_access`

This function overrides the definition of `socket` so that we do not accidently
try to run tests that make network calls. If our tests do not depend on other
local services it is a good idea to call this before any of our tests runs.

Otherwise we may want to modify this function to allow certain hosts to be
called. (PRs welcomed).

### `block_m_side_effects`

This function overrides the definition of `m` so that we do not accidently try
write a lot of files or create/move directories.

The function will return a dictionary with references to the original functions
that were overriden in case these are needed.

### `ActionStepTestCase`

This class is used to define a test case for an action. It is helpful to
parametrize different use cases for an action.

- `name`: The name of the test case. This is used to identify the test case in
  the test report.
- `py_file`. The full path to the file that Github Actions will run.
- `inputs`: A dictionary of the inputs that the action will receive.
- `exit_code`: The expected exit code of the action. `0` means all is good.
- `expected_stdout`: The expected output of the action. This is what we print to
  stdout. The output should match. If this is a long output it may be worth
  reading from fixture and assigning the value instead.
- `errors`: A list of strings that should be present in `stderr`. This is
  helpful to make sure our actions are reporting useful error messages to help
  us debug.
- `outputs`: A list of strings that should be present in `$GITHUB_OUTPUT` file.
  Each entry in the array should be of the form `output-name=output_value`.
- `file_write_side_effect`: This can be provided if we need to modify the
  behaviour of `m.core.rw.write_file`. This is useful if we want to test cases
  in which a file failed to write.

### `run_action_test_case`

This is a commodity wrapper to help us run the action tests case. If we need
more control over the assertions we can then copy and modify the implementation.

- `mocker`: A reference to the pytest `MockerFixture`.
- `tcase`: The test case to run.

### `run_action_step`

Runs an action step. This is useful since it will run the module and assert that
the exit code is the one we expect. It returns a tuple with the stdout, stderr
and a dictionary or the files writen by `m.core.rw.write_file`.

- `mocker`: A reference to the pytest `MockerFixture`.
- `py_file`: The full path to the file that Github Actions will run.
- `exit_code`: The expected exit code of the action. `0` means all is good.
- `env_vars`: A dictionary of the environment variables that the action will
  receive.
- `file_write_side_effect`: This can be provided if we need to modify the
  behaviour of `m.core.rw.write_file`. This is useful if we want to test cases
  in which a file failed to write.
