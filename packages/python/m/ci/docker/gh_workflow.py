from textwrap import dedent
from typing import Any

from m.core import yaml
from pydantic import BaseModel

from .image import DockerImage

TEMPLATE = """\
# AUTOGENERATED FILE - Update {m_dir}/m.yaml
#   then run `m blueprints --update-workflow` to update
name: m

on:
  workflow_call:
    inputs:
      m-tag:
        type: string
        description: The unique version to use for all the images
        required: true
      cache-from-pr:
        type: string
        description: The pull request number to attempt to use as cache.
        required: true

permissions: write-all

env: {global_env}

jobs:
  blueprints:
    runs-on: {default_runner}
    outputs:
      image-names: ${{{{ steps.m-blueprints.outputs.image-names }}}}
      image-tags: ${{{{ steps.m-blueprints.outputs.image-tags }}}}
    steps:
      - name: checkout
        uses: actions/checkout@v4
      - name: install-m
        run: pip install git+https://github.com/jmlopez-rod/m.git@topic/docker
      - name: m-blueprints
        id: m-blueprints
        run: |-
          m blueprints
          {{
            echo 'image-names=$(cat {ci_dir}/_image-names.json)'
            echo 'image-tags=$(cat {ci_dir}/_image-tags.json)'
          }} >> $GITHUB_OUTPUT
      - name: archive
        uses: actions/upload-artifact@v3
        with:
          name: m-blueprints
          path: {ci_dir}

  build:
    needs: blueprints
    strategy:
      fast-fail: false
      matrix:
        include: {build_architectures}
    runs-on: ${{{{ matrix.os }}}}
    env:
      ARCH: ${{{{ matrix.arch }}}}
    steps:
      - name: checkout
        uses: actions/checkout@v4
      - name: restore-m-blueprints
        uses: actions/download-artifact@v3
        with:
          name: m-blueprints
          path: {ci_dir}
      - name: chmod
        run: chmod +x {ci_dir}/*.sh
      - {docker_login}
      {build_steps}

  manifest:
    runs-on: {default_runner}
    needs: [blueprints, build]
    strategy:
      matrix:
        image-name: ${{{{ fromJSON(needs.blueprints.outputs.image-names) }}}}
        image-tag: ${{{{ fromJSON(needs.blueprints.outputs.image-tags) }}}}
    steps:
      - {docker_login}
      - name: create
        run: {create_manifest}
      - name: push
        run: {push_manifest}
"""


class TemplateVars(BaseModel):
    """Template variables."""

    m_dir: str

    ci_dir: str

    default_runner: str

    global_env: str

    build_architectures: str

    docker_login: str

    build_steps: str

    create_manifest: str

    push_manifest: str


def _indent(text: str, num: int) -> str:
    spaces = '  ' * num
    return text.replace('\n', f'\n{spaces}', -1)


class Workflow(BaseModel):
    """Helper class to write the `m` workflow."""

    m_dir: str

    ci_dir: str

    global_env: dict[str, str] | None

    default_runner: str

    docker_registry: str

    architectures: dict[str, str | list[str]]

    extra_build_steps: list[dict[str, Any]] | None

    images: list[DockerImage]

    def docker_login_str(self: 'Workflow') -> str:
        """Generate a github action str to login to docker.

        Returns:
            A string to add to the Github workflow.
        """
        login_obj = """\
            name: docker-login
            uses: docker/login-action@v3
            with:
              registry: ghcr.io
              username: ${{ github.actor }}
              password: ${{ secrets.GITHUB_TOKEN }}"""
        return _indent(dedent(login_obj), 4)

    def global_env_str(self: 'Workflow') -> str:
        """Generate a github action str with the global environment variables.

        Returns:
            A string to add to the Github workflow.
        """
        all_vars = {
            'GITHUB_TOKEN': '${{ secrets.GITHUB_TOKEN }}',
            'M_TAG': '${{ inputs.m-tag }}',
            'CACHE_FROM_PR': '${{ inputs.cache-from-pr }}',
            **(self.global_env or {}),
        }
        vars_str = '\n'.join([
            f'  {env_var}: {env_val}'
            for env_var, env_val in all_vars.items()
        ])
        return f'\n{vars_str}'

    def build_architectures(self: 'Workflow') -> str:
        """Generate a github action str with the build architectures.

        Returns:
            A string to add to the Github workflow.
        """
        arch_strs = '\n'.join([
            f'- arch: {arch}\n  os: {os}'
            for arch, os in self.architectures.items()
        ])
        return _indent(f'\n{arch_strs}', 5)

    def build_steps_str(self: 'Workflow') -> str:
        """Generate a github action str for the build steps.

        Returns:
            A string to add to the Github workflow.
        """
        lines: list[str] = []
        for step in self.extra_build_steps or []:
            step_str = _indent(yaml.dumps(step)[:-1], 1)
            lines.append(f'- {step_str}')
        for img in self.images:
            cache_sh = f'{self.ci_dir}/_find-cache.sh'
            build_sh = f'{self.ci_dir}/{img.image_name}.build.sh'
            push_sh = f'{self.ci_dir}/_push-image.sh'
            image_steps = [
                f'- name: {img.image_name} - cache',
                f'  run: {cache_sh} {img.image_name}',
                f'- name: {img.image_name} - build',
                f'  run: {build_sh}',
                f'- name: {img.image_name} - push',
                f'  run: {push_sh} {img.image_name}',
            ]
            lines.extend(image_steps)
        return _indent('\n'.join(lines), 3)

    def create_manifest_str(self: 'Workflow') -> str:
        """Generate the script to create the manifest.

        Returns:
            The manifest create script.
        """
        cmd = 'docker manifest create'
        registry = self.docker_registry
        image = '${{ matrix.image-name }}'
        tag = '${{ matrix.image-tag }}'
        m_tag = '${{ inputs.m-tag }}'
        lines = [f'{cmd} {registry}/{image}:{tag}']
        for arch in self.architectures:
            lines.append(f'  {registry}/{arch}-{image}:{m_tag}')
        full_cmd = ' \\\n'.join(lines)
        return _indent(f'|-\n{full_cmd}', 5)

    def push_manifest_str(self: 'Workflow') -> str:
        """Generate the script to run to push the manifest.

        Returns:
            The command to push.
        """
        cmd = 'docker manifest push'
        registry = self.docker_registry
        image = '${{ matrix.image-name }}'
        tag = '${{ matrix.image-tag }}'
        full_cmd = f'|-\n{cmd} {registry}/{image}:{tag}'
        return _indent(full_cmd, 5)

    def __str__(self: 'Workflow') -> str:
        """Stringify the workflow file.

        Returns:
            The github workflow.
        """
        template_vars = TemplateVars(
            m_dir=self.m_dir,
            default_runner=self.default_runner,
            global_env=self.global_env_str(),
            ci_dir=self.ci_dir,
            build_architectures=self.build_architectures(),
            docker_login=self.docker_login_str(),
            build_steps=self.build_steps_str(),
            create_manifest=self.create_manifest_str(),
            push_manifest=self.push_manifest_str(),
        )
        return TEMPLATE.format(**template_vars.model_dump())
